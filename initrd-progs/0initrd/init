#!/bin/sh

if [ "$(ls /proc)" = "" ]; then
 mount -t proc none /proc
 mount -t sysfs none /sys
 mount -t rootfs -o remount,rw rootfs /
 ln -s /proc/mounts /etc/mtab
fi

export TERM="xterm"
export TERMINFO="/usr/share/terminfo"

export LANG=C #w004
. /DISTRO_SPECS #v412 has DISTRO_VERSION, DISTRO_FILE_PREFIX
[ ! "$DISTRO_DB_SUBNAME" ] && DISTRO_DB_SUBNAME="$DISTRO_COMPAT_VERSION" #121102 fallback if DISTRO_DB_SUBNAME not defined in file DISTRO_SPECS.

PATH="/bin:/sbin"
KERNELVER="$(uname -r)"

# always use DEVTMPFS now.
mount -t devtmpfs devtmpfs /dev
DEVTMPFSFLG=1 #130618 set it from 3builddistro.

#100911 simple filenames specified in DISTRO_SPECS: DISTRO_ZDRVSFS, DISTRO_PUPPYSFS...
Z_DEF_FN="$DISTRO_ZDRVSFS"
F_DEF_FN="$DISTRO_FDRVSFS"
A_DEF_FN="$DISTRO_ADRVSFS"
Y_DEF_FN="$DISTRO_YDRVSFS"
P_DEF_FN="$DISTRO_PUPPYSFS"

[ $loglevel ] && LOGLEVEL=$loglevel #v2.22

fsck_ext() {
# "$1" - partition device - ex: /dev/sdb2
# "$2" - fstype - ex: ext2
 case $2 in
  ext2|ext3|ext4)
   if [ "$(echo "$FSCKDPARTS" | grep "${1}")" = "" ];then
    e2fsck -y ${1} > /dev/console 2>&1
    FSCKDPARTS="${FSCKDPARTS}${1} "
   fi
  ;;
 esac
}

mntfunc() {
 MNT_T="$1"    #ex: vfat
 MNT_DEV="$2"  #ex: /dev/sda1
 MNT_DIR="$3"  #ex: /mnt/sda1
 MNT_O=""
 [ $4 ] && MNT_O="${4}" #ex: noatime
 MNT_DSK="${MNT_DEV:5:3}"
 if [ "$PTRIM" = "yes" -a "$(cat /sys/block/$MNT_DSK/queue/rotational)" = "0" ];then
  if [ "$MNT_T" = "ext4" -o "$MNT_T" = "f2fs" ];then
   if [ "$MNT_O" = "" ];then
    MNT_O="discard"
   else
    MNT_O="${MNT_O},discard"
   fi
  fi
 fi
 case $MNT_T in
  ntfs)
   ntfs-3g $MNT_DEV $MNT_DIR -o umask=0,no_def_opts,noatime,rw,silent 2>/dev/null #default is rw. 130211 add silent.
   ntfsRETVAL=$?
   [ $ntfsRETVAL -eq 0 ] && return 0
   if [ $ntfsRETVAL -eq 14 ];then
    echo -e "\\033[1;31m" >/dev/console #31=red
    echo -n "ERROR: Windows NTFS hibernated partition, cannot mount" > /dev/console
    echo -e "\\033[0;39m" >/dev/console
    return 14
   else
    ntfs-3g $MNT_DEV $MNT_DIR -o umask=0,no_def_opts,noatime,rw,force,silent 2>/dev/null #130211 add silent.
   fi
  ;;
  vfat)
   mount -t $MNT_T -o $VFAT_OUT_PARAM $MNT_DEV $MNT_DIR
  ;;
  *)
   [ "$PFSCKP" = "yes" ] && fsck_ext "$MNT_DEV" "$MNT_T"
   if [ "$MNT_O" = "" ];then
    mount -t $MNT_T $MNT_DEV $MNT_DIR
   else
    mount -t $MNT_T -o $MNT_O $MNT_DEV $MNT_DIR
   fi
  ;;
 esac
 return $?
}

check_status() #args: [-critical] $RET_VAL "$ERROR_MSG"
{
  ERROR_CRITICAL=""
  [ "$1" = "-critical" ] && { ERROR_CRITICAL="yes" ; shift; }
  RET_VAL=$1
  shift
  ERROR_MSG="$@"
  if [ $RET_VAL -eq 0 ] ; then
    /bin/echo -en "\\033[74G" >/dev/console #move to column 72. 110426: 74
    /bin/echo -en "\\033[1;32m" >/dev/console
    /bin/echo -en "done" >/dev/console
    /bin/echo -e "\\033[0;39m" >/dev/console
  else
    /bin/echo -en "\\033[72G" >/dev/console #110426 move to column 72.
    /bin/echo -en "\\033[1;31m" >/dev/console
    /bin/echo -en "failed" >/dev/console
    /bin/echo -e "\\033[0;39m" >/dev/console
    echo -en "\\033[1;35m" >/dev/console #35=purple
    echo -n "Dumping last lines of /tmp/bootinit.log..." >/dev/console
    /bin/echo -e "\\033[0;39m" >/dev/console
    echo -en "\\033[1;31m" >/dev/console #31=red
    cat /tmp/bootinit.log | tail -n 4 >/dev/console
    /bin/echo -en "\\033[0;39m" >/dev/console
    echo -en "\\033[1;35m" >/dev/console #35=purple
    echo -n "Dumping last lines of kernel log..." >/dev/console
    /bin/echo -e "\\033[0;39m" >/dev/console
    echo -en "\\033[1;31m" >/dev/console #31=red
    dmesg | tail -n 4 >/dev/console
    /bin/echo -en "\\033[0;39m" >/dev/console
    #exit to initial ramdisk shell...
    [ "$RDSH" != "" ] && exec /bin/sh >/dev/console 2>&1
    if [ "$ERROR_CRITICAL" = "yes" ] ; then
      echo -en "\\033[1;35m" >/dev/console #35=purple
      [ "$ERROR_MSG" != "" ] && echo "*** $ERROR_MSG" >/dev/console
      echo "*** Error is too critical, dropping out to console..." >/dev/console
      echo -en "\\033[0;39m" >/dev/console
      exec /bin/sh >/dev/console 2>&1
    else
      echo "Pausing for 60 seconds..." >/dev/console
      sleep 60
    fi
  fi
}

decode_spec() {
 ONE_BP_ID=""; ONE_BP_FN=""
 [ "${1}" ] || return
 ONE_BP_ID="$(echo "$1" | cut -f 1 -d ':')"
 ONE_BP_FN="$(echo "$1" | cut -f 2 -d ':')"
 [ "$ONE_BP_FN" = "$ONE_BP_ID" ] && ONE_BP_FN=""
 [ "$ONE_BP_FN" ] && [ "${ONE_BP_FN:0:1}" != "/" ] && ONE_BP_FN="$PSUBDIR/$ONE_BP_FN"
}

decode_id() {
 ONE_PART=""
 [ "${1}" ] || return
 if [ "$(echo -n ${1} | grep -E '^[a-z]+[0-9]')" -a "$(grep -m1 "${1}$" /proc/partitions)" ];then
  ONE_PART="$1"  #is a real partition
 else
  [ "$BLKIDOUT" ] || BLKIDOUT="$(blkid)"
  ONE_PART="$(echo "$BLKIDOUT" | grep -m1 -E "LABEL=.${1}|UUID=.${1}" | cut -f1 -d: | cut -f3 -d/)" #is LABEL or UUID
 fi
}

decode_other_ids() {
 #get ONE_PART from DEV or ID specified in sfs boot params
 decode_id "$Z_BP_ID"
 [ "$ONE_PART" ] && { Z_PART="$ONE_PART"; Z_BP_ID=""; }
 decode_id "$F_BP_ID"
 [ "$ONE_PART" ] && { F_PART="$ONE_PART"; F_BP_ID=""; }
 decode_id "$A_BP_ID"
 [ "$ONE_PART" ] && { A_PART="$ONE_PART"; A_BP_ID=""; }
 decode_id "$Y_BP_ID"
 [ "$ONE_PART" ] && { Y_PART="$ONE_PART"; Y_BP_ID=""; }
 decode_id "$SAVE_BP_ID"
 [ "$ONE_PART" ] && { SAVEPART="$ONE_PART"; PSAVEPART="$ONE_PART"; SAVE_BP_ID=""; }
}

log_part_id() {
# "$1" - partition id - ex: Work or sdc4
 echo "Partition ${1} not found." >> /tmp/bootinit.log
}

ensure_mounted() {
# "$1" - partition - ex: sda3
# "$2" - mountpoint - ex: /mnt/pdrv
 ONE_MP="$(mount | grep -m1 "/dev/${1} " | cut -f 3 -d ' ')"
 [ "$ONE_MP" ] && return
 ONE_FS="$(echo "$HAVE_PARTS" | grep "${1}" | cut -f 2 -d '|')"
 ONE_MP="${2}"
 [ -d "$ONE_MP" ] || mkdir -p $ONE_MP
 mntfunc $ONE_FS /dev/${1} $ONE_MP #-t $ONE_FS /dev/$ONE_PART $ONE_MP
 [ $? -eq 0 ] || { ONE_MP=""; echo "${1} on $ONE_MP as $ONE_FS mount failed." >> /tmp/bootinit.log; }
}

ensure_save_mounted() {
 ensure_mounted "$SAVEPART" "$SAVE_MP"
 SAVE_MP="$ONE_MP"
 [ "$SAVE_MP" ] && SAVE_FS="$ONE_FS"
}

find_drv_file() {
# "$1" - specified filename - ex: /pup/mydrv-1.2.3.sfs
# "$2" - default filename - ex: adrv_tahr_6.0.5.sfs
 ONE_FN=""
 [ "${1}" ] || [ "${2}" ] || return
 if [ "${1}" ];then
  ONE_TRY_FN="${1}"
 else
  ONE_TRY_FN="${PSUBDIR}/${2}"
 fi
 [ -f "${ONE_MP}${ONE_TRY_FN}" ] && ONE_FN="$ONE_TRY_FN"
}

find_onepupdrv() {
# "$1" - partition - ex: sda3
# "$2" - specified filename - ex: /pup/mydrv-1.2.3.sfs
# "$3" - default filename - ex: adrv_tahr_6.0.5.sfs
# "$4" - prefix for "drv" mountpoint - ex: a
 ONE_FN=""
 [ "${2}" ] || [ "${3}" ] || return
 [ "${4}" ] || return
 if [ "${1}" ];then
  ONE_PART="${1}"
 else
  ONE_PART="$P_PART"
 fi
 [ "$ONE_PART" ] || return
 ensure_mounted "$ONE_PART" "/mnt/${4}drv"
 [ "$ONE_MP" ] || return
 find_drv_file "${2}" "${3}"
 [ "$ONE_FN" = "" -a "${2}" ] && echo "$ONE_PART, $ONE_TRY_FN file not found." >> /tmp/bootinit.log
}

setup_loop_sfs() {
# "$1" - sfs filename - ex: /mnt/dev_save/puppy/tahr/puppy_tahr_6.0.5.sfs
 ONE_LOOP="$(losetup -f)"
 losetup $LO_OPT $ONE_LOOP ${1}
 [ $? -eq 0 ] || { LO_OPT=""; losetup $LO_OPT $ONE_LOOP ${1}; }
}

load_sfs_file() {
 [ "$LOADMSG" ] && echo -n "Loading the '${ONE_BASENAME}' ${LOADMSG} file..." > /dev/console
 if [ "$COPY2RAM" = "" ];then
  COPY2RAM="no"
  #if there's heaps of ram, copy puppy.sfs to a tmpfs...
  #v405 fast media plus more than 256MB ram then definitely worth copying to ram...
  SIZESFSK=$(du -k $ONE_FN | cut -f 1)
  SIZESFSK=$(($SIZESFSK + 1000)) #some slack.
  MINRAM2CPY=$(($SIZESFSK * 2)) #100222 technosaurus: in case of very big puppies.
  #decide whether to copy .sfs's to ram
  [ "$PNOCOPY" = "yes" ] || COPYCONTENDER='yes'
  [ "$PCOPY" = "yes" ] && COPYCONTENDER='yes'
  [ "$PRAMONLY" = "yes" ] && COPYCONTENDER='yes'
  [ "$COPYCONTENDER" = "yes" ] && [ $RAMSIZE -gt 400000 ] && [ $RAMSIZE -gt $MINRAM2CPY ] && COPY2RAM="yes"
 fi
 if [ "$COPY2RAM" = "yes" ];then
  SIZEZK=$(du -k $ONE_FN | cut -f 1)
  TFREEK=$(df | grep -m1 ' /mnt/tmpfs' | tr -s ' ' | cut -f 4 -d ' ')
  if [ $TFREEK -gt $SIZEZK ];then
   if [ "$ONE_MP" = "" ];then #101101 humongous initrd.
    mv -af $ONE_FN /mnt/tmpfs/
   else
    [ "$LOADMSG" ] && [ "$COPYMSG" ] && echo -e -n " \\033[1;35m${COPYMSG}\\033[0;39m" > /dev/console #purple.
    cp -af $ONE_FN /mnt/tmpfs/
   fi
   sync
   setup_loop_sfs /mnt/tmpfs/$ONE_BASENAME
  else
   setup_loop_sfs $ONE_FN
   [ "$ONE_PART" != "rootfs" ] && KEEPMOUNTED="${KEEPMOUNTED}${ONE_PART} "
  fi
 else
  setup_loop_sfs $ONE_FN
  [ "$ONE_PART" != "rootfs" ] && KEEPMOUNTED="${KEEPMOUNTED}${ONE_PART} "
 fi
 SFS_MP="/pup_${ONE_SFX}"
 [ "$ONE_SFX" = "p" ] && SFS_MP="/pup_ro2"
 [ -d "$SFS_MP" ] || mkdir $SFS_MP
 mount -r -t squashfs -o noatime $ONE_LOOP $SFS_MP > /dev/console 2>&1
 STATUS=$?
 [ $STATUS -eq 0 ] && ONE_LAYER="$SFS_MP=rr"
 [ "$LOADMSG" ] && check_status $STATUS
}

setup_onepupdrv() {
# "$1" - sfs spec - ex: sdb2,ext4,/pup/mydrv-1.2.3.sfs
# "$2" - suffix for "pup_" branch directory - ex: a
# "$3" - prepend after rw layer indicator - ex: p
 ONE_LAYER=""
 [ "$1" ] || return 1
 [ "$2" ] || return 1
 ONE_PART="$(echo "${1}" | cut -f 1 -d ',')"
 [ "$ONE_PART" ] || return 1
 ONE_REL_FN="$(echo "${1}" | cut -f 3 -d ',')"
 [ "$ONE_REL_FN" ] || return 1
 ONE_SFX="${2}"
 ONE_PREP="${3}"
 if [ "$ONE_PART" = "rootfs" ];then #humongous initrd.
  ONE_MP="" #actually it's '/'.
  COPY2RAM='yes' #actually it is already in ram, but load_sfs_file code puts it in a tmpfs.
 else
  if [ "$ONE_PART" = "$P_PART" ];then
   ONE_MP="$P_MP"
  else
   ONE_MP="$(mount | grep -m1 "/dev/$ONE_PART " | cut -f 3 -d ' ')"
   [ "$ONE_MP" ] || return 2
  fi
 fi
 ONE_FN="${ONE_MP}${ONE_REL_FN}"
 ONE_BASENAME="$(basename $ONE_REL_FN)"
 #validate sfs here
 [ -s "$ONE_FN" ] || return 3 #sfs not Ok
 load_sfs_file
 [ "$ONE_LAYER" ] || return 4 #sfs mount failed
 if [ "$ONE_PREP" ];then
  mount -o remount,add:1:$ONE_LAYER /pup_new
  [ $? -eq 0 ] || return 5
 else
  mount -o remount,append:$ONE_LAYER /pup_new
  [ $? -eq 0 ] || return 5
 fi
 NEWUNIONRECORD="${NEWUNIONRECORD}${ONE_BASENAME} "
 return 0
}

resize_ext_file() {
 . $RESIZE_FN
 [ "$PUPSAVEFILEX" = "$SAVE_REL_FN" ] || return
 if [ ! -e /bin/e2fsck ];then
  echo -e -n "\\033[1;31m SORRY, cannot resize ${PUPSAVEFILEX} \\033[0;39m" > /dev/console #31=red
  rm -f $RESIZE_FN
 else
  SAVE_SZ_FN="$SAVE_FN"
  rm -f $RESIZE_FN
  echo > /dev/console
  echo -n "Increasing $PUPSAVEFILEX by $KILOBIG Kbytes, please wait..." >/dev/console
  dd if=/dev/zero bs=1024 count=$KILOBIG >> $SAVE_SZ_FN #131225 
  sync
 fi
}

resize_ext_fs() {
 fsck_ext ${1} ${2}
 resize2fs -pf ${1} #no size, will fill all of file.
 sync
 check_status 0 #note, e2fsck gives an error even though it works. v2.21 maybe okay now.
 echo -n "...continuing with loading $PUPSAVEFILE..." > /dev/console
}

load_ext_file() {
 SAVE_SZ_FN=""
 RESIZE_FN="$(dirname $SAVE_FN)/pupsaveresizenew.txt"
#delete following line when resize file location is fixed
 [ -f "$RESIZE_FN" ] || RESIZE_FN="$SAVE_MP/pupsaveresizenew.txt"
 [ -f "$RESIZE_FN" ] && resize_ext_file
 ONE_LOOP="$(losetup -f)"
 losetup $ONE_LOOP $SAVE_FN
 SFFS='ext'$(echo -n "$SAVE_FN" | rev | cut -c 3)
 [ "$PFSCK" = "yes" ] && { echo "" > /dev/console; fsck_ext "$ONE_LOOP" "$SFFS"; }
 [ "$SAVE_SZ_FN" ] && resize_ext_fs "$ONE_LOOP" "$SFFS"
 [ -d "$SAVE_LAYER" ] || mkdir $SAVE_LAYER
 mount -t $SFFS -o noatime $ONE_LOOP $SAVE_LAYER
 [ $? -eq 0 ] || PUPSAVE=""  
}

setup_save_file(){
 SAVE_REL_FN="$(echo "$PUPSAVE" | cut -f 3 -d ',')"
 echo -n "Loading personal storage $SAVE_REL_FN ($SAVEPART)..." > /dev/console 
 rm -r -f "$SAVE_LAYER"
 SAVE_FN="${SAVE_MP}${SAVE_REL_FN}"
 if [ -f "$SAVE_FN" ];then #savefile
  load_ext_file
 elif [ -d "$SAVE_FN" ];then #savefolder
  ln -s "$SAVE_FN" "$SAVE_LAYER"
 else
  PUPSAVE=""
 fi
#[ "$PUPSAVE" ] && decrypt directory at SAVE_LAYER
 if [ "$PUPSAVE" ];then
  SAVE_NAME="$(basename $SAVE_REL_FN)"
  check_status 0
  OLDDISTRO_VERSION="$(grep '^DISTRO_VERSION' $SAVE_FN/etc/DISTRO_SPECS | cut -f 2 -d '=' | cut -f 2 -d "'" | cut -f 2 -d '"' | cut -f 1 -d ' ')"
  if [ "$DISTRO_VERSION" != "$OLDDISTRO_VERSION" ]; then
   echo -en "\\033[1;36m" >/dev/console #36=aquablue
   echo "This personal storage was last used with version $OLDDISTRO_VERSION of Puppy." >/dev/console
   echo "Hit the ENTER key only if it is okay to upgrade this file, or to not use it and boot up in RAM only type any other printable character."  >/dev/console
   echo -n "ENTER only to upgrade: "  >/dev/console
   echo -en "\\033[0;39m" >/dev/console
   read noupgradesf
   if [ "$noupgradesf" != "" ];then
    echo -en "\\033[1;35m" >/dev/console #35=purple
    echo "Backing off, not using personal storage, booting in RAM only, PUPMODE=5..." >/dev/console
    echo -en "\\033[0;39m" >/dev/console
    PUPSAVE=""
   #else
    #do upgrade processing
   fi
  fi
 else
  check_status 1
 fi
 [ "$PUPSAVE" ] || { PUPMODE=5; SAVE_MP=""; SAVE_LAYER=""; }
}

setup_save_part() {
 rm -r -f $SAVE_LAYER
 ln -s $SAVE_MP $SAVE_LAYER
 SAVE_NAME="$SAVEPART"
}

copy_folders() {
 DESTDIR="/mnt/tmpfs/pup_ro1"
 [ -d "$DESTDIR" ] || mkdir -p $DESTDIR
 ln -s $DESTDIR $SAVE_LAYER
 BKFOLDERS="$(ls -1 -r $SAVE_MP | grep '^20[0-9][0-9]')"
 BKLASTFOLDER="$(echo "$BKFOLDERS" | head -n 1)"
 #a boot option allows ignore last n sessions, also need to create a badlist...
 if [ "$PIGNORELAST" ];then
  BKBADLIST="$(echo "$BKFOLDERS" | head -n ${PIGNORELAST})"
  if [ -f $SAVE_MP/$BKLASTFOLDER/.badfolders ];then
   cp $SAVE_MP/$BKLASTFOLDER/.badfolders $DESTDIR/
   if [ $? -ne 0 ];then
    #fallback, in case last folder badly corrupted...
    BKPREVFOLDER="$(echo "$BKFOLDERS" | head -n 2 | tail -n 1)"
    [ -f $SAVE_MP/$BKPREVFOLDER/.badfolders ] && cp $SAVE_MP/$BKPREVFOLDER/.badfolders $DESTDIR/
   fi
  fi
  echo "$BKBADLIST" >> $DESTDIR/.badfolders
  #note, rc.shutdown and savesession-dvd 'touch' this file so it will get saved.
  sync
 else
  [ -f $SAVE_MP/$BKLASTFOLDER/.badfolders ] && cp $SAVE_MP/$BKLASTFOLDER/.badfolders $DESTDIR/
 fi
 [ -f $DESTDIR/.badfolders ] && BKBADLIST="$(cat $DESTDIR/.badfolders | tr "\n" " ")"
 BKFOLDERS="$(echo -n "$BKFOLDERS" | tr "\n" " ")"
 for ONEFOLDER in $BKFOLDERS;do
  if [ ! "$(echo -n "$BKBADLIST" | grep "$ONEFOLDER")" = "" ];then
   echo "Folder $ONEFOLDER marked bad." >/dev/console
   continue #ignore bad folder.
  fi
  echo -n "Loading folder $ONEFOLDER from CD/DVD..." >/dev/console
  #need to be careful not to overfill the ramdisk...
  FREERAMDISK=$(df 2>/dev/null | grep /mnt/tmpfs | head -n 1 | tr -s " " | cut -f 4 -d " ")
  SIZEFOLDER=$(du -k -s ${SAVE_MP}/${ONEFOLDER} | cut -f 1)
  if [ -d ${SAVE_MP}/${ONEFOLDER}/archive ];then
   SIZEARCHIVE=$(du -k -s ${SAVE_MP}/${ONEFOLDER}/archive | cut -f 1)
  else
   SIZEARCHIVE=0
  fi
  SIZESOURCE=$(expr $SIZEFOLDER - $SIZEARCHIVE)
  if [ $FREERAMDISK -gt $SIZESOURCE ];then
   #well, -u will only copy if files newer, so less stuff may get copied than calc'd above.
   #need to copy everything except archive folder...
   [ -d $SAVE_MP/$ONEFOLDER/bin ] && cp -a -u $SAVE_MP/$ONEFOLDER/bin $DESTDIR/   > /dev/null 2>&1
   [ -d $SAVE_MP/$ONEFOLDER/sbin ] && cp -a -u $SAVE_MP/$ONEFOLDER/sbin $DESTDIR/   > /dev/null 2>&1
   [ -d $SAVE_MP/$ONEFOLDER/etc ] && cp -a -u $SAVE_MP/$ONEFOLDER/etc $DESTDIR/   > /dev/null 2>&1
   [ -d $SAVE_MP/$ONEFOLDER/lib ] && cp -a -u $SAVE_MP/$ONEFOLDER/lib $DESTDIR/   > /dev/null 2>&1
   [ -d $SAVE_MP/$ONEFOLDER/opt ] && cp -a -u $SAVE_MP/$ONEFOLDER/opt $DESTDIR/   > /dev/null 2>&1
   if [ -d $SAVE_MP/$ONEFOLDER/root/.var_saved ];then #100820 see /etc/rc.d/functions4puppy
    mkdir -p $DESTDIR/var
    cp -a -u $SAVE_MP/$ONEFOLDER/root/.var_saved/* $DESTDIR/var/ > /dev/null 2>&1
   fi
   [ -d $SAVE_MP/$ONEFOLDER/root ] && cp -a -u $SAVE_MP/$ONEFOLDER/root $DESTDIR/   > /dev/null 2>&1
   [ -d $SAVE_MP/$ONEFOLDER/root/.var_saved ] && rm -rf $DESTDIR/root/.var_saved > /dev/null 2>&1 #100820
   [ -d $SAVE_MP/$ONEFOLDER/usr ] && cp -a -u $SAVE_MP/$ONEFOLDER/usr $DESTDIR/   > /dev/null 2>&1
   [ $DEVTMPFSFLG -eq 0 ] && [ -d $SAVE_MP/$ONEFOLDER/dev ] && cp -a -u $SAVE_MP/$ONEFOLDER/dev $DESTDIR/   > /dev/null 2>&1 #v411 130612
   cp -a -u $SAVE_MP/$ONEFOLDER/*.sfs $DESTDIR/   > /dev/null 2>&1 #v3.97
   #delete deleted files (.wh.filename)... 110212 screen out .wh..wh..opq
   WHITEOUTS="$(find $DESTDIR -xdev -type f -name .wh.* | grep -v '__dir_opaque' | grep -v '.wh..wh.')" #110212
   echo "$WHITEOUTS" |
   while read DELWHITE;do
    DELFILE="$(echo -n "$DELWHITE" | sed -e 's/\\.wh\\.//g')"
    if [ -e "$DELFILE" ];then
     rm -rf "$DELFILE"
     rm -rf "$DELWHITE"
    fi
   done
   check_status 0 #display 'done' for each folder loaded.
  else
   echo -n "RAM disk full, copy failed at $ONEFOLDER" >> /tmp/bootinit.log
   check_status 1
   break
  fi
 done
 sync
}

prepend_dir() {
 rm -r -f ${SAVE_LAYER}/tmp #in case last boot was pupmode=12
 #adjust stack
 mount -o remount,add:1:${SAVE_LAYER}=ro+wh /pup_new
 if [ $? -eq 0 ];then
  KEEPMOUNTED="${KEEPMOUNTED}${SAVEPART} "
  [ "$SAVE_NAME" ] && NEWUNIONRECORD="$SAVE_NAME $NEWUNIONRECORD"
 else
  echo "adding $SAVE_LAYER to aufs stack failed." >> /tmp/bootinit.log
 fi
}

replace_dir() {
 #setup empty /tmp on tmpfs for after switch
 rm -r -f ${SAVE_LAYER}/tmp
 mkdir -p /mnt/tmpfs/tmp
 ln -s /initrd/mnt/tmpfs/tmp ${SAVE_LAYER}/tmp
 #adjust stack
 mount -o remount,prepend:${SAVE_LAYER}=rw,mod:/mnt/tmpfs/pup_rw=ro,del:/mnt/tmpfs/pup_rw /pup_new
 if [ $? -eq 0 ];then
  rm -r -f /mnt/tmpfs/pup_rw
  KEEPMOUNTED="${KEEPMOUNTED}${SAVEPART} "
  [ "$SAVE_NAME" ] && NEWUNIONRECORD="$SAVE_NAME $NEWUNIONRECORD"
 else
  echo "adding $SAVE_LAYER to aufs stack failed." >> /tmp/bootinit.log
 fi
}

set_fs_linux() {
# "$1" - file system type - ex: ext4
 ONE_FS_IS_LINUX=""
 case ${1} in
  ext2|ext3|ext4|reiserfs|minix|f2fs) ONE_FS_IS_LINUX="yes" ;;
 esac
}

find_save_file() {
# "$1" - mount point - ex:  /mnt/pdrv
# "$2" - partition name - ex: sdb2
# "$3" - file system type - ex: ext4
 if [ "$ONE_FS_IS_LINUX" = "yes" ];then
  SAVE_FILES="$(ls -d ${1}${PSUBDIR}/${DISTRO_FILE_PREFIX}save* 2>/dev/null)"
 else
  SAVE_FILES="$(ls -d ${1}${PSUBDIR}/${DISTRO_FILE_PREFIX}save*.?fs 2>/dev/null)"
 fi
 for ONE_SAVE in $SAVE_FILES;do
  #validate savefiles here
  [ -d "$ONE_SAVE" -o -s "$ONE_SAVE" ] && PUPSAVES="${PUPSAVES}${2},${3},${PSUBDIR}/$(basename $ONE_SAVE) "
 done
}

search_func() {
 if [ "${1}" ];then
  TRY_PARTS="$(echo "$HAVE_PARTS" | grep -E "${1}")"
 else
  TRY_PARTS="$HAVE_PARTS"
 fi
 [ "$TRY_PARTS" ] || return
 for ONETRY in $TRY_PARTS;do
  ONE_PART="$(echo -n "$ONETRY" | cut -f 1 -d '|')"
  ensure_mounted "$ONE_PART" "/mnt/pdrv"
  if [ "$ONE_MP" ];then
   if [ "$LOOK_SAVE" ];then
    set_fs_linux "$ONE_FS"
    find_save_file "$ONE_MP" "$ONE_PART" "$ONE_FS"
   fi
   if [ "$LOOK_PUP" ];then
    find_drv_file "$P_BP_FN" "$P_DEF_FN"
    if [ "$ONE_FN" ];then
     PDRV="$ONE_PART,$ONE_FS,$ONE_FN"
     P_MP="$ONE_MP"
     P_PART="$ONE_PART"
     break;
    fi
   fi
   umount $ONE_MP
  fi
 done 
}

get_part_info() {
 ls -1 /sys/block | grep -E '^scd|^sd|^mmc|^sr' > /tmp/ALLDRVS0
 PCPARTSALL="$(/sbin/probepart_init -k)"
 HAVE_PARTS="$(echo "$PCPARTSALL" | grep '^/dev/' | cut -f 1-2 -d '|'  | grep -E 'f2fs|udf|iso9660|ext2|ext3|ext4|reiserfs|msdos|vfat|minix|ntfs' | sed -e 's%/dev/%%')"
}

wait_for_usb() {
 [ -e /tmp/flag-usb-ready ] && return
 echo -n "Waiting for USB storage." > /dev/console 
 /sbin/wait4usb
 get_part_info
 BLKIDOUT=""
 check_status 0
}

umount_unneeded() {
 MTD_PARTS="$(mount | cut -f1 -d' ' | grep '^/dev' | grep -v loop | cut -f3 -d'/')"
 for ONE_PART in $MTD_PARTS;do
  [ "$(echo -n "$KEEPMOUNTED" | grep "$ONE_PART")" ] || umount /dev/$ONE_PART
 done
}

fatal_error() {
# "$1" - message - ex: puppy_tahr_6.0.5.sfs not found
# "$2" - pre-status-message - ex: Finding puppy
 KEEPMOUNTED=""
 umount_unneeded
 [ "${2}" ] && echo -n "${2}" > /dev/console
 check_status -critical 1 "$1"
}

[ $plang ] && PLANG=$plang #boot parameter
[ $pkeys ] && PKEYS=$pkeys #boot parameter, keyboard layout w476
#pmedia= usbflash|usbhd|usbcd|ataflash|atahd|atacd|atazip|scsihd|scsicd|cd
[ $pmedia ] && PMEDIA=$pmedia #boot parameter, broad category of boot media. ex: cd.
[ $psubdir ] && PSUBDIR=$psubdir #boot parameter, directory for puppy files. ex: puppy220
[ $psavemark ] && PSAVEMARK=$psavemark #100913 partition number that has/will-have save-file.

[ $PSUBDIR ] && [ "${PSUBDIR:0:1}" != "/" ] && PSUBDIR="/${PSUBDIR}" #add leading /.

[ $pdev1 ] && PDRV=$pdev1 #boot parameter, partition have booted off. ex: hda3
#100915 requested by technosaurus (formats get changed further down)...
[ $pdrv ] && PDRV=$pdrv #format partition:<path><filename> ex: sda2:/slacko/puppy_slacko_6.3.0.sfs
[ $pupsfs ] && PDRV=$pupsfs
[ $zdrv ] && ZDRV=$zdrv #ex: sda2:/slacko/zdrv_slacko_6.3.0.sfs
[ $fdrv ] && FDRV=$fdrv
[ $adrv ] && ADRV=$adrv
[ $ydrv ] && YDRV=$ydrv
#<partition>:<filename>, for savefile/savefolder. <partition> can be a name or Label or UUID
[ $psave ] && PSAVE=$psave #ex: sdb4:/puppy/tahr/tahrsave or smark or 49baa82d-8c69:tahrsave

#list of kernel modules to load, ex: pimod=hid-logitech-dj.ko,kernel/drivers/hid/hid-multitouch.ko 
[ $pimod ] && PIMOD=$pimod

RDSH=""
if [ "$pfix" ];then
 for ONEFIX in $(echo -n "$pfix" | tr ',' ' ')
 do
  case $ONEFIX in
   ram)     PRAMONLY="yes";;      #run in ram only (do not load ${DISTRO_FILE_PREFIX}save).
   rdsh)    RDSH="yes";;          #exit to shell in initial ramdisk.
   nox)     PNOX="yes";;          #do not start X.
   clean)   PCLEAN="yes";;        #force version upgrade and cleanup.
   purge)   PPURGE="yes";;        #radical cleanup for broken system.
   trim)    PTRIM="yes";;         #add "discard" to mount options if SSD
   copy)    PCOPY="yes";;         #copy .sfs files into ram.
   nocopy)  PNOCOPY="yes";;        #do not copy .sfs files into ram (default is copy if enough ram).
   fsck)    PFSCK="yes";;         #do a fsck of ${DISTRO_FILE_PREFIX}save file.
   fsckp)   PFSCKP="yes";;        #do fsck before first mount of ext partitions
   [0-9]*)  PIGNORELAST=$ONEFIX;; #blacklist last $ONEFIX folders (multisession).
  esac
 done
fi

clear #clear the screen.
[ ! "$LOGLEVEL" ] && exec 1>/tmp/bootinit.log 2>&1 #remove o/p from console. v2.22 loglevel added.

export TZ='XXX-20'
/bin/hwclock -l -s

#120216 /PUPPYKEYMAP inserted in initrd by quicksetup (in future, by Woof too)...
FONTMAP=""
[ -f /PUPPYKEYMAP ] && [ ! "$PKEYS" ] && PKEYS="`cat /PUPPYKEYMAP`" #allow kernel boot param to override.
if [ "$PLANG" ];then
 if [ ! "$PKEYS" ];then
  #try to set PKEYS to match the language. first 2 letters of PLANG...
  PKEYS=${PLANG:0:2} #rough as guts, assign first 2 chars of PLANG to PKEYS.
  case $PLANG in
   en*) PKEYS=us ;;
  esac
 fi
 #120216 L18L suggests load these, instead of what is below...
 case $PLANG in
  en*) echo ;;
  ar*|iw*) #L18L no Greek
   setfont /lib/consolefonts/LatArCyrHeb-16.psfu.gz -C /dev/tty1
   FONTMAP='LatArCyrHeb-16.psfu'
  ;;
  ru*) #vkvkvk for ru
   zcat /lib/consolefonts/ter-u16n.psf.gz | loadfont
   FONTMAP='ter-u16n.psf'
  ;;
  *) #L18L All European languages; new default ?!
   zcat /lib/consolefonts/LatGrkCyr-8x16.psfu.gz | loadfont
   FONTMAP='LatGrkCyr-8x16.psfu'
  ;;
 esac
fi

#091122 load keyboard layout if PKEYS boot param...
STATUS=0
VFAT_OUT_PARAM='shortname=mixed,quiet,utf8'
CODEPAGE=""
KMAP=""
if [ "$PKEYS" ];then
 if [ ! -f /lib/keymaps/${PKEYS}.gz ];then
  PKEYS="`ls -1 /lib/keymaps/${PKEYS}*.gz | head -n 1 | rev | cut -f 1 -d '/' | cut -f 2 -d '.' | rev`"
 fi
 if [ -f /lib/keymaps/${PKEYS}.gz ];then
  echo "Loading '${PKEYS}' keyboard layout..." >/dev/console
  KMAP="$PKEYS"
  zcat /lib/keymaps/${PKEYS}.gz | loadkmap ; STATUS=$(($STATUS + $?))
  case $PKEYS in #note, same code in /etc/rc.d/rc.country, /usr/sbin/input-wizard and init.
   de*|be*|br*|dk*|es*|fi*|fr*|it*|no*|se*|pt*)
    [ ! "$PLANG" ] && FONTMAP="lat1-12.psfu" #120216
    CODEPAGE="850"
    VFAT_OUT_PARAM="$OUT_PARAM"',codepage=850'
   ;;
   cz*|hu*|pl*|ro*|sk*|croat*|slovene*)
    [ ! "$PLANG" ] && FONTMAP="lat2-12.psfu" #120216
    CODEPAGE="852"
    VFAT_OUT_PARAM="$OUT_PARAM"',codepage=852,iocharset=iso8859-2'
   ;;
  esac
  if [ ! "$PLANG" ];then #120216 old behaviour.
   if [ "$FONTMAP" ];then #100520 fix syntax error...
    zcat /lib/consolefonts/${FONTMAP}.gz | loadfont
    STATUS=$(($STATUS + $?))
   fi
  fi
  check_status $STATUS
 fi
fi

#100915 technosaurus recommendation (see above)...
[ "$PDRV" ] && { decode_spec "$PDRV"; P_BP_ID="$ONE_BP_ID"; P_BP_FN="$ONE_BP_FN"; PDRV=""; }
[ "$ZDRV" ] && { decode_spec "$ZDRV"; Z_BP_ID="$ONE_BP_ID"; Z_BP_FN="$ONE_BP_FN"; ZDRV=""; }
[ "$FDRV" ] && { decode_spec "$FDRV"; F_BP_ID="$ONE_BP_ID"; F_BP_FN="$ONE_BP_FN"; FDRV=""; }	
[ "$ADRV" ] && { decode_spec "$ADRV"; A_BP_ID="$ONE_BP_ID"; A_BP_FN="$ONE_BP_FN"; ADRV=""; }
[ "$YDRV" ] && { decode_spec "$YDRV"; Y_BP_ID="$ONE_BP_ID"; Y_BP_FN="$ONE_BP_FN"; YDRV=""; }
[ "$PSAVE" ] && { decode_spec "$PSAVE"; SAVE_BP_ID="$ONE_BP_ID"; SAVE_BP_FN="$ONE_BP_FN"; }

#first look inside initrd...
#unset x_DEF_FN so that find_onepupdrv() won't look for it
[ -f /${P_DEF_FN} ] && { PDRV="rootfs,rootfs,/$P_DEF_FN"; P_DEF_FN=""; }
[ -f /${Z_DEF_FN} ] && { ZDRV="rootfs,rootfs,/$Z_DEF_FN"; Z_DEF_FN=""; }
[ -f /${F_DEF_FN} ] && { FDRV="rootfs,rootfs,/$F_DEF_FN"; F_DEF_FN=""; }
[ -f /${A_DEF_FN} ] && { ADRV="rootfs,rootfs,/$A_DEF_FN"; A_DEF_FN=""; }
[ -f /${Y_DEF_FN} ] && { YDRV="rootfs,rootfs,/$Y_DEF_FN"; Y_DEF_FN=""; }

get_part_info
grep -v '^sr' /tmp/ALLDRVS0 > /tmp/ATADRIVES0
ATAOPTICALDRIVES="$(grep '^sr' /tmp/ALLDRVS0 | tr '\n' ' ')"

PUPSAVES=""
KEEPMOUNTED=""
FSCKDPARTS=""
BLKIDOUT=""
LO_OPT="-r"

#establish PDRV
P_PART=""; LOOK_PUP=""; LOOK_SAVE=""
if [ "$P_BP_ID" ];then #specified as parameter
 decode_id "$P_BP_ID"
 [ "$ONE_PART" ] && { P_PART="$ONE_PART"; P_BP_ID=""; }
 if [ "$P_PART"  = "" ];then
  wait_for_usb
  decode_id "$P_BP_ID"
  [ "$ONE_PART" ] && { P_PART="$ONE_PART"; P_BP_ID=""; }
 fi
 find_onepupdrv "$P_PART" "$P_BP_FN" "$P_DEF_FN" "p"
 [ "$ONE_FN" ] && { PDRV="$ONE_PART,$ONE_FS,$ONE_FN"; P_MP="$ONE_MP"; }
elif [ "$PDRV" = "" ];then #not specified anywhere
 #determine what to search for
 [ "$PMEDIA" = "cd" ] && LOOK_SAVE="yes"
 [ "$SAVE_BP_ID" -o "$PSAVEMARK" ] && LOOK_SAVE=""
 LOOK_PUP=yes
fi
if [ "$LOOK_PUP" -o "$LOOK_SAVE" ];then #something to search for
 [ "${PMEDIA:0:3}" != "usb" ] && search_func
 if [ "$P_PART" = "" ];then
  wait_for_usb
  USBDRVS="$(find /sys/block -maxdepth 1 -name 'sd*' -o -name 'sr*' | xargs -n 1 readlink 2>/dev/null | grep '/usb[0-9]' | rev | cut -f 1 -d '/' | rev | tr '\n' ' ')"
  [ "$USBDRVS" ] && search_func "$(echo -n $USBDRVS | tr ' ' '|')"
 fi
fi
[ "$P_BP_ID" ] && { log_part_id "$P_BP_ID"; ONE_PART="$P_BP_ID"; }
if [ "$PDRV" = "" ];then
 [ "$ONE_TRY_FN" ] || ONE_TRY_FN="$PSUBDIR/$P_DEF_FN"
 fatal_error "$ONE_PART $ONE_TRY_FN not found." "Finding puppy main sfs file."
fi

#establish SAVEPART
decode_other_ids
if [ "$Z_BP_ID" -o "$F_BP_ID" -o "$A_BP_ID" -o "$Y_BP_ID" -o "$SAVE_BP_ID" ];then
 wait_for_usb
 decode_other_ids
fi
if [ "$P_PART" ];then
 BOOTDRV="$(echo -n "$P_PART" | grep -o -f /tmp/ALLDRVS0)" #110205 ex: sda1 becomes sda.
 if [ "$SAVEPART" = "" ];then #setup SAVEPART
  [ "$P_MP" ] || P_MP="$(mount | grep -m1 "/dev/$P_PART " | cut -f 3 -d ' ')"
  [ -f ${P_MP}${PSUBDIR}/SAVEMARK ] && PSAVEMARK="$(cat ${P_MP}${PSUBDIR}/SAVEMARK)" #partition no. that has or will-have ${DISTRO_FILE_PREFIX}save.2fs. 101020
  [ "$PSAVEMARK" ] && SAVEPART="${BOOTDRV}${PSAVEMARK}" #note, PSAVEMARK could also be a kernel boot param. ex: sda2
  [ "$SAVEPART" ] || SAVEPART="$P_PART"
 fi
fi
#ensure SAVEPART is mounted on /mnt/dev_save
SAVE_MP="/mnt/dev_save"
if [ "$SAVEPART" -a "$SAVEPART" = "$P_PART" ];then
 #this mount move needs to be done before loading any sfs's
 [ -d "$SAVE_MP" ] || mkdir -p $SAVE_MP
 [ "$P_MP" ] && { mount -o move $P_MP $SAVE_MP; P_MP="$SAVE_MP"; } 
fi

#have pup...sfs, now try to load it
RAMSIZE=$(free | grep -o 'Mem: .*' | tr -s ' ' | cut -f 2 -d ' ') #total physical ram (less shared video). 110405

mount -t tmpfs tmpfs /mnt/tmpfs
[ -d "/mnt/tmpfs/pup_rw" ] || mkdir /mnt/tmpfs/pup_rw
mount -t aufs -o udba=reval,diropq=w,br=/mnt/tmpfs/pup_rw=rw,xino=/mnt/tmpfs/.aufs.xino unionfs /pup_new 
[ $? -eq 0 ] || fatal_error "Failed to create empty aufs stack"

NEWUNIONRECORD=""
COPY2RAM=""

COPYMSG='copying to ram' #purple
LOADMSG="main"
setup_onepupdrv "$PDRV" "p"
STATUS=$?
if [ $STATUS -gt 0 ];then
 P_PRE_MSG="Loading puppy main sfs file."
 case $STATUS in
  1)
   fatal_error "$PDRV information is incomplete." "$P_PRE_MSG" ;;
  2)
   fatal_error "$ONE_PART is not mounted." "$P_PRE_MSG" ;;
  3)
   fatal_error "$ONE_PART $ONE_REL_FN is not Ok." "$P_PRE_MSG" ;;
  4)
   fatal_error "$ONE_PART $ONE_REL_FN mount of sfs failed." "$P_PRE_MSG" ;;
  5)
   fatal_error "aufs mount of $ONE_LAYER failed." "$P_PRE_MSG" ;;
 esac
fi
PUP_LAYER="$SFS_MP"

#all partition id's should be decoded by now
[ "$Z_BP_ID" ] && log_part_id "$Z_BP_ID"
[ "$F_BP_ID" ] && log_part_id "$F_BP_ID"
[ "$A_BP_ID" ] && log_part_id "$A_BP_ID"
[ "$Y_BP_ID" ] && log_part_id "$Y_BP_ID"
[ "$SAVE_BP_ID" ] && log_part_id "$SAVE_BP_ID"

#have basic system, now try to add optional stuff
find_onepupdrv "$F_PART" "$F_BP_FN" "$F_DEF_FN" "f"
[ "$ONE_FN" ] && FDRV="$ONE_PART,$ONE_FS,$ONE_FN"
[ "$FDRV" ] && { LOADMSG="fdrv"; setup_onepupdrv "$FDRV" "f"; }

find_onepupdrv "$Z_PART" "$Z_BP_FN" "$Z_DEF_FN" "z"
[ "$ONE_FN" ] && ZDRV="$ONE_PART,$ONE_FS,$ONE_FN"
[ "$ZDRV" ] && { LOADMSG="zdrv"; setup_onepupdrv "$ZDRV" "z"; }

find_onepupdrv "$Y_PART" "$Y_BP_FN" "$Y_DEF_FN" "y"
[ "$ONE_FN" ] && YDRV="$ONE_PART,$ONE_FS,$ONE_FN"
[ "$YDRV" ] && { LOADMSG="ydrv"; setup_onepupdrv "$YDRV" "y" "p"; }

find_onepupdrv "$A_PART" "$A_BP_FN" "$A_DEF_FN" "a"
[ "$ONE_FN" ] && ADRV="$ONE_PART,$ONE_FS,$ONE_FN"
[ "$ADRV" ] && { LOADMSG="adrv"; setup_onepupdrv "$ADRV" "a" "p"; }

#insmod modules needed by keyboard
if [ "$PIMOD" != "" ];then
 [ -d /lib/modules ] && mv -f /lib/modules /lib/modules.bak
 ln -s /pup_new/lib/modules /lib/modules
 [ -d /lib/firmware ] && mv -f /lib/firmware /lib/firmware.bak
 ln -s /pup_new/lib/firmware /lib/firmware
 MODSPATH="/lib/modules/$KERNELVER"
 for ONEMOD in `echo -n "$PIMOD" | tr ',' ' '`;do
  CURMOD=""
  if [ -f "${MODSPATH}/${ONEMOD}" ];then
   CURMOD="$ONEMOD"
  else
   CURMOD="`grep -m1 $ONEMOD $MODSPATH/modules.order`"
   if [ "$CURMOD" = "" ];then
    MODPATN="`echo -n "$ONEMOD" | tr '_' '-'`"
    CURMOD="`grep -m1 "$MODPATN" $MODSPATH/modules.order`"
   fi
   [ -f "${MODSPATH}/${CURMOD}" ] || CURMOD=""
  fi
  if [ "$CURMOD" != "" ];then
   echo -n "Adding module $CURMOD" > /dev/console
   insmod "${MODSPATH}/${CURMOD}" > /dev/console 2>&1
   check_status $?
  fi
 done
 rm -f /lib/modules
 [ -d /lib/modules.bak ] && mv /lib/modules.bak /lib/modules
 rm -f /lib/firmware
 [ -d /lib/firmware.bak ] && mv /lib/firmware.bak /lib/firmware
fi

#ensure that save partition is mounted
[ "$SAVEPART" ] && ensure_save_mounted

#find PUPSAVE, sortout pupmode
PUPMODE=5
PUPSAVE=""
if [ "$SAVE_MP" -a "$PRAMONLY" != "yes" ];then #have mounted save? partition
 #check if save partition is linux
 set_fs_linux "$SAVE_FS"
 #check for cd multisession
 if [ "$(ls -l /dev/$BOOTDRV | cut -f4 -d' ')" = "cdrom" ];then #booting on optical, is it multisession?...
  FND_MULTIFOLDER="$(find $SAVE_MP -maxdepth 1 -xdev -type d -name 20[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9] | grep -v ' ' | sed -e 's%^/mnt/pdrv%%' | head -n 1)"
  if [ "$FND_MULTIFOLDER" ];then #multisession cd/dvd
   PUPMODE=77
   PUPSAVE="${SAVEPART},${SAVE_FS},${FND_MULTIFOLDER}"
  fi
 fi
 #check for save to partition 
 if [ "$ONE_FS_IS_LINUX" = "yes" -a "$PSUBDIR" = "" -a -f "$SAVE_MP/etc/rc.d/PUPSTATE" ];then
  PUPMODE=6
  PUPSAVE="${SAVEPART},${SAVE_FS},/"
 fi
 #not sorted yet, may be pupmode=12
 if [ $PUPMODE -eq 5 ];then
  #check boot spec
  if [ "$SAVE_BP_FN" ];then
   if [ -d "${SAVE_MP}${SAVE_BP_FN}" ];then
    [ "$ONE_FS_IS_LINUX" = "yes" ] && PUPSAVE="$SAVEPART,$SAVE_FS,$SAVE_BP_FN"
   else
    [ -s "${SAVE_MP}${SAVE_BP_FN}" ] && PUPSAVE="$SAVEPART,$SAVE_FS,$SAVE_BP_FN"
   fi
   [ "$PUPSAVE" ] || echo "$SAVEPART, $SAVE_BP_FN file not found." >> /tmp/bootinit.log
  else
   #have to find savefile/savefolder
   [ "$PUPSAVES" ] || find_save_file "$SAVE_MP" "$SAVEPART" "$SAVE_FS"
   if [ "$PUPSAVES" ];then
    NUMPUPSAVES=0
    for ONE_SAVE in $PUPSAVES;do
     NUMPUPSAVES=$(expr $NUMPUPSAVES + 1)
    done
    if [ $NUMPUPSAVES -eq 1 ];then
     PUPSAVE="$(echo -n $PUPSAVES)"
    elif [ $NUMPUPSAVES -gt 1 ];then
     CNTSAVE=1
     echo -e "\\033[1;36m" >/dev/console #36=aquablue
     echo "Type a number to choose which personal file to use:" > /dev/console
     echo "0  none" > /dev/console
     for ONETRY in $PUPSAVES;do
      ONE_PART="$(echo -n "$ONETRY" | cut -f 1 -d ',')"
      ONE_FILE="$(echo -n "$ONETRY" | cut -f 3 -d ',')"
      echo -e "${CNTSAVE}  ${ONE_PART}\\033[10G${ONE_FILE}" > /dev/console #10 means move to that column.
      CNTSAVE=$(expr $CNTSAVE + 1)
     done
     echo -en "\\033[0;39m" >/dev/console
     read NUMSAVE
     [ $NUMSAVE -ne 0 ] && PUPSAVE="$(echo -n $PUPSAVES | cut -f $NUMSAVE -d ' ')"
    fi
   fi
  fi
  if [ "$PUPSAVE" ];then
   PUPMODE=12
   ONE_PART="$(echo -n "$PUPSAVE" | cut -f 1 -d ',')"
   [ "$ONE_PART" != "$SAVEPART" ] && { SAVEPART="$ONE_PART"; ensure_save_mounted; }
  fi
 fi
fi

SAVE_LAYER=""
if [ "$PUPSAVE" ];then #refine pupmode
 if [ $PUPMODE -eq 6 -o $PUPMODE -eq 12 ];then
  if [ "${PMEDIA:3}" = "flash" ];then
   PUPMODE=$(expr $PUPMODE + 1)
   SAVE_LAYER="/pup_ro1"
  else
   SAVE_LAYER="/pup_rw"
  fi
 fi
fi

#load savefile if required, then setup stack
case $PUPMODE in
 77) #load folders
  copy_folders
  prepend_dir
 ;;
 13) #prepend ro1
  setup_save_file
  [ "$PUPSAVE" ] && prepend_dir
 ;;
 12) #replace rw
  setup_save_file
  [ "$PUPSAVE" ] && replace_dir
 ;;
 7) #prepend ro1
  setup_save_part
  prepend_dir
 ;;
 6) #replace rw
  setup_save_part
  replace_dir
 ;;
 5)
  SAVE_MP=""
 ;;
esac

umount_unneeded

[ "$DEV1FS" ] || DEV1FS="$(echo "$PDRV" | cut -f 2 -d ',')"
[ "$ATADRIVES" ] || ATADRIVES="$(cat /tmp/ATADRIVES0 | tr '\n' ' ')"
mkdir -p /pup_new/etc/rc.d
echo "PUPMODE=$PUPMODE" > /pup_new/etc/rc.d/PUPSTATE
echo "PDEV1='$P_PART'" >> /pup_new/etc/rc.d/PUPSTATE
echo "DEV1FS='$DEV1FS'" >> /pup_new/etc/rc.d/PUPSTATE
echo "PUPSFS='$PDRV'" >> /pup_new/etc/rc.d/PUPSTATE
echo "PUPSAVE='$PUPSAVE'" >> /pup_new/etc/rc.d/PUPSTATE
echo "PMEDIA='$PMEDIA'" >> /pup_new/etc/rc.d/PUPSTATE
echo '#ATADRIVES is all internal ide/pata/sata drives, excluding optical, excluding usb...' >> /pup_new/etc/rc.d/PUPSTATE
echo "ATADRIVES='$ATADRIVES'"  >> /pup_new/etc/rc.d/PUPSTATE
echo '#ATAOPTICALDRIVES is list of non-usb optical drives...'  >> /pup_new/etc/rc.d/PUPSTATE #110206
echo "ATAOPTICALDRIVES='$ATAOPTICALDRIVES'"  >> /pup_new/etc/rc.d/PUPSTATE
echo '#these directories are unionfs/aufs layers in /initrd...' >> /pup_new/etc/rc.d/PUPSTATE
echo "SAVE_LAYER='$SAVE_LAYER'" >> /pup_new/etc/rc.d/PUPSTATE
echo "PUP_LAYER='$PUP_LAYER'" >> /pup_new/etc/rc.d/PUPSTATE
echo "#The partition that has the ${DISTRO_FILE_PREFIX}save file is mounted here..." >> /pup_new/etc/rc.d/PUPSTATE
echo "PUP_HOME='$SAVE_MP'" >> /pup_new/etc/rc.d/PUPSTATE
echo '#(in /initrd) ...note, /mnt/home is a link to it.' >> /pup_new/etc/rc.d/PUPSTATE
echo '#this file has extra kernel drivers and firmware...' >> /pup_new/etc/rc.d/PUPSTATE
echo "ZDRV='$ZDRV'" >> /pup_new/etc/rc.d/PUPSTATE #v2.22
echo "FDRV='$FDRV'" >> /pup_new/etc/rc.d/PUPSTATE
echo "ADRV='$ADRV'" >> /pup_new/etc/rc.d/PUPSTATE 
echo "YDRV='$YDRV'" >> /pup_new/etc/rc.d/PUPSTATE
echo '#Partition no. override on boot drive to which session is (or will be) saved...' >> /pup_new/etc/rc.d/PUPSTATE
echo "PSAVEMARK='$PSAVEMARK'" >> /pup_new/etc/rc.d/PUPSTATE
echo "PSAVEPART='$PSAVEPART'" >> /pup_new/etc/rc.d/PUPSTATE
echo "PSUBDIR='$PSUBDIR'" >> /pup_new/etc/rc.d/PUPSTATE #120215

if [ "$PUPSAVE" ];then
 xBOOTCONFIG="$(grep -v '^PREVUNIONRECORD' /pup_new/etc/rc.d/BOOTCONFIG | sed -e 's/^LASTUNIONRECORD/PREVUNIONRECORD/')"
 echo "$xBOOTCONFIG" > /pup_new/etc/rc.d/BOOTCONFIG
 echo "LASTUNIONRECORD='$(echo -n $NEWUNIONRECORD)'" >> /pup_new/etc/rc.d/BOOTCONFIG
else
 echo "" > /pup_new/etc/rc.d/BOOTCONFIG
 echo "LASTUNIONRECORD=''" >> /pup_new/etc/rc.d/BOOTCONFIG
fi

echo -n "Performing a 'switch_root' to the layered filesystem..." > /dev/console

rm -r -f "/pup_new/initrd${SAVE_LAYER}"
for ONEMNT in $(mount | cut -f 3 -d ' ' | grep -v 'pup_new' | grep '^/pup_' | tr '\n' ' ');do
 mkdir -p /pup_new/initrd${ONEMNT}
 mount -o move $ONEMNT /pup_new/initrd${ONEMNT}
done
for ONEMNT in $(mount | cut -f 3 -d ' ' | grep '^/mnt/' | tr '\n' ' ');do
 mkdir -p /pup_new/initrd${ONEMNT}
 mount -o move $ONEMNT /pup_new/initrd${ONEMNT}
done

if [ "$PUPSAVE" ];then
 if [ "$SAVE_LAYER" -a -L "$SAVE_LAYER" ];then
  ln -s "/initrd${SAVE_FN}" "/pup_new/initrd${SAVE_LAYER}" #for after switch
 fi
fi
if [ -d "/pup_new/initrd/mnt/tmpfs/pup_rw" ];then
  rm -r -f /pup_new/initrd/pup_rw
  ln -s /initrd/mnt/tmpfs/pup_rw /pup_new/initrd/pup_rw #for after switch
fi

#PNOX is a boot param. /etc/profile prevents X from starting if this file exists...
[ "$PNOX" = "yes" ] && touch /pup_new/tmp/bootcnt.txt
cp -a /DISTRO_SPECS /pup_new/initrd/
cp -a /DISTRO_SPECS /pup_new/etc #james - so we don't duplicate in main SFS
cp /init /pup_new/initrd/
chmod -x /pup_new/initrd/init

[ -d "/pup_new/initrd/tmp" ] && rm -r -f /pup_new/initrd/tmp
mkdir -p /pup_new/initrd/tmp
cp -af /tmp/* /pup_new/initrd/tmp/ #keep any log files.

if [ "$RDSH" = "yes" ];then
 echo > /dev/console
 echo "Dropped to initramfs shell. Type 'exec switch' to continue booting Puppy." > /dev/console
 exec /bin/sh >/dev/console 2>&1
fi

sync
#killall -USR1 hotplug2 #v423
[ -d "/proc/bus/usb" ] && umount /proc/bus/usb
umount /sys
umount /dev
umount /proc

#now using cpio archive for initramfs 'initial ramdisk'...
exec switch_root /pup_new /sbin/init

###END###
