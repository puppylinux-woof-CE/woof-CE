From 7767ea479617ccf024d5c1a7ace945af4499ad21 Mon Sep 17 00:00:00 2001
From: Dima Krasner <dima@dimakrasner.com>
Date: Fri, 30 Sep 2022 11:03:27 +0000
Subject: [PATCH] Squashed commit of the following:
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

commit 209c4007eb6f393f135cedcbbc1dedd5a88183db
Merge: 07a8839 b5776e5
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Sep 30 11:01:12 2022 +0000

    Merge branch 'main' of https://github.com/djpohly/dwl into dwl-kiosk-v3

commit 07a883913455611c5c7898d42c4a5e8cb640f15c
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Sep 23 06:53:21 2022 +0000

    restore auto-scaling in kiosk mode

commit a83f9c64a469c378f47e58d395a064cc3ac74e13
Merge: 27f9ce2 d1936f1
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu Sep 22 05:28:02 2022 +0000

    Merge branch 'auto-dpi' into dwl-kiosk-v3

commit d1936f1f9340e59185e461f90e73776d1f7d337a
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu Sep 22 05:26:20 2022 +0000

    automatically choose the scale factor if <= 0

commit 27f9ce2f9d1540e7cf8c0da509e5b22ff85733ec
Merge: f7ecc23 25c2eab
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu Sep 22 05:19:47 2022 +0000

    Merge branch 'env' of https://github.com/dimkr/dwl into dwl-kiosk-v3

commit 25c2eabdab20e4cffb1729af35f9f5bba290d6f9
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sun Jul 24 20:55:56 2022 +0300

    allow environment variables to override config.h

commit f7ecc236b5625a632e0822cb3f802b6d089cc0e1
Merge: bef597a 2385d82
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu Sep 22 05:13:52 2022 +0000

    Merge branch 'main' of https://github.com/djpohly/dwl into dwl-kiosk-v3

commit bef597aeb10fe025ef01e976281bcd9319bbd901
Merge: bdd3e59 e3f5db5
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Sep 12 08:42:13 2022 +0000

    Merge branch 'center' into dwl-kiosk-v3

commit e3f5db51af641c59464a96a84fd083c496f86d07
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Tue Aug 9 06:56:00 2022 +0000

    center floating windows

commit bdd3e590a0c685f417d9fdba81da2da47b0a16e7
Merge: 7613573 f26616e
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Sep 10 13:55:55 2022 +0000

    Merge branch 'kiosk' into dwl-kiosk-v3

commit f26616eb82a02bb5aea428277634d7e5cfe63fe9
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Aug 15 13:27:21 2022 +0000

    run the first client in kiosk mode if -k

commit 76135730ec5f5e71fdb65fbf7e445e3f1c101f66
Merge: 4a62043 c2b606b
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Sep 10 13:51:38 2022 +0000

    Merge branch 'auto-dpi' into dwl-kiosk-v3

commit 4a620431556dbbb6ac1abe53fa8c7758bc1b7ae6
Merge: 828da01 bd5efbd
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Sep 10 13:50:16 2022 +0000

    Merge branch 'right' into dwl-kiosk-v3

commit 828da01dc0c54d4dc827f7daaeb4a69e8750708e
Merge: 5302996 dd65795
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Sep 10 13:50:14 2022 +0000

    Merge branch 'snail' into dwl-kiosk-v3

commit 5302996697134406aec6248b801f18fc723380ff
Merge: 5a7b5ff a6ba3c0
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Sep 10 13:50:13 2022 +0000

    Merge branch 'fallback' into dwl-kiosk-v3

commit 5a7b5ffa29d0f8423e49f5cf00a4490f9d034450
Merge: f0c1549 92d18bb
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Sep 10 13:50:10 2022 +0000

    Merge branch 'center' into dwl-kiosk-v3

commit f0c15495cc6d3115722529be2e0b121b3fc37493
Merge: 37bfc57 4ed9c32
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Sep 10 13:50:07 2022 +0000

    Merge branch 'rootcolor' into dwl-kiosk-v3

commit 37bfc5730abf4a18525885570511c7f010cd1945
Merge: feff720 9680472
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Sep 10 13:49:52 2022 +0000

    Merge branch 'env' into dwl-kiosk-v3

commit feff7209565222d47ee368996eaeb93602d4d078
Merge: cab1114 13a57da
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Sep 10 13:49:34 2022 +0000

    Merge branch 'en-keycodes' into dwl-kiosk-v3

commit cab1114729e6eda7e22f3df50442a3f5c4d6c654
Merge: 56b9970 c4ed358
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Sep 10 13:49:15 2022 +0000

    Merge branch 'center-cursor' into dwl-kiosk-v3

commit 56b9970807767a522e7be98a713f4d20c6bc8a1e
Merge: 72bcaab 55056ec
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Sep 10 13:49:12 2022 +0000

    Merge branch 'toplevel-requests' into dwl-kiosk-v3

commit 72bcaab9ec7a5ead23380fc34183f6de1268d8d9
Merge: 92925ad 3a22ccf
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Sep 10 13:22:02 2022 +0000

    Merge branch 'point' of https://github.com/PalanixYT/dwl into dwl-kiosk-v3

commit 92925add2773d174fb844fec6e15a5aab5b4cc09
Merge: 9bcef3d c0bdaf9
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Sep 10 13:21:05 2022 +0000

    Merge branch 'output-power-management' of https://github.com/guidocella/dwl into dwl-kiosk-v3

commit 3a22ccf6943af9c1934f0a4db803153bf43f8e53
Author: Palanix <palanixyt@gmail.com>
Date:   Sun Jul 3 18:46:18 2022 +0200

    Fix pointerconstraints

commit c2b606bd5d4a667a5de4f121c9e5eb0010bb17df
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Wed Aug 31 05:20:54 2022 +0000

    automatically choose the scale factor if <= 0

commit bd5efbd01e3e24f071081619dcc366fab3fc4ef0
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu Jul 21 21:14:14 2022 +0300

    extend the display to the right

commit dd65795a57a9ecabde193ebb913bce70855873e7
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Tue Jul 19 10:01:26 2022 +0300

    add the snail layout

    This layout is a scalable alternative to the "tile" and "spiral" layouts, optimized for wide monitors. Both the master area and the stack are "spirals", but windows in the master area are split horizontally as long as the master area has enough horizontal space, and the first window in the stack is split vertically unless the stack is wide.

    With one window in the master area and mfact = 0.5, it behaves like the spiral layout:

    ┌───────────────┬────────────────┐
    │               │                │
    │               │                │
    │               │                │
    │               │                │
    │               ├───┬───┬────────┤
    │               │   │   │        │
    │               ├───┴───┤        │
    │               │       │        │
    │               │       │        │
    └───────────────┴───────┴────────┘

    With 2 windows in the master area and 2 in the stack:

    ┌───────────────┬────────────────┐
    │               │                │
    │               │                │
    │               │                │
    │               │                │
    ├───────────────┼────────────────┤
    │               │                │
    │               │                │
    │               │                │
    │               │                │
    └───────────────┴────────────────┘

    With 3 windows in the master area and 2 in the stack:

    ┌───────────────┬────────────────┐
    │               │                │
    │               │                │
    │               │                │
    │               │                │
    ├───────┬───────┼────────────────┤
    │       │       │                │
    │       │       │                │
    │       │       │                │
    │       │       │                │
    └───────┴───────┴────────────────┘

    With many windows in both areas:

    ┌───────────────┬────────────────┐
    │               │                │
    │               │                │
    │               │                │
    │               │                │
    ├───┬───┬───────┼───┬───┬────────┤
    │   │   │       │   │   │        │
    ├───┴───┤       ├───┴───┤        │
    │       │       │       │        │
    │       │       │       │        │
    └───────┴───────┴───────┴────────┘

    With 2 windows in the master area, many windows in the stack and high mfact:

    ┌──────────┬──────────┬──────────┐
    │          │          │          │
    │          │          │          │
    │          │          │          │
    │          │          │          │
    │        master       ├──┬stack──┤
    │          │          │  │  │    │
    │          │          ├──┴──┤    │
    │          │          │     │    │
    │          │          │     │    │
    └──────────┴──────────┴─────┴────┘

    With 2 windows in the master area, many windows in the stack and low mfact:

    ┌──────────┬──────────┬──────────┐
    │          │          │          │
    │          │          │          │
    │          │          │          │
    │          │          │          │
    ├──master──┤        stack┬──┬────┤
    │          │          │  │  │    │
    │          │          ├──┴──┤    │
    │          │          │     │    │
    │          │          │     │    │
    └──────────┴──────────┴─────┴────┘

commit a6ba3c0ecb074a07e655191f4643582d77d0ea98
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu Jul 21 21:26:31 2022 +0300

    fall back to a lower output mode if needed (swaywm/sway@4cdc4ac)

commit 92d18bb228646c3849a9d575015c57c429d4d14b
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Tue Aug 9 06:56:00 2022 +0000

    center floating windows

commit 55056ec810743852350805a4dc1f4bb2b5c18213
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sun Jul 24 15:47:01 2022 +0300

    add support for titlebar actions

commit 4ed9c323d90ba3e34bdc4525317e6e487510bcf1
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu Aug 4 06:38:48 2022 +0000

    respect rootcolor[]

commit 96804724cc5301d780b3c6fda60b5674bac9cc24
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sun Jul 24 20:55:56 2022 +0300

    allow environment variables to override config.h

commit 13a57dae1aa81b63206beb14061a16eb4b7e9ccc
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sun Jul 24 17:52:07 2022 +0300

    always use the English keymap to get keycodes

commit c4ed3581bd04d60670786917bc2a80ef88eb734d
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Jun 17 06:26:34 2022 +0000

    center the cursor on startup

commit c0bdaf9309106d8929e9c66db134946995973525
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Apr 4 01:20:06 2022 +0800

    damage the output after wlopm --on

commit 89fd86bc20c95366bb00fed6585bf93fdc8f3112
Author: Guido Cella <guido@guidocella.xyz>
Date:   Sun Mar 20 21:19:29 2022 +0100

    Implement the output power management protocol.

    I thought wlr-randr used this, but it doesn't so I don't even know what
    this is for.
---
 Makefile                                      |   9 +-
 config.def.h                                  |  45 +-
 dwl.c                                         | 435 +++++++++++++++++-
 env.c                                         | 213 +++++++++
 ...lr-output-power-management-unstable-v1.xml | 128 ++++++
 5 files changed, 790 insertions(+), 40 deletions(-)
 create mode 100644 env.c
 create mode 100644 protocols/wlr-output-power-management-unstable-v1.xml

diff --git a/Makefile b/Makefile
index 66057960..6f68a49b 100644
--- a/Makefile
+++ b/Makefile
@@ -15,7 +15,8 @@ LDLIBS    = `$(PKG_CONFIG) --libs $(PKGS)` $(LIBS)
 all: dwl
 dwl: dwl.o util.o
 	$(CC) dwl.o util.o $(LDLIBS) $(LDFLAGS) $(DWLCFLAGS) -o $@
-dwl.o: dwl.c config.mk config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h
+dwl.o: dwl.c config.mk config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h wlr-output-power-management-unstable-v1-protocol.h pointer-constraints-unstable-v1-protocol.h
+dwl.o: env.c
 util.o: util.c util.h
 
 # wayland-scanner is a tool which generates C headers and rigging for Wayland
@@ -27,9 +28,15 @@ WAYLAND_PROTOCOLS = `$(PKG_CONFIG) --variable=pkgdatadir wayland-protocols`
 xdg-shell-protocol.h:
 	$(WAYLAND_SCANNER) server-header \
 		$(WAYLAND_PROTOCOLS)/stable/xdg-shell/xdg-shell.xml $@
+pointer-constraints-unstable-v1-protocol.h:
+	$(WAYLAND_SCANNER) server-header \
+		$(WAYLAND_PROTOCOLS)/unstable/pointer-constraints/pointer-constraints-unstable-v1.xml $@
 wlr-layer-shell-unstable-v1-protocol.h:
 	$(WAYLAND_SCANNER) server-header \
 		protocols/wlr-layer-shell-unstable-v1.xml $@
+wlr-output-power-management-unstable-v1-protocol.h:
+	$(WAYLAND_SCANNER) server-header \
+		protocols/wlr-output-power-management-unstable-v1.xml $@
 
 config.h:
 	cp config.def.h $@
diff --git a/config.def.h b/config.def.h
index ec1f0528..dcf1843a 100644
--- a/config.def.h
+++ b/config.def.h
@@ -1,13 +1,16 @@
 /* appearance */
 static const int sloppyfocus        = 1;  /* focus follows mouse */
-static const unsigned int borderpx  = 1;  /* border pixel of windows */
+static unsigned int borderpx  = 1;  /* border pixel of windows */
 static const int lockfullscreen     = 1;  /* 1 will force focus on the fullscreen window */
-static const float rootcolor[]      = {0.3, 0.3, 0.3, 1.0};
-static const float bordercolor[]    = {0.5, 0.5, 0.5, 1.0};
-static const float focuscolor[]     = {1.0, 0.0, 0.0, 1.0};
+static float rootcolor[]      = {0.3, 0.3, 0.3, 1.0};
+static float bordercolor[]    = {0.5, 0.5, 0.5, 1.0};
+static float focuscolor[]     = {1.0, 0.0, 0.0, 1.0};
 /* To conform the xdg-protocol, set the alpha to zero to restore the old behavior */
 static const float fullscreen_bg[]  = {0.1, 0.1, 0.1, 1.0};
 
+/* pointer constraints */
+static const int allow_constrain      = 1;
+
 /* tagging */
 static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
 
@@ -25,6 +28,7 @@ static const Layout layouts[] = {
 	{ "[]=",      tile },
 	{ "><>",      NULL },    /* no layout function means floating behavior */
 	{ "[M]",      monocle },
+	{ "@|@",      snail },
 };
 
 /* monitors */
@@ -34,7 +38,7 @@ static const MonitorRule monrules[] = {
 	{ "eDP-1",    0.5,  1,      2,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL },
 	*/
 	/* defaults */
-	{ NULL,       0.55, 1,      1,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL },
+	{ NULL,       0.64, 1,     -1,    &layouts[3], WL_OUTPUT_TRANSFORM_NORMAL },
 };
 
 /* keyboard */
@@ -114,33 +118,34 @@ static const Key keys[] = {
 	{ MODKEY,                    XKB_KEY_l,          setmfact,       {.f = +0.05} },
 	{ MODKEY,                    XKB_KEY_Return,     zoom,           {0} },
 	{ MODKEY,                    XKB_KEY_Tab,        view,           {0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_C,          killclient,     {0} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_c,          killclient,     {0} },
 	{ MODKEY,                    XKB_KEY_t,          setlayout,      {.v = &layouts[0]} },
 	{ MODKEY,                    XKB_KEY_f,          setlayout,      {.v = &layouts[1]} },
 	{ MODKEY,                    XKB_KEY_m,          setlayout,      {.v = &layouts[2]} },
+	{ MODKEY,                    XKB_KEY_s,          setlayout,      {.v = &layouts[3]} },
 	{ MODKEY,                    XKB_KEY_space,      setlayout,      {0} },
 	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_space,      togglefloating, {0} },
 	{ MODKEY,                    XKB_KEY_e,         togglefullscreen, {0} },
 	{ MODKEY,                    XKB_KEY_0,          view,           {.ui = ~0} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_parenright, tag,            {.ui = ~0} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_0,          tag,            {.ui = ~0} },
 	{ MODKEY,                    XKB_KEY_comma,      focusmon,       {.i = WLR_DIRECTION_LEFT} },
 	{ MODKEY,                    XKB_KEY_period,     focusmon,       {.i = WLR_DIRECTION_RIGHT} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_less,       tagmon,         {.i = WLR_DIRECTION_LEFT} },
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_greater,    tagmon,         {.i = WLR_DIRECTION_RIGHT} },
-	TAGKEYS(          XKB_KEY_1, XKB_KEY_exclam,                     0),
-	TAGKEYS(          XKB_KEY_2, XKB_KEY_at,                         1),
-	TAGKEYS(          XKB_KEY_3, XKB_KEY_numbersign,                 2),
-	TAGKEYS(          XKB_KEY_4, XKB_KEY_dollar,                     3),
-	TAGKEYS(          XKB_KEY_5, XKB_KEY_percent,                    4),
-	TAGKEYS(          XKB_KEY_6, XKB_KEY_asciicircum,                5),
-	TAGKEYS(          XKB_KEY_7, XKB_KEY_ampersand,                  6),
-	TAGKEYS(          XKB_KEY_8, XKB_KEY_asterisk,                   7),
-	TAGKEYS(          XKB_KEY_9, XKB_KEY_parenleft,                  8),
-	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_Q,          quit,           {0} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_comma,      tagmon,         {.i = WLR_DIRECTION_LEFT} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_period,    tagmon,         {.i = WLR_DIRECTION_RIGHT} },
+	TAGKEYS(          XKB_KEY_1, XKB_KEY_1,                          0),
+	TAGKEYS(          XKB_KEY_2, XKB_KEY_2,                          1),
+	TAGKEYS(          XKB_KEY_3, XKB_KEY_3,                          2),
+	TAGKEYS(          XKB_KEY_4, XKB_KEY_4,                          3),
+	TAGKEYS(          XKB_KEY_5, XKB_KEY_5,                          4),
+	TAGKEYS(          XKB_KEY_6, XKB_KEY_6,                          5),
+	TAGKEYS(          XKB_KEY_7, XKB_KEY_7,                          6),
+	TAGKEYS(          XKB_KEY_8, XKB_KEY_8,                          7),
+	TAGKEYS(          XKB_KEY_9, XKB_KEY_9,                          8),
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_q,          quit,           {0} },
 
 	/* Ctrl-Alt-Backspace and Ctrl-Alt-Fx used to be handled by X server */
 	{ WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_Terminate_Server, quit, {0} },
-#define CHVT(n) { WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_XF86Switch_VT_##n, chvt, {.ui = (n)} }
+#define CHVT(n) { WLR_MODIFIER_CTRL|WLR_MODIFIER_ALT,XKB_KEY_F##n, chvt, {.ui = (n)} }
 	CHVT(1), CHVT(2), CHVT(3), CHVT(4), CHVT(5), CHVT(6),
 	CHVT(7), CHVT(8), CHVT(9), CHVT(10), CHVT(11), CHVT(12),
 };
diff --git a/dwl.c b/dwl.c
index 339ebe52..8d6d37f9 100644
--- a/dwl.c
+++ b/dwl.c
@@ -1,6 +1,7 @@
 /*
  * See LICENSE file for copyright and license details.
  */
+#include <assert.h>
 #include <getopt.h>
 #include <libinput.h>
 #include <limits.h>
@@ -29,12 +30,16 @@
 #include <wlr/types/wlr_keyboard.h>
 #include <wlr/types/wlr_layer_shell_v1.h>
 #include <wlr/types/wlr_output.h>
+#include <wlr/interfaces/wlr_output.h>
 #include <wlr/types/wlr_output_layout.h>
 #include <wlr/types/wlr_output_management_v1.h>
+#include <wlr/types/wlr_output_power_management_v1.h>
 #include <wlr/types/wlr_pointer.h>
 #include <wlr/types/wlr_presentation_time.h>
+#include <wlr/types/wlr_pointer_constraints_v1.h>
 #include <wlr/types/wlr_primary_selection.h>
 #include <wlr/types/wlr_primary_selection_v1.h>
+#include <wlr/types/wlr_relative_pointer_v1.h>
 #include <wlr/types/wlr_scene.h>
 #include <wlr/types/wlr_screencopy_v1.h>
 #include <wlr/types/wlr_seat.h>
@@ -110,6 +115,10 @@ typedef struct {
 	struct wl_listener destroy;
 	struct wl_listener set_title;
 	struct wl_listener fullscreen;
+	struct wl_listener request_move;
+	struct wl_listener request_resize;
+	struct wl_listener request_maximize;
+	struct wl_listener request_minimize;
 	struct wlr_box prev;  /* layout-relative, includes border */
 #ifdef XWAYLAND
 	struct wl_listener activate;
@@ -120,6 +129,8 @@ typedef struct {
 	unsigned int tags;
 	int isfloating, isurgent, isfullscreen;
 	uint32_t resize; /* configure serial of a pending resize */
+	int ismaximized;
+	int kiosk;
 } Client;
 
 typedef struct {
@@ -194,6 +205,14 @@ typedef struct {
 	enum wl_output_transform rr;
 } MonitorRule;
 
+struct pointer_constraint {
+	struct wlr_pointer_constraint_v1 *constraint;
+
+	struct wl_listener set_region;
+	struct wl_listener destroy;
+};
+
+
 typedef struct {
 	const char *id;
 	const char *title;
@@ -214,6 +233,7 @@ static void arrangelayer(Monitor *m, struct wl_list *list,
 static void arrangelayers(Monitor *m);
 static void axisnotify(struct wl_listener *listener, void *data);
 static void buttonpress(struct wl_listener *listener, void *data);
+static void center(Client *c, const struct wlr_box *box);
 static void chvt(const Arg *arg);
 static void checkidleinhibitor(struct wlr_surface *exclude);
 static void cleanup(void);
@@ -228,10 +248,12 @@ static void createlayersurface(struct wl_listener *listener, void *data);
 static void createmon(struct wl_listener *listener, void *data);
 static void createnotify(struct wl_listener *listener, void *data);
 static void createpointer(struct wlr_input_device *device);
+static void createpointerconstraint(struct wl_listener *listener, void *data);
 static void cursorframe(struct wl_listener *listener, void *data);
 static void destroyidleinhibitor(struct wl_listener *listener, void *data);
 static void destroylayersurfacenotify(struct wl_listener *listener, void *data);
 static void destroynotify(struct wl_listener *listener, void *data);
+static void destroypointerconstraint(struct wl_listener *listener, void *data);
 static Monitor *dirtomon(enum wlr_direction dir);
 static void dragicondestroy(struct wl_listener *listener, void *data);
 static void focusclient(Client *c, int lift);
@@ -239,9 +261,10 @@ static void focusmon(const Arg *arg);
 static void focusstack(const Arg *arg);
 static Client *focustop(Monitor *m);
 static void fullscreennotify(struct wl_listener *listener, void *data);
+static void handleconstraintcommit(struct wl_listener *listener, void *data);
 static void incnmaster(const Arg *arg);
 static void inputdevice(struct wl_listener *listener, void *data);
-static int keybinding(uint32_t mods, xkb_keysym_t sym);
+static int keybinding(uint32_t mods, xkb_keysym_t sym, Client *sel);
 static void keypress(struct wl_listener *listener, void *data);
 static void keypressmod(struct wl_listener *listener, void *data);
 static void killclient(const Arg *arg);
@@ -258,6 +281,7 @@ static void outputmgrtest(struct wl_listener *listener, void *data);
 static void pointerfocus(Client *c, struct wlr_surface *surface,
 		double sx, double sy, uint32_t time);
 static void printstatus(void);
+static void powermgrsetmodenotify(struct wl_listener *listener, void *data);
 static void quit(const Arg *arg);
 static void quitsignal(int signo);
 static void rendermon(struct wl_listener *listener, void *data);
@@ -269,19 +293,27 @@ static void setcursor(struct wl_listener *listener, void *data);
 static void setfloating(Client *c, int floating);
 static void setfullscreen(Client *c, int fullscreen);
 static void setlayout(const Arg *arg);
+static void setmaximized(Client *c, int maximized);
 static void setmfact(const Arg *arg);
 static void setmon(Client *c, Monitor *m, unsigned int newtags);
 static void setpsel(struct wl_listener *listener, void *data);
 static void setsel(struct wl_listener *listener, void *data);
 static void setup(void);
 static void sigchld(int unused);
+static void snail(Monitor *m);
 static void spawn(const Arg *arg);
 static void startdrag(struct wl_listener *listener, void *data);
+static void startmove(struct wl_listener *listener, void *data);
+static void startresize(struct wl_listener *listener, void *data);
 static void tag(const Arg *arg);
 static void tagmon(const Arg *arg);
 static void tile(Monitor *m);
 static void togglefloating(const Arg *arg);
 static void togglefullscreen(const Arg *arg);
+static void togglemaximize(struct wl_listener *listener, void *data);
+static void togglemaximizesel(const Arg *arg);
+static void toggleminimize(struct wl_listener *listener, void *data);
+static void toggleminimizesel(const Arg *arg);
 static void toggletag(const Arg *arg);
 static void toggleview(const Arg *arg);
 static void unmaplayersurfacenotify(struct wl_listener *listener, void *data);
@@ -308,6 +340,7 @@ static struct wlr_scene_node *layers[NUM_LAYERS];
 static struct wlr_renderer *drw;
 static struct wlr_allocator *alloc;
 static struct wlr_compositor *compositor;
+static struct wlr_scene_rect *root;
 
 static struct wlr_xdg_shell *xdg_shell;
 static struct wlr_xdg_activation_v1 *activation;
@@ -323,17 +356,30 @@ static struct wlr_virtual_keyboard_manager_v1 *virtual_keyboard_mgr;
 static struct wlr_cursor *cursor;
 static struct wlr_xcursor_manager *cursor_mgr;
 
+static struct wlr_output_power_manager_v1 *power_mgr;
+static struct wl_listener power_mgr_set_mode = {.notify = powermgrsetmodenotify};
+
 static struct wlr_seat *seat;
 static struct wl_list keyboards;
 static unsigned int cursor_mode;
 static Client *grabc;
 static int grabcx, grabcy; /* client-relative */
+static int kiosk = 0;
 
 static struct wlr_output_layout *output_layout;
 static struct wlr_box sgeom;
 static struct wl_list mons;
 static Monitor *selmon;
 
+struct wlr_pointer_constraints_v1 *pointer_constraints;
+struct wlr_pointer_constraint_v1 *active_constraint;
+static struct wl_listener constraint_commit;
+struct wlr_relative_pointer_manager_v1 *relative_pointer_manager;
+static const struct xkb_rule_names en_rules = {.layout = "us"};
+static struct xkb_context *en_context;
+static struct xkb_keymap *en_keymap;
+static struct xkb_state *en_state;
+
 /* global event handlers */
 static struct wl_listener cursor_axis = {.notify = axisnotify};
 static struct wl_listener cursor_button = {.notify = buttonpress};
@@ -347,6 +393,7 @@ static struct wl_listener new_input = {.notify = inputdevice};
 static struct wl_listener new_virtual_keyboard = {.notify = virtualkeyboard};
 static struct wl_listener new_output = {.notify = createmon};
 static struct wl_listener new_xdg_surface = {.notify = createnotify};
+static struct wl_listener pointer_constraint_create = {.notify = createpointerconstraint};
 static struct wl_listener new_layer_shell_surface = {.notify = createlayersurface};
 static struct wl_listener output_mgr_apply = {.notify = outputmgrapply};
 static struct wl_listener output_mgr_test = {.notify = outputmgrtest};
@@ -377,6 +424,8 @@ static Atom netatom[NetLast];
 /* attempt to encapsulate suck into one file */
 #include "client.h"
 
+#include "env.c"
+
 /* compile-time check if all tags fit into an unsigned int bit array. */
 struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
 
@@ -490,6 +539,17 @@ applyrules(Client *c)
 					mon = m;
 		}
 	}
+	if (kiosk) {
+		if (c->link.next == &clients && c->link.prev == &clients) {
+			c->kiosk = 1;
+			c->isfullscreen = 1;
+		} else
+			c->isfloating = 1;
+	}
+	if (c->isfloating) {
+		mon = xytomon(cursor->x, cursor->y);
+		center(c, &mon->w);
+	}
 	wlr_scene_node_reparent(c->scene, layers[c->isfloating ? LyrFloat : LyrTile]);
 	setmon(c, mon, newtags);
 }
@@ -662,12 +722,11 @@ buttonpress(struct wl_listener *listener, void *data)
 		/* Don't focus unmanaged clients */
 		if (c && !client_is_unmanaged(c))
 			focusclient(c, 1);
-
 		keyboard = wlr_seat_get_keyboard(seat);
 		mods = keyboard ? wlr_keyboard_get_modifiers(keyboard) : 0;
 		for (b = buttons; b < END(buttons); b++) {
 			if (CLEANMASK(mods) == CLEANMASK(b->mod) &&
-					event->button == b->button && b->func) {
+					event->button == b->button && b->func && (!kiosk || !c || !c->kiosk || client_is_unmanaged(c))) {
 				b->func(&b->arg);
 				return;
 			}
@@ -695,6 +754,24 @@ buttonpress(struct wl_listener *listener, void *data)
 			event->time_msec, event->button, event->state);
 }
 
+void
+center(Client *c, const struct wlr_box *box)
+{
+	c->geom.x = cursor->x - c->geom.width / 2;
+	if (c->geom.x + c->geom.width > box->x + box->width)
+		c->geom.x = box->x + box->width - c->geom.width;
+	if (c->geom.x < box->x || c->geom.width > box->width)
+		c->geom.x = box->x;
+
+	c->geom.y = cursor->y - c->geom.height / 2;
+	if (c->geom.y + c->geom.height > box->y + box->height)
+		c->geom.y = box->y + box->height - c->geom.height;
+	if (c->geom.y < box->y || c->geom.height > box->height)
+		c->geom.y = box->y;
+
+	wlr_scene_node_set_position(c->scene, c->geom.x, c->geom.y);
+}
+
 void
 chvt(const Arg *arg)
 {
@@ -741,6 +818,9 @@ cleanup(void)
 	wlr_output_layout_destroy(output_layout);
 	wlr_seat_destroy(seat);
 	wl_display_destroy(dpy);
+	xkb_state_unref(en_state);
+	xkb_keymap_unref(en_keymap);
+	xkb_context_unref(en_context);
 }
 
 void
@@ -930,9 +1010,11 @@ createmon(struct wl_listener *listener, void *data)
 	/* This event is raised by the backend when a new output (aka a display or
 	 * monitor) becomes available. */
 	struct wlr_output *wlr_output = data;
+	struct wlr_output_mode *preferred_mode, *mode;
 	const MonitorRule *r;
 	size_t i;
-	Monitor *m = wlr_output->data = ecalloc(1, sizeof(*m));
+	int max_x = 0, max_x_y = 0, width, height;
+	Monitor *om, *m = wlr_output->data = ecalloc(1, sizeof(*m));
 	m->wlr_output = wlr_output;
 
 	wlr_output_init_render(wlr_output, alloc, drw);
@@ -945,8 +1027,21 @@ createmon(struct wl_listener *listener, void *data)
 		if (!r->name || strstr(wlr_output->name, r->name)) {
 			m->mfact = r->mfact;
 			m->nmaster = r->nmaster;
-			wlr_output_set_scale(wlr_output, r->scale);
-			wlr_xcursor_manager_load(cursor_mgr, r->scale);
+			if (r->scale > 0)
+				wlr_output_set_scale(wlr_output, r->scale);
+			else {
+				struct wlr_output_mode *native = wlr_output_preferred_mode(wlr_output);
+				float ppi = (native && native->height >= 1080 && wlr_output->phys_width > 0) ? native->width / (wlr_output->phys_width / 25.4) : 96;
+				if (ppi >= 96 * 2)
+					wlr_output_set_scale(wlr_output, 2);
+				else if (ppi >= 96 * 1.5)
+					wlr_output_set_scale(wlr_output, 1.5);
+				else if (ppi >= 96 * 1.25)
+					wlr_output_set_scale(wlr_output, 1.25);
+				else
+					wlr_output_set_scale(wlr_output, 1);
+			}
+			wlr_xcursor_manager_load(cursor_mgr, wlr_output->scale);
 			m->lt[0] = m->lt[1] = r->lt;
 			wlr_output_set_transform(wlr_output, r->rr);
 			break;
@@ -957,7 +1052,17 @@ createmon(struct wl_listener *listener, void *data)
 	 * monitor supports only a specific set of modes. We just pick the
 	 * monitor's preferred mode; a more sophisticated compositor would let
 	 * the user configure it. */
-	wlr_output_set_mode(wlr_output, wlr_output_preferred_mode(wlr_output));
+	preferred_mode = wlr_output_preferred_mode(wlr_output);
+	wlr_output_set_mode(wlr_output, preferred_mode);
+	if (!wlr_output_test(wlr_output) && !wl_list_empty(&wlr_output->modes)) {
+		wl_list_for_each(mode, &wlr_output->modes, link) {
+			if (mode != preferred_mode) {
+				wlr_output_set_mode(wlr_output, mode);
+				if (wlr_output_test(wlr_output))
+					break;
+			}
+		}
+	}
 	wlr_output_enable_adaptive_sync(wlr_output, 1);
 
 	/* Set up event listeners */
@@ -968,6 +1073,14 @@ createmon(struct wl_listener *listener, void *data)
 	if (!wlr_output_commit(wlr_output))
 		return;
 
+	wl_list_for_each(om, &mons, link) {
+		wlr_output_effective_resolution(om->wlr_output, &width, &height);
+		if (om->m.x + width > max_x) {
+			max_x = om->m.x + width;
+			max_x_y = om->m.y;
+		}
+	}
+
 	wl_list_insert(&mons, &m->link);
 	printstatus();
 
@@ -978,7 +1091,31 @@ createmon(struct wl_listener *listener, void *data)
 	 * output (such as DPI, scale factor, manufacturer, etc).
 	 */
 	m->scene_output = wlr_scene_output_create(scene, wlr_output);
-	wlr_output_layout_add_auto(output_layout, wlr_output);
+	wlr_output_layout_add(output_layout, wlr_output, max_x, max_x_y);
+}
+
+void
+createpointerconstraint(struct wl_listener *listener, void *data)
+{
+	if (selclient()) {
+		struct wlr_pointer_constraint_v1 *constraint = data;
+		struct pointer_constraint *pointer_constraint = calloc(1, sizeof(struct pointer_constraint));
+		pointer_constraint->constraint = constraint;
+
+		pointer_constraint->destroy.notify = destroypointerconstraint;
+		wl_signal_add(&constraint->events.destroy, &pointer_constraint->destroy);
+
+		if (client_surface(selclient()) == constraint->surface) {
+			if (allow_constrain == 0 || active_constraint == constraint)
+				return;
+
+			active_constraint = constraint;
+			wlr_pointer_constraint_v1_send_activated(constraint);
+
+			constraint_commit.notify = handleconstraintcommit;
+			wl_signal_add(&constraint->surface->events.commit, &constraint_commit);
+		}
+	}
 }
 
 void
@@ -1026,6 +1163,14 @@ createnotify(struct wl_listener *listener, void *data)
 	LISTEN(&xdg_surface->toplevel->events.set_title, &c->set_title, updatetitle);
 	LISTEN(&xdg_surface->toplevel->events.request_fullscreen, &c->fullscreen,
 			fullscreennotify);
+	LISTEN(&xdg_surface->toplevel->events.request_move, &c->request_move,
+			startmove);
+	LISTEN(&xdg_surface->toplevel->events.request_resize, &c->request_resize,
+			startresize);
+	LISTEN(&xdg_surface->toplevel->events.request_maximize, &c->request_maximize,
+			togglemaximize);
+	LISTEN(&xdg_surface->toplevel->events.request_minimize, &c->request_minimize,
+			toggleminimize);
 }
 
 void
@@ -1066,11 +1211,32 @@ createpointer(struct wlr_input_device *device)
 			libinput_device_config_accel_set_profile(libinput_device, accel_profile);
 			libinput_device_config_accel_set_speed(libinput_device, accel_speed);
 		}
+
+		inputconfig(libinput_device);
 	}
 
 	wlr_cursor_attach_input_device(cursor, device);
 }
 
+void
+destroypointerconstraint(struct wl_listener *listener, void *data)
+{
+	struct wlr_pointer_constraint_v1 *constraint = data;
+	struct pointer_constraint *pointer_constraint = wl_container_of(listener, pointer_constraint, destroy);
+
+	wl_list_remove(&pointer_constraint->destroy.link);
+
+	if (active_constraint == constraint) {
+		if (constraint_commit.link.next != NULL) {
+			wl_list_remove(&constraint_commit.link);
+		}
+		wl_list_init(&constraint_commit.link);
+		active_constraint = NULL;
+	}
+
+	free(pointer_constraint);
+}
+
 void
 cursorframe(struct wl_listener *listener, void *data)
 {
@@ -1114,6 +1280,10 @@ destroynotify(struct wl_listener *listener, void *data)
 	wl_list_remove(&c->destroy.link);
 	wl_list_remove(&c->set_title.link);
 	wl_list_remove(&c->fullscreen.link);
+	wl_list_remove(&c->request_move.link);
+	wl_list_remove(&c->request_resize.link);
+	wl_list_remove(&c->request_maximize.link);
+	wl_list_remove(&c->request_minimize.link);
 #ifdef XWAYLAND
 	if (c->type != XDGShell) {
 		wl_list_remove(&c->configure.link);
@@ -1155,7 +1325,7 @@ focusclient(Client *c, int lift)
 	int i;
 
 	/* Raise client in stacking order if requested */
-	if (c && lift)
+	if (c && lift && (!kiosk || c->isfloating))
 		wlr_scene_node_raise_to_top(c->scene);
 
 	if (c && client_surface(c) == old)
@@ -1275,6 +1445,12 @@ fullscreennotify(struct wl_listener *listener, void *data)
 	setfullscreen(c, client_wants_fullscreen(c));
 }
 
+void
+handleconstraintcommit(struct wl_listener *listener, void *data)
+{
+	assert(active_constraint->surface == data);
+}
+
 void
 incnmaster(const Arg *arg)
 {
@@ -1315,7 +1491,7 @@ inputdevice(struct wl_listener *listener, void *data)
 }
 
 int
-keybinding(uint32_t mods, xkb_keysym_t sym)
+keybinding(uint32_t mods, xkb_keysym_t sym, Client *sel)
 {
 	/*
 	 * Here we handle compositor keybindings. This is when the compositor is
@@ -1326,7 +1502,7 @@ keybinding(uint32_t mods, xkb_keysym_t sym)
 	const Key *k;
 	for (k = keys; k < END(keys); k++) {
 		if (CLEANMASK(mods) == CLEANMASK(k->mod) &&
-				sym == k->keysym && k->func) {
+				sym == k->keysym && k->func && (!kiosk || !sel || !sel->kiosk || client_is_unmanaged(sel) || k->func == chvt)) {
 			k->func(&k->arg);
 			handled = 1;
 		}
@@ -1337,6 +1513,7 @@ keybinding(uint32_t mods, xkb_keysym_t sym)
 void
 keypress(struct wl_listener *listener, void *data)
 {
+	Client *sel = selclient();
 	int i;
 	/* This event is raised when a key is pressed or released. */
 	Keyboard *kb = wl_container_of(listener, kb, key);
@@ -1347,7 +1524,7 @@ keypress(struct wl_listener *listener, void *data)
 	/* Get a list of keysyms based on the keymap for this keyboard */
 	const xkb_keysym_t *syms;
 	int nsyms = xkb_state_key_get_syms(
-			kb->device->keyboard->xkb_state, keycode, &syms);
+			en_state, keycode, &syms);
 
 	int handled = 0;
 	uint32_t mods = wlr_keyboard_get_modifiers(kb->device->keyboard);
@@ -1359,7 +1536,7 @@ keypress(struct wl_listener *listener, void *data)
 	if (!input_inhibit_mgr->active_inhibitor
 			&& event->state == WL_KEYBOARD_KEY_STATE_PRESSED)
 		for (i = 0; i < nsyms; i++)
-			handled = keybinding(mods, syms[i]) || handled;
+			handled = keybinding(mods, syms[i], sel) || handled;
 
 	if (!handled) {
 		/* Pass unhandled keycodes along to the client. */
@@ -1461,6 +1638,7 @@ mapnotify(struct wl_listener *listener, void *data)
 		c->isfloating = 1;
 		wlr_scene_node_reparent(c->scene, layers[LyrFloat]);
 		setmon(c, p->mon, p->tags);
+		center(c, &c->mon->w);
 	} else {
 		applyrules(c);
 	}
@@ -1552,7 +1730,15 @@ motionrelative(struct wl_listener *listener, void *data)
 	 * special configuration applied for the specific input device which
 	 * generated the event. You can pass NULL for the device if you want to move
 	 * the cursor around without any input. */
-	wlr_cursor_move(cursor, event->device, event->delta_x, event->delta_y);
+	wlr_relative_pointer_manager_v1_send_relative_motion(
+		relative_pointer_manager,
+		seat, (uint64_t)event->time_msec * 1000,
+		event->delta_x, event->delta_y, event->unaccel_dx, event->unaccel_dy);
+
+	if (!active_constraint) {
+		wlr_cursor_move(cursor, event->device,
+			event->delta_x, event->delta_y);
+	}
 	motionnotify(event->time_msec);
 }
 
@@ -1567,6 +1753,8 @@ moveresize(const Arg *arg)
 
 	/* Float the window and tell motionnotify to grab it */
 	setfloating(grabc, 1);
+	if (grabc->ismaximized)
+		setmaximized(grabc, 0);
 	switch (cursor_mode = arg->ui) {
 	case CurMove:
 		grabcx = cursor->x - grabc->geom.x;
@@ -1743,6 +1931,16 @@ printstatus(void)
 	}
 }
 
+void
+powermgrsetmodenotify(struct wl_listener *listener, void *data)
+{
+	struct wlr_output_power_v1_set_mode_event *event = data;
+	wlr_output_enable(event->output, event->mode);
+	if (event->mode)
+		wlr_output_damage_whole(event->output);
+	wlr_output_commit(event->output);
+}
+
 void
 quit(const Arg *arg)
 {
@@ -1869,7 +2067,10 @@ run(char *startup_cmd)
 	 * instead of (0, 0) and then jumping.  still may not be fully
 	 * initialized, as the image/coordinates are not transformed for the
 	 * monitor when displayed here */
-	wlr_cursor_warp_closest(cursor, NULL, cursor->x, cursor->y);
+	if (selmon)
+		wlr_cursor_warp_closest(cursor, NULL, selmon->w.x + selmon->w.width / 2, selmon->w.y + selmon->w.height / 2);
+	else
+		wlr_cursor_warp_closest(cursor, NULL, cursor->x, cursor->y);
 	wlr_xcursor_manager_set_cursor_image(cursor_mgr, cursor_image, cursor);
 
 	/* Run the Wayland event loop. This does not return until you exit the
@@ -1914,6 +2115,8 @@ setfloating(Client *c, int floating)
 {
 	c->isfloating = floating;
 	wlr_scene_node_reparent(c->scene, layers[c->isfloating ? LyrFloat : LyrTile]);
+	if (floating)
+		center(c, &c->mon->w);
 	arrange(c->mon);
 	printstatus();
 }
@@ -1921,6 +2124,7 @@ setfloating(Client *c, int floating)
 void
 setfullscreen(Client *c, int fullscreen)
 {
+	struct wlr_box *layout_box;
 	c->isfullscreen = fullscreen;
 	if (!c->mon)
 		return;
@@ -1929,7 +2133,10 @@ setfullscreen(Client *c, int fullscreen)
 
 	if (fullscreen) {
 		c->prev = c->geom;
-		resize(c, c->mon->m, 0);
+		if (c->kiosk) {
+			layout_box = wlr_output_layout_get_box(output_layout, NULL);
+			resize(c, (struct wlr_box){.x = layout_box->x, .y = layout_box->y, .width = layout_box->width, .height = layout_box->height}, 0);
+		} else resize(c, c->mon->m, 0);
 		/* The xdg-protocol specifies:
 		 *
 		 * If the fullscreened surface is not opaque, the compositor must make
@@ -1971,6 +2178,25 @@ setlayout(const Arg *arg)
 	printstatus();
 }
 
+void
+setmaximized(Client *c, int maximized)
+{
+	if (c->isfullscreen || client_is_unmanaged(c))
+		return;
+	if (!c->isfloating)
+		setfloating(c, 1);
+
+	c->ismaximized = maximized;
+
+	if (maximized) {
+		c->prev = c->geom;
+		resize(c, (struct wlr_box){.x = c->mon->w.x, .y = c->mon->w.y, .width = c->mon->w.width, .height = c->mon->w.height}, 0);
+	} else
+		resize(c, (struct wlr_box){.x = c->prev.x, .y = c->prev.y, .width = c->prev.width, .height = c->prev.height}, 0);
+	arrange(c->mon);
+	printstatus();
+}
+
 /* arg > 1.0 will set mfact absolutely */
 void
 setmfact(const Arg *arg)
@@ -2061,6 +2287,7 @@ setup(void)
 
 	/* Initialize the scene graph used to lay out windows */
 	scene = wlr_scene_create();
+	root = wlr_scene_rect_create(&scene->node, 0, 0, rootcolor);
 	layers[LyrBg] = &wlr_scene_tree_create(&scene->node)->node;
 	layers[LyrBottom] = &wlr_scene_tree_create(&scene->node)->node;
 	layers[LyrTile] = &wlr_scene_tree_create(&scene->node)->node;
@@ -2097,6 +2324,9 @@ setup(void)
 	activation = wlr_xdg_activation_v1_create(dpy);
 	wl_signal_add(&activation->events.request_activate, &request_activate);
 
+	power_mgr = wlr_output_power_manager_v1_create(dpy);
+	wl_signal_add(&power_mgr->events.set_mode, &power_mgr_set_mode);
+
 	/* Creates an output layout, which a wlroots utility for working with an
 	 * arrangement of screens in a physical layout. */
 	output_layout = wlr_output_layout_create();
@@ -2133,9 +2363,14 @@ setup(void)
 	/* Use decoration protocols to negotiate server-side decorations */
 	wlr_server_decoration_manager_set_default_mode(
 			wlr_server_decoration_manager_create(dpy),
-			WLR_SERVER_DECORATION_MANAGER_MODE_SERVER);
+			kiosk ? WLR_SERVER_DECORATION_MANAGER_MODE_CLIENT : WLR_SERVER_DECORATION_MANAGER_MODE_SERVER);
 	wlr_xdg_decoration_manager_v1_create(dpy);
 
+	pointer_constraints = wlr_pointer_constraints_v1_create(dpy);
+	wl_signal_add(&pointer_constraints->events.new_constraint, &pointer_constraint_create);
+
+	relative_pointer_manager = wlr_relative_pointer_manager_v1_create(dpy);
+
 	/*
 	 * Creates a cursor, which is a wlroots utility for tracking the cursor
 	 * image shown on screen.
@@ -2174,6 +2409,10 @@ setup(void)
 	 * let us know when new input devices are available on the backend.
 	 */
 	wl_list_init(&keyboards);
+	en_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
+	en_keymap = xkb_keymap_new_from_names(en_context, &en_rules,
+		XKB_KEYMAP_COMPILE_NO_FLAGS);
+	en_state = xkb_state_new(en_keymap);
 	wl_signal_add(&backend->events.new_input, &new_input);
 	virtual_keyboard_mgr = wlr_virtual_keyboard_manager_v1_create(dpy);
 	wl_signal_add(&virtual_keyboard_mgr->events.new_virtual_keyboard,
@@ -2192,6 +2431,9 @@ setup(void)
 	wlr_scene_set_presentation(scene, wlr_presentation_create(dpy, backend));
 
 #ifdef XWAYLAND
+	if (kiosk)
+		return;
+
 	/*
 	 * Initialise the XWayland X server.
 	 * It will be started when the first X client is started.
@@ -2224,6 +2466,99 @@ sigchld(int unused)
 			child_pid = -1;
 }
 
+void
+snail(Monitor *m)
+{
+	unsigned int i = 0, n = 0, mw = m->w.width;
+	Client *c, *prev;
+	enum wlr_direction dir = WLR_DIRECTION_RIGHT;
+
+	wl_list_for_each(c, &clients, link)
+		if (VISIBLEON(c, m) && !c->isfloating && !c->isfullscreen)
+			n++;
+	if (n == 0)
+		return;
+
+	if (n > m->nmaster)
+		mw = m->nmaster ? m->w.width * m->mfact : 0;
+
+	wl_list_for_each(c, &clients, link) {
+		if (!VISIBLEON(c, m) || c->isfloating || c->isfullscreen)
+			continue;
+
+		/*
+		 * If the master area exists and this is the first window, fill the
+		 * master area with this window
+		 */
+		if (mw > 0 && i == 0) {
+			resize(c, (struct wlr_box){.x = m->w.x, .y = m->w.y,
+				.width = mw, .height = m->w.height}, 0);
+			/*
+			 * If the first window in the master area is wide, split it
+			 * horizontally and put next one on its right; otherwise, split it
+			 * vertically and put the next one below it
+			 */
+			dir = c->geom.width > m->w.height ? WLR_DIRECTION_RIGHT : WLR_DIRECTION_DOWN;
+		/*
+		 * If the master area is full or doesn't exist, fill the stack with the
+		 * m->nmaster-th window
+		 */
+		} else if (i == m->nmaster) {
+			resize(c, (struct wlr_box){.x = m->w.x + mw, .y = m->w.y,
+				.width = m->w.width - mw, .height = m->w.height}, 0);
+			/*
+			 * If the first window in the stack is wide, split it horizontally
+			 * and put next one on its right; otherwise, split it vertically and
+			 * put the next one below it
+			 */
+			dir = c->geom.width > m->w.height ? WLR_DIRECTION_RIGHT : WLR_DIRECTION_DOWN;
+		/*
+		 * Split the previous horizontally and put the current window on the right
+		 */
+		} else if (dir == WLR_DIRECTION_RIGHT) {
+			resize(c, (struct wlr_box){.x = prev->geom.x + prev->geom.width / 2, .y = prev->geom.y,
+				.width = prev->geom.width / 2, .height = prev->geom.height}, 0);
+			resize(prev, (struct wlr_box){.x = prev->geom.x, .y = prev->geom.y,
+				.width = prev->geom.width / 2, .height = prev->geom.height}, 0);
+			/*
+			 * If it's a stack window or the first narrow window in the master
+			 * area, put the next one below it
+			 */
+			if (i >= m->nmaster || c->geom.width < m->w.height)
+				dir = WLR_DIRECTION_DOWN;
+		/*
+		 * Split the previous vertically and put the current window below it
+		 */
+		} else if (dir == WLR_DIRECTION_DOWN) {
+			resize(c, (struct wlr_box){.x = prev->geom.x, .y = prev->geom.y + prev->geom.height / 2,
+				.width = prev->geom.width, .height = prev->geom.height / 2}, 0);
+			resize(prev, (struct wlr_box){.x = prev->geom.x, .y = prev->geom.y,
+				.width = prev->geom.width, .height = prev->geom.height / 2}, 0);
+			dir = WLR_DIRECTION_LEFT;
+		/*
+		 * Split the previous horizontally and put the current window on the left
+		 */
+		} else if (dir == WLR_DIRECTION_LEFT) {
+			resize(c, (struct wlr_box){.x = prev->geom.x, .y = prev->geom.y,
+				.width = prev->geom.width / 2, .height = prev->geom.height}, 0);
+			resize(prev, (struct wlr_box){.x = prev->geom.x + prev->geom.width / 2, .y = prev->geom.y,
+				.width = prev->geom.width / 2, .height = prev->geom.height}, 0);
+			dir = WLR_DIRECTION_UP;
+		/*
+		 * Split the previous vertically and put the current window above it
+		 */
+		} else {
+			resize(c, (struct wlr_box){.x = prev->geom.x, .y = prev->geom.y,
+				.width = prev->geom.width, .height = prev->geom.height / 2}, 0);
+			resize(prev, (struct wlr_box){.x = prev->geom.x, .y = prev->geom.y + prev->geom.height / 2,
+				.width = prev->geom.width, .height = prev->geom.height / 2}, 0);
+			dir = WLR_DIRECTION_RIGHT;
+		}
+		i++;
+		prev = c;
+	}
+}
+
 void
 spawn(const Arg *arg)
 {
@@ -2248,6 +2583,22 @@ startdrag(struct wl_listener *listener, void *data)
 	wl_signal_add(&drag->icon->events.destroy, &drag_icon_destroy);
 }
 
+void
+startmove(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, request_move);
+
+	moveresize(&(Arg){.ui = CurMove});
+}
+
+void
+startresize(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, request_resize);
+
+	moveresize(&(Arg){.ui = CurResize});
+}
+
 void
 tag(const Arg *arg)
 {
@@ -2318,6 +2669,40 @@ togglefullscreen(const Arg *arg)
 		setfullscreen(sel, !sel->isfullscreen);
 }
 
+void
+togglemaximize(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, request_maximize);
+
+	if (c->mon)
+		setmaximized(c, !c->ismaximized);
+}
+
+void
+togglemaximizesel(const Arg *arg)
+{
+	Client *sel = selclient();
+	if (sel)
+		setmaximized(sel, !sel->ismaximized);
+}
+
+void
+toggleminimize(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, request_minimize);
+
+	if (c->mon && !client_is_unmanaged(c))
+		setfloating(c, !c->isfloating);
+}
+
+void
+toggleminimizesel(const Arg *arg)
+{
+	Client *sel = selclient();
+	if (sel && !client_is_unmanaged(sel))
+		setfloating(sel, !sel->isfloating);
+}
+
 void
 toggletag(const Arg *arg)
 {
@@ -2407,6 +2792,7 @@ updatemons(struct wl_listener *listener, void *data)
 	Client *c;
 	Monitor *m;
 	sgeom = *wlr_output_layout_get_box(output_layout, NULL);
+	wlr_scene_rect_set_size(root, sgeom.width, sgeom.height);
 	wl_list_for_each(m, &mons, link) {
 		struct wlr_output_configuration_head_v1 *config_head =
 			wlr_output_configuration_head_v1_create(config, m->wlr_output);
@@ -2594,6 +2980,14 @@ createnotifyx11(struct wl_listener *listener, void *data)
 	LISTEN(&xwayland_surface->events.destroy, &c->destroy, destroynotify);
 	LISTEN(&xwayland_surface->events.request_fullscreen, &c->fullscreen,
 			fullscreennotify);
+	LISTEN(&xwayland_surface->events.request_move, &c->request_move,
+			startmove);
+	LISTEN(&xwayland_surface->events.request_resize, &c->request_resize,
+			startresize);
+	LISTEN(&xwayland_surface->events.request_maximize, &c->request_maximize,
+			togglemaximize);
+	LISTEN(&xwayland_surface->events.request_minimize, &c->request_minimize,
+			toggleminimize);
 }
 
 Atom
@@ -2657,11 +3051,13 @@ main(int argc, char *argv[])
 	char *startup_cmd = NULL;
 	int c;
 
-	while ((c = getopt(argc, argv, "s:hv")) != -1) {
+	while ((c = getopt(argc, argv, "s:hvk")) != -1) {
 		if (c == 's')
 			startup_cmd = optarg;
 		else if (c == 'v')
 			die("dwl " VERSION);
+		else if (c == 'k')
+			kiosk = 1;
 		else
 			goto usage;
 	}
@@ -2671,11 +3067,12 @@ main(int argc, char *argv[])
 	/* Wayland requires XDG_RUNTIME_DIR for creating its communications socket */
 	if (!getenv("XDG_RUNTIME_DIR"))
 		die("XDG_RUNTIME_DIR must be set");
+	loadtheme();
 	setup();
 	run(startup_cmd);
 	cleanup();
 	return EXIT_SUCCESS;
 
 usage:
-	die("Usage: %s [-v] [-s startup command]", argv[0]);
+	die("Usage: %s [-v] [-k] [-s startup command]", argv[0]);
 }
diff --git a/env.c b/env.c
new file mode 100644
index 00000000..6fe624ef
--- /dev/null
+++ b/env.c
@@ -0,0 +1,213 @@
+static int
+isenabled(const char *val, int def)
+{
+	return ((def && (!val || !val[0] || (val[0] != '0'))) || (!def && (val && val[0] && (val[0] != '0'))));
+}
+
+static void
+setclickmethod(struct libinput_device *libinput_device)
+{
+	const char *val;
+	long l;
+	char *end = NULL;
+
+	val = getenv("LIBINPUT_DEFAULT_CLICK_METHOD");
+	if (!val || !val[0])
+		return;
+
+	errno = 0;
+	l = strtol(val, &end, 10);
+	if (errno || (end && *end))
+		return;
+
+	libinput_device_config_click_set_method(libinput_device,
+		(enum libinput_config_click_method)l);
+}
+
+static void
+settap(struct libinput_device *libinput_device)
+{
+	const char *val;
+
+	val = getenv("LIBINPUT_DEFAULT_TAP");
+	if (val) {
+		if (!val[0])
+			return;
+
+		libinput_device_config_tap_set_enabled(libinput_device,
+			isenabled(val, 1) ? LIBINPUT_CONFIG_TAP_ENABLED :
+				LIBINPUT_CONFIG_TAP_DISABLED);
+	} else if (tap_to_click && libinput_device_config_tap_get_finger_count(libinput_device))
+		libinput_device_config_tap_set_enabled(libinput_device,
+			LIBINPUT_CONFIG_TAP_ENABLED);
+}
+
+static void
+settapanddrag(struct libinput_device *libinput_device)
+{
+	const char *val;
+
+	val = getenv("LIBINPUT_DEFAULT_DRAG");
+	if (val && val[0])
+		libinput_device_config_tap_set_drag_enabled(libinput_device,
+			isenabled(val, 1) ? LIBINPUT_CONFIG_DRAG_ENABLED :
+				LIBINPUT_CONFIG_DRAG_DISABLED);
+}
+
+static void
+setnaturalscroll(struct libinput_device *libinput_device)
+{
+	const char *val;
+
+	val = getenv("LIBINPUT_DEFAULT_NATURAL_SCROLL");
+	if (val && val[0])
+		libinput_device_config_scroll_set_natural_scroll_enabled(
+			libinput_device, isenabled(val, 0));
+	else if (!val && libinput_device_config_scroll_has_natural_scroll(libinput_device))
+		libinput_device_config_scroll_set_natural_scroll_enabled(
+			libinput_device, natural_scrolling);
+}
+
+static void
+setaccelprofile(struct libinput_device *libinput_device)
+{
+	const char *val;
+	double profile;
+	char *end = NULL;
+
+	val = getenv("LIBINPUT_DEFAULT_ACCELERATION_PROFILE");
+	if (!val || !val[0])
+		return;
+
+	errno = 0;
+	profile = strtod(val, &end);
+	if (errno || (end && *end))
+		return;
+
+	libinput_device_config_accel_set_profile(libinput_device,
+		(enum libinput_config_accel_profile)profile);
+}
+
+static void
+setaccelspeed(struct libinput_device *libinput_device)
+{
+	const char *val;
+	double accel = 0;
+	char *end = NULL;
+
+	val = getenv("LIBINPUT_DEFAULT_ACCELERATION");
+	if (!val || !val[0])
+		return;
+
+	errno = 0;
+	accel = strtod(val, &end);
+	if (errno || (end && *end) || (accel < -1) || (accel > 1))
+		return;
+
+	libinput_device_config_accel_set_speed(libinput_device, accel);
+}
+
+static void
+setscrollmethod(struct libinput_device *libinput_device)
+{
+	const char *val;
+	long l;
+	char *end = NULL;
+
+	val = getenv("LIBINPUT_DEFAULT_SCROLL_METHOD");
+	if (!val || !val[0])
+		return;
+
+	errno = 0;
+	l = strtol(val, &end, 10);
+	if (errno || (end && *end))
+		return;
+
+	libinput_device_config_scroll_set_method(libinput_device,
+		(enum libinput_config_scroll_method)l);
+}
+
+static void
+setdwt(struct libinput_device *libinput_device)
+{
+	const char *val;
+
+	val = getenv("LIBINPUT_DEFAULT_DISABLE_WHILE_TYPING");
+	if (val && val[0])
+		libinput_device_config_dwt_set_enabled(libinput_device,
+			isenabled(val, false) ? LIBINPUT_CONFIG_DWT_ENABLED :
+				LIBINPUT_CONFIG_DWT_DISABLED);
+}
+
+static void
+setmiddleemul(struct libinput_device *libinput_device)
+{
+	const char *val;
+
+	val = getenv("LIBINPUT_DEFAULT_MIDDLE_EMULATION");
+	if (val && val[0])
+		libinput_device_config_middle_emulation_set_enabled(libinput_device,
+			isenabled(val, false) ? LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED :
+				LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED);
+}
+
+static void
+setlefthanded(struct libinput_device *libinput_device)
+{
+	const char *val;
+
+	val = getenv("LIBINPUT_DEFAULT_LEFT_HANDED");
+	if (val && val[0])
+		libinput_device_config_left_handed_set(libinput_device,
+			isenabled(val, 0));
+}
+
+static void
+inputconfig(struct libinput_device *libinput_device)
+{
+	setclickmethod(libinput_device);
+	settap(libinput_device);
+	settapanddrag(libinput_device);
+	setnaturalscroll(libinput_device);
+	setaccelprofile(libinput_device);
+	setaccelspeed(libinput_device);
+	setscrollmethod(libinput_device);
+	setdwt(libinput_device);
+	setmiddleemul(libinput_device);
+	setlefthanded(libinput_device);
+}
+
+static void
+parsecolor(const char *val, float color[4])
+{
+	uint8_t r, g, b;
+	if (sscanf(val, "#%02hhx%02hhx%02hhx", &r, &g, &b) == 3) {
+		color[0] = (float)r / 0xFF;
+		color[1] = (float)g / 0xFF;
+		color[2] = (float)b / 0xFF;
+		color[3] = 1.0;
+	}
+}
+
+static void
+loadtheme(void)
+{
+	const char *val;
+	unsigned int tmp;
+
+	val = getenv("DWL_ROOT_COLOR");
+	if (val)
+		parsecolor(val, rootcolor);
+
+	val = getenv("DWL_BORDER_COLOR");
+	if (val)
+		parsecolor(val, bordercolor);
+
+	val = getenv("DWL_FOCUS_COLOR");
+	if (val)
+		parsecolor(val, focuscolor);
+
+	val = getenv("DWL_BORDER");
+	if (val && sscanf(val, "%u", &tmp) == 1)
+		borderpx = tmp;
+}
diff --git a/protocols/wlr-output-power-management-unstable-v1.xml b/protocols/wlr-output-power-management-unstable-v1.xml
new file mode 100644
index 00000000..a9778399
--- /dev/null
+++ b/protocols/wlr-output-power-management-unstable-v1.xml
@@ -0,0 +1,128 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="wlr_output_power_management_unstable_v1">
+  <copyright>
+    Copyright © 2019 Purism SPC
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <description summary="Control power management modes of outputs">
+    This protocol allows clients to control power management modes
+    of outputs that are currently part of the compositor space. The
+    intent is to allow special clients like desktop shells to power
+    down outputs when the system is idle.
+
+    To modify outputs not currently part of the compositor space see
+    wlr-output-management.
+
+    Warning! The protocol described in this file is experimental and
+    backward incompatible changes may be made. Backward compatible changes
+    may be added together with the corresponding interface version bump.
+    Backward incompatible changes are done by bumping the version number in
+    the protocol and interface names and resetting the interface version.
+    Once the protocol is to be declared stable, the 'z' prefix and the
+    version number in the protocol and interface names are removed and the
+    interface version number is reset.
+  </description>
+
+  <interface name="zwlr_output_power_manager_v1" version="1">
+    <description summary="manager to create per-output power management">
+      This interface is a manager that allows creating per-output power
+      management mode controls.
+    </description>
+
+    <request name="get_output_power">
+      <description summary="get a power management for an output">
+        Create a output power management mode control that can be used to
+        adjust the power management mode for a given output.
+      </description>
+      <arg name="id" type="new_id" interface="zwlr_output_power_v1"/>
+      <arg name="output" type="object" interface="wl_output"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the manager">
+        All objects created by the manager will still remain valid, until their
+        appropriate destroy request has been called.
+      </description>
+    </request>
+  </interface>
+
+  <interface name="zwlr_output_power_v1" version="1">
+    <description summary="adjust power management mode for an output">
+      This object offers requests to set the power management mode of
+      an output.
+    </description>
+
+    <enum name="mode">
+      <entry name="off" value="0"
+             summary="Output is turned off."/>
+      <entry name="on" value="1"
+             summary="Output is turned on, no power saving"/>
+    </enum>
+
+    <enum name="error">
+      <entry name="invalid_mode" value="1" summary="inexistent power save mode"/>
+    </enum>
+
+    <request name="set_mode">
+      <description summary="Set an outputs power save mode">
+        Set an output's power save mode to the given mode. The mode change
+        is effective immediately. If the output does not support the given
+        mode a failed event is sent.
+      </description>
+      <arg name="mode" type="uint" enum="mode" summary="the power save mode to set"/>
+    </request>
+
+    <event name="mode">
+      <description summary="Report a power management mode change">
+        Report the power management mode change of an output.
+
+        The mode event is sent after an output changed its power
+        management mode. The reason can be a client using set_mode or the
+        compositor deciding to change an output's mode.
+        This event is also sent immediately when the object is created
+        so the client is informed about the current power management mode.
+      </description>
+      <arg name="mode" type="uint" enum="mode"
+           summary="the output's new power management mode"/>
+    </event>
+
+    <event name="failed">
+      <description summary="object no longer valid">
+        This event indicates that the output power management mode control
+        is no longer valid. This can happen for a number of reasons,
+        including:
+        - The output doesn't support power management
+        - Another client already has exclusive power management mode control
+          for this output
+        - The output disappeared
+
+        Upon receiving this event, the client should destroy this object.
+      </description>
+    </event>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy this power management">
+        Destroys the output power management mode control object.
+      </description>
+    </request>
+  </interface>
+</protocol>
