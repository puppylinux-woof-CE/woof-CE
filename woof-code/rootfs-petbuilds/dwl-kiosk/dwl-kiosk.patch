From c035b4580ed2a2316eede1bfdac75d1d80969a67 Mon Sep 17 00:00:00 2001
From: Dima Krasner <dima@dimakrasner.com>
Date: Wed, 22 Jun 2022 20:14:53 +0000
Subject: [PATCH] Squashed commit of the following:

commit 0c728e1ca5575793b416db6894226c7e3808fe2e
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Wed Jun 22 20:11:51 2022 +0000

    add a function for Alt-Tab

commit f2cd033f17c8d141739917b55ed85c4e0e4be83d
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Jun 18 11:47:57 2022 +0000

    fix segfault if window has no title

commit f0509ea8acfab1047a9e7606897a6f195537e4c6
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Jun 17 06:26:34 2022 +0000

    center the cursor on startup

commit d41059b80d9f1ec56d99fb3618d7ba76d2055e0c
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu Jun 16 18:01:56 2022 +0000

    float maximized windows

commit 7fbc4c95cf22f878c3edbe1f0c726a692e8e51cf
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu Jun 16 15:38:34 2022 +0000

    add functions maximize/minimize key bindings

commit 3101ec921d0703e59bb227bc11ff74673c84a640
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu Jun 16 15:12:47 2022 +0000

    disable key bindings in kiosk mode

commit 543b1757ac8f17c0a76a17c52d7003c9ec0ef760
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Wed Jun 15 06:03:03 2022 +0000

    deactivate other windows when focusing a window

commit 4d747e7ecac220b0b4a4a11c9b56bbb05ddd4f57
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Tue Jun 14 17:43:05 2022 +0000

    activate floating windows

commit f3284d7756c20b41b24df4f9fc0eca351a135183
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Tue Jun 14 16:42:18 2022 +0000

    add missing wlr-foreign-toplevel-management updates

commit 2c954a088cae74edff39712bc3ab4ed20fa57e63
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Tue Jun 14 15:55:30 2022 +0000

    tile minimized windows

commit cd81a991259b9f26f9834a7d16143e634bc353c7
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Jun 13 17:16:31 2022 +0000

    float by default when -f is specified

commit e91dde6ea85f9433dc867b63c75a418571679d8c
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Jun 13 17:02:10 2022 +0000

    center floating windows within the usable area

commit 4f0f369295fce6c64f5c0bdb8b748232b3085b0c
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Jun 13 16:49:55 2022 +0000

    respect the usable area when maximizing

commit 7a1b8207e6eb7f454a62cf377d53854a4dfa4122
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Jun 13 16:48:20 2022 +0000

    activate kiosk mode using -k

commit f6bdcab9ec029ce1ad1851b91db8101cdbb7b71f
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Jun 13 05:51:08 2022 +0000

    disable Xwayland at runtime if GDK_BACKEND=x11

commit 4701c81d3af1b49075f873ed0a17102ee4399d85
Merge: 128a3b6 583f471
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Jun 10 21:14:39 2022 +0300

    Merge branch 'main' of https://github.com/djpohly/dwl into dwl-kiosk

commit 128a3b6114a254fc12977c8687d9f7bcbf3ae4e8
Merge: 7cf1ac8 d969289
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Jun 10 19:23:41 2022 +0300

    Merge branch 'main' of https://github.com/djpohly/dwl into dwl-kiosk

commit 7cf1ac815850a7e4940dfa9aa23f4baf1810827c
Merge: 9da62b6 4dfa456
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Jun 6 19:02:52 2022 +0300

    Merge branch 'main' into dwl-kiosk

commit 9da62b6c5d5c3a99b2cce4ef827bc2af4d720d08
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Jun 6 19:02:02 2022 +0300

    add basic wlr-foreign-toplevel-management support

commit 93a25e164c9cb6f26393ad2444a0b5cbb0e8d3f9
Merge: 51b10ba 2623a96
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Jun 4 16:58:16 2022 +0800

    Merge branch 'main' of https://github.com/djpohly/dwl into dwl-kiosk

commit 51b10bac51e40b4ba39f208eb1493d37a5b4e186
Merge: 3abcf6e 52e0d00
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu May 26 14:03:49 2022 +0800

    Merge branch 'main' of https://github.com/djpohly/dwl into dwl-kiosk

commit 3abcf6e9075428157c2e2cffd7e6df934cd3b299
Merge: 7293f2c da4fd3c
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri May 20 14:28:59 2022 +0800

    Merge branch 'kiosk' of https://github.com/dimkr/dwl

commit 7293f2cc464624e0b9a201958cad88f9446e5e58
Merge: 2dfdd52 12e6a9b
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri May 20 14:28:01 2022 +0800

    Merge branch 'csd' of https://github.com/dimkr/dwl

commit 2dfdd529bce8cfc4047df6d5754547e5be920ca9
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri May 20 14:27:51 2022 +0800

    add support for resizing and moving of floating windows

commit fbf0edbb757274155f3499c1744694d79c31afd2
Merge: 76346dc 395c057
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri May 20 14:17:43 2022 +0800

    Merge branch 'fallback' of https://github.com/dimkr/dwl

commit 76346dcd20637d2edbb5f831130484ce0515190f
Merge: 936b5bd 0718815
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri May 20 14:17:34 2022 +0800

    Merge branch 'right' of https://github.com/dimkr/dwl

commit 936b5bdaaa36d98451d65052a5ca8079449e870c
Merge: 85502b7 a0abd9c
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri May 20 14:16:50 2022 +0800

    Merge branch 'input' of https://github.com/dimkr/dwl

commit 85502b7aec6196732f4e2bdfd802c8c1368f9c61
Merge: d6b0aca cf2000f
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri May 20 14:16:29 2022 +0800

    Merge branch 'output-power-management' of https://github.com/guidocella/dwl

commit d6b0aca985c4836140132d406b593e6f9829e9ff
Merge: 8870ba0 49bd8a8
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri May 20 14:14:27 2022 +0800

    Merge branch 'point' of https://github.com/PalanixYT/dwl

commit 0718815dc585183d642b06dba21d7015cdc94525
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Apr 22 15:59:27 2022 +0800

    extend the display to the right

commit da4fd3cab01010825d90bfd38b90b87bf076d490
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Apr 22 15:47:57 2022 +0800

    maximize the first window and make all others float

commit a0abd9c83d7980c2a807d4a96d58c40126f84590
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Apr 22 15:43:57 2022 +0800

    add support for pointer device configuration using environment variables

commit 395c0578f5248b5919ad7710e2094ae1b89cc7fc
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Apr 22 15:37:08 2022 +0800

    fall back to a lower output mode if needed (swaywm/sway@4cdc4ac)

commit 12e6a9bcf8225465c32ea4472a21cddc10b1cd34
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Apr 22 15:36:28 2022 +0800

    ask clients to draw their own decorations

commit 49bd8a8274d5803c90f0651bf1d9fa16e4f6d4ea
Author: Palanix <palanixyt@gmail.com>
Date:   Sun Mar 20 20:40:49 2022 +0100

    Fix pointerconstraints

    Fix pedantic

commit cf2000f2655de6829020dc0186333ac00e60567e
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Apr 4 01:20:06 2022 +0800

    damage the output after wlopm --on

commit e0f48b3ab478a7e67f00bb42171c311e334ee778
Author: Guido Cella <guido@guidocella.xyz>
Date:   Sun Mar 20 21:19:29 2022 +0100

    Implement the output power management protocol.

    I thought wlr-randr used this, but it doesn't so I don't even know what
    this is for.
---
 Makefile                                      |   8 +-
 config.def.h                                  |   3 +
 dwl.c                                         | 615 +++++++++++++++++-
 ...lr-output-power-management-unstable-v1.xml | 128 ++++
 4 files changed, 739 insertions(+), 15 deletions(-)
 create mode 100644 protocols/wlr-output-power-management-unstable-v1.xml

diff --git a/Makefile b/Makefile
index 2c1782b4..07bbcce8 100644
--- a/Makefile
+++ b/Makefile
@@ -23,7 +23,7 @@ LDLIBS    = `pkg-config --libs $(PKGS)` $(LIBS)
 all: dwl
 dwl: dwl.o util.o
 	$(CC) dwl.o util.o $(LDLIBS) $(LDFLAGS) -o $@
-dwl.o: dwl.c config.mk config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h idle-protocol.h
+dwl.o: dwl.c config.mk config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h idle-protocol.h pointer-constraints-unstable-v1-protocol.h wlr-output-power-management-unstable-v1-protocol.h
 util.o: util.c util.h
 
 # wayland scanner rules to generate .h / .c files
@@ -36,6 +36,12 @@ wlr-layer-shell-unstable-v1-protocol.h:
 idle-protocol.h:
 	$(WAYLAND_SCANNER) server-header \
 		protocols/idle.xml $@
+pointer-constraints-unstable-v1-protocol.h:
+	$(WAYLAND_SCANNER) server-header \
+		$(WAYLAND_PROTOCOLS)/unstable/pointer-constraints/pointer-constraints-unstable-v1.xml $@
+wlr-output-power-management-unstable-v1-protocol.h:
+	$(WAYLAND_SCANNER) server-header \
+		protocols/wlr-output-power-management-unstable-v1.xml $@
 
 config.h:
 	cp config.def.h $@
diff --git a/config.def.h b/config.def.h
index 43f35cd4..46eec04e 100644
--- a/config.def.h
+++ b/config.def.h
@@ -6,6 +6,9 @@ static const float rootcolor[]      = {0.3, 0.3, 0.3, 1.0};
 static const float bordercolor[]    = {0.5, 0.5, 0.5, 1.0};
 static const float focuscolor[]     = {1.0, 0.0, 0.0, 1.0};
 
+/* pointer constraints */
+static const int allow_constrain      = 1;
+
 /* tagging */
 static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
 
diff --git a/dwl.c b/dwl.c
index 04ba50fc..82389c3c 100644
--- a/dwl.c
+++ b/dwl.c
@@ -2,6 +2,7 @@
  * See LICENSE file for copyright and license details.
  */
 #define _POSIX_C_SOURCE 200809L
+#include <assert.h>
 #include <getopt.h>
 #include <libinput.h>
 #include <linux/input-event-codes.h>
@@ -21,6 +22,7 @@
 #include <wlr/types/wlr_data_control_v1.h>
 #include <wlr/types/wlr_data_device.h>
 #include <wlr/types/wlr_export_dmabuf_v1.h>
+#include <wlr/types/wlr_foreign_toplevel_management_v1.h>
 #include <wlr/types/wlr_gamma_control_v1.h>
 #include <wlr/types/wlr_idle.h>
 #include <wlr/types/wlr_idle_inhibit_v1.h>
@@ -29,12 +31,16 @@
 #include <wlr/types/wlr_keyboard.h>
 #include <wlr/types/wlr_layer_shell_v1.h>
 #include <wlr/types/wlr_output.h>
+#include <wlr/interfaces/wlr_output.h>
 #include <wlr/types/wlr_output_layout.h>
 #include <wlr/types/wlr_output_management_v1.h>
+#include <wlr/types/wlr_output_power_management_v1.h>
 #include <wlr/types/wlr_pointer.h>
 #include <wlr/types/wlr_presentation_time.h>
+#include <wlr/types/wlr_pointer_constraints_v1.h>
 #include <wlr/types/wlr_primary_selection.h>
 #include <wlr/types/wlr_primary_selection_v1.h>
+#include <wlr/types/wlr_relative_pointer_v1.h>
 #include <wlr/types/wlr_scene.h>
 #include <wlr/types/wlr_screencopy_v1.h>
 #include <wlr/types/wlr_seat.h>
@@ -95,6 +101,7 @@ typedef struct {
 	struct wlr_scene_node *scene;
 	struct wlr_scene_rect *border[4]; /* top, bottom, left, right */
 	struct wlr_scene_node *scene_surface;
+	struct wlr_foreign_toplevel_handle_v1 *toplevel_handle;
 	struct wl_list link;
 	struct wl_list flink;
 	union {
@@ -106,7 +113,15 @@ typedef struct {
 	struct wl_listener unmap;
 	struct wl_listener destroy;
 	struct wl_listener set_title;
+	struct wl_listener set_app_id;
 	struct wl_listener fullscreen;
+	struct wl_listener request_move;
+	struct wl_listener request_resize;
+	struct wl_listener request_maximize;
+	struct wl_listener request_minimize;
+	struct wl_listener toplevel_request_activate;
+	struct wl_listener toplevel_request_maximize;
+	struct wl_listener toplevel_request_minimize;
 	struct wlr_box geom, prev;  /* layout-relative, includes border */
 	Monitor *mon;
 #ifdef XWAYLAND
@@ -118,7 +133,9 @@ typedef struct {
 	unsigned int tags;
 	int isfloating, isurgent;
 	uint32_t resize; /* configure serial of a pending resize */
+	int allmons;
 	int isfullscreen;
+	int ismaximized;
 } Client;
 
 typedef struct {
@@ -193,6 +210,14 @@ typedef struct {
 	enum wl_output_transform rr;
 } MonitorRule;
 
+struct pointer_constraint {
+	struct wlr_pointer_constraint_v1 *constraint;
+
+	struct wl_listener set_region;
+	struct wl_listener destroy;
+};
+
+
 typedef struct {
 	const char *id;
 	const char *title;
@@ -202,10 +227,12 @@ typedef struct {
 } Rule;
 
 /* function declarations */
+static void activatetoplevel(struct wl_listener *listener, void *data);
 static void applybounds(Client *c, struct wlr_box *bbox);
 static void applyexclusive(struct wlr_box *usable_area, uint32_t anchor,
 		int32_t exclusive, int32_t margin_top, int32_t margin_right,
 		int32_t margin_bottom, int32_t margin_left);
+static void center(Client *c, const struct wlr_box *box);
 static void applyrules(Client *c);
 static void arrange(Monitor *m);
 static void arrangelayer(Monitor *m, struct wl_list *list,
@@ -226,10 +253,12 @@ static void createlayersurface(struct wl_listener *listener, void *data);
 static void createmon(struct wl_listener *listener, void *data);
 static void createnotify(struct wl_listener *listener, void *data);
 static void createpointer(struct wlr_input_device *device);
+static void createpointerconstraint(struct wl_listener *listener, void *data);
 static void cursorframe(struct wl_listener *listener, void *data);
 static void destroyidleinhibitor(struct wl_listener *listener, void *data);
 static void destroylayersurfacenotify(struct wl_listener *listener, void *data);
 static void destroynotify(struct wl_listener *listener, void *data);
+static void destroypointerconstraint(struct wl_listener *listener, void *data);
 static Monitor *dirtomon(enum wlr_direction dir);
 static void dragicondestroy(struct wl_listener *listener, void *data);
 static void focusclient(Client *c, int lift);
@@ -237,6 +266,7 @@ static void focusmon(const Arg *arg);
 static void focusstack(const Arg *arg);
 static Client *focustop(Monitor *m);
 static void fullscreennotify(struct wl_listener *listener, void *data);
+static void handleconstraintcommit(struct wl_listener *listener, void *data);
 static void incnmaster(const Arg *arg);
 static void inputdevice(struct wl_listener *listener, void *data);
 static int keybinding(uint32_t mods, xkb_keysym_t sym);
@@ -245,17 +275,21 @@ static void keypressmod(struct wl_listener *listener, void *data);
 static void killclient(const Arg *arg);
 static void maplayersurfacenotify(struct wl_listener *listener, void *data);
 static void mapnotify(struct wl_listener *listener, void *data);
+static void maximizetoplevel(struct wl_listener *listener, void *data);
+static void minimizetoplevel(struct wl_listener *listener, void *data);
 static void monocle(Monitor *m);
 static void motionabsolute(struct wl_listener *listener, void *data);
 static void motionnotify(uint32_t time);
 static void motionrelative(struct wl_listener *listener, void *data);
 static void moveresize(const Arg *arg);
+static void nextstacked(const Arg *arg);
 static void outputmgrapply(struct wl_listener *listener, void *data);
 static void outputmgrapplyortest(struct wlr_output_configuration_v1 *config, int test);
 static void outputmgrtest(struct wl_listener *listener, void *data);
 static void pointerfocus(Client *c, struct wlr_surface *surface,
 		double sx, double sy, uint32_t time);
 static void printstatus(void);
+static void powermgrsetmodenotify(struct wl_listener *listener, void *data);
 static void quit(const Arg *arg);
 static void quitsignal(int signo);
 static void rendermon(struct wl_listener *listener, void *data);
@@ -267,6 +301,7 @@ static void setcursor(struct wl_listener *listener, void *data);
 static void setfloating(Client *c, int floating);
 static void setfullscreen(Client *c, int fullscreen);
 static void setlayout(const Arg *arg);
+static void setmaximized(Client *c, int maximized);
 static void setmfact(const Arg *arg);
 static void setmon(Client *c, Monitor *m, unsigned int newtags);
 static void setpsel(struct wl_listener *listener, void *data);
@@ -275,16 +310,23 @@ static void setup(void);
 static void sigchld(int unused);
 static void spawn(const Arg *arg);
 static void startdrag(struct wl_listener *listener, void *data);
+static void startmove(struct wl_listener *listener, void *data);
+static void startresize(struct wl_listener *listener, void *data);
 static void tag(const Arg *arg);
 static void tagmon(const Arg *arg);
 static void tile(Monitor *m);
 static void togglefloating(const Arg *arg);
 static void togglefullscreen(const Arg *arg);
+static void togglemaximize(struct wl_listener *listener, void *data);
+static void togglemaximizesel(const Arg *arg);
+static void toggleminimize(struct wl_listener *listener, void *data);
+static void toggleminimizesel(const Arg *arg);
 static void toggletag(const Arg *arg);
 static void toggleview(const Arg *arg);
 static void unmaplayersurface(LayerSurface *layersurface);
 static void unmaplayersurfacenotify(struct wl_listener *listener, void *data);
 static void unmapnotify(struct wl_listener *listener, void *data);
+static void updateappid(struct wl_listener *listener, void *data);
 static void updatemons(struct wl_listener *listener, void *data);
 static void updatetitle(struct wl_listener *listener, void *data);
 static void urgent(struct wl_listener *listener, void *data);
@@ -313,6 +355,7 @@ static struct wl_list fstack;  /* focus order */
 static struct wlr_idle *idle;
 static struct wlr_idle_inhibit_manager_v1 *idle_inhibit_mgr;
 static struct wlr_input_inhibit_manager *input_inhibit_mgr;
+static struct wlr_foreign_toplevel_manager_v1 *foreign_toplevel_mgr;
 static struct wlr_layer_shell_v1 *layer_shell;
 static struct wlr_output_manager_v1 *output_mgr;
 static struct wlr_virtual_keyboard_manager_v1 *virtual_keyboard_mgr;
@@ -320,17 +363,27 @@ static struct wlr_virtual_keyboard_manager_v1 *virtual_keyboard_mgr;
 static struct wlr_cursor *cursor;
 static struct wlr_xcursor_manager *cursor_mgr;
 
+static struct wlr_output_power_manager_v1 *power_mgr;
+static struct wl_listener power_mgr_set_mode = {.notify = powermgrsetmodenotify};
+
 static struct wlr_seat *seat;
 static struct wl_list keyboards;
 static unsigned int cursor_mode;
 static Client *grabc;
 static int grabcx, grabcy; /* client-relative */
+static int kiosk = 0;
+static int floating = 0;
 
 static struct wlr_output_layout *output_layout;
 static struct wlr_box sgeom;
 static struct wl_list mons;
 static Monitor *selmon;
 
+struct wlr_pointer_constraints_v1 *pointer_constraints;
+struct wlr_pointer_constraint_v1 *active_constraint;
+static struct wl_listener constraint_commit;
+struct wlr_relative_pointer_manager_v1 *relative_pointer_manager;
+
 /* global event handlers */
 static struct wl_listener cursor_axis = {.notify = axisnotify};
 static struct wl_listener cursor_button = {.notify = buttonpress};
@@ -344,6 +397,7 @@ static struct wl_listener new_input = {.notify = inputdevice};
 static struct wl_listener new_virtual_keyboard = {.notify = virtualkeyboard};
 static struct wl_listener new_output = {.notify = createmon};
 static struct wl_listener new_xdg_surface = {.notify = createnotify};
+static struct wl_listener pointer_constraint_create = {.notify = createpointerconstraint};
 static struct wl_listener new_layer_shell_surface = {.notify = createlayersurface};
 static struct wl_listener output_mgr_apply = {.notify = outputmgrapply};
 static struct wl_listener output_mgr_test = {.notify = outputmgrtest};
@@ -378,6 +432,13 @@ static Atom netatom[NetLast];
 struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
 
 /* function implementations */
+void
+activatetoplevel(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, toplevel_request_activate);
+	focusclient(c, 1);
+}
+
 void
 applybounds(Client *c, struct wlr_box *bbox)
 {
@@ -450,6 +511,24 @@ applyexclusive(struct wlr_box *usable_area,
 	}
 }
 
+void
+center(Client *c, const struct wlr_box *box)
+{
+	c->geom.x = cursor->x - c->geom.width / 2;
+	if (c->geom.x + c->geom.width > box->x + box->width)
+		c->geom.x = box->x + box->width - c->geom.width;
+	if (c->geom.x < box->x || c->geom.width > box->width)
+		c->geom.x = box->x;
+
+	c->geom.y = cursor->y - c->geom.height / 2;
+	if (c->geom.y + c->geom.height > box->y + box->height)
+		c->geom.y = box->y + box->height - c->geom.height;
+	if (c->geom.y < box->y || c->geom.height > box->height)
+		c->geom.y = box->y;
+
+	wlr_scene_node_set_position(c->scene, c->geom.x, c->geom.y);
+}
+
 void
 applyrules(Client *c)
 {
@@ -458,6 +537,7 @@ applyrules(Client *c)
 	unsigned int i, newtags = 0;
 	const Rule *r;
 	Monitor *mon = selmon, *m;
+	Client *oc;
 
 	c->isfloating = client_is_float_type(c);
 	if (!(appid = client_get_appid(c)))
@@ -476,6 +556,22 @@ applyrules(Client *c)
 					mon = m;
 		}
 	}
+	if (kiosk) {
+		c->isfullscreen = 1;
+		c->allmons = 1;
+		wl_list_for_each(oc, &clients, link) {
+			if (oc != c) {
+				c->isfloating = 1;
+				c->isfullscreen = 0;
+				c->allmons = 0;
+				center(c, &mon->w);
+				break;
+			}
+		}
+	} else if (floating) {
+		c->isfloating = 1;
+		center(c, &mon->w);
+	}
 	wlr_scene_node_reparent(c->scene, layers[c->isfloating ? LyrFloat : LyrTile]);
 	setmon(c, mon, newtags);
 }
@@ -645,12 +741,11 @@ buttonpress(struct wl_listener *listener, void *data)
 		/* Don't focus unmanaged clients */
 		if (c && !client_is_unmanaged(c))
 			focusclient(c, 1);
-
 		keyboard = wlr_seat_get_keyboard(seat);
 		mods = keyboard ? wlr_keyboard_get_modifiers(keyboard) : 0;
 		for (b = buttons; b < END(buttons); b++) {
 			if (CLEANMASK(mods) == CLEANMASK(b->mod) &&
-					event->button == b->button && b->func) {
+					event->button == b->button && b->func && !kiosk) {
 				b->func(&b->arg);
 				return;
 			}
@@ -880,8 +975,10 @@ createmon(struct wl_listener *listener, void *data)
 	/* This event is raised by the backend when a new output (aka a display or
 	 * monitor) becomes available. */
 	struct wlr_output *wlr_output = data;
+	struct wlr_output_mode *preferred_mode, *mode;
 	const MonitorRule *r;
-	Monitor *m = wlr_output->data = ecalloc(1, sizeof(*m));
+	int max_x = 0, max_x_y = 0, width, height;
+	Monitor *om, *m = wlr_output->data = ecalloc(1, sizeof(*m));
 	m->wlr_output = wlr_output;
 
 	wlr_output_init_render(wlr_output, alloc, drw);
@@ -906,7 +1003,17 @@ createmon(struct wl_listener *listener, void *data)
 	 * monitor supports only a specific set of modes. We just pick the
 	 * monitor's preferred mode; a more sophisticated compositor would let
 	 * the user configure it. */
-	wlr_output_set_mode(wlr_output, wlr_output_preferred_mode(wlr_output));
+	preferred_mode = wlr_output_preferred_mode(wlr_output);
+	wlr_output_set_mode(wlr_output, preferred_mode);
+	if (!wlr_output_test(wlr_output) && !wl_list_empty(&wlr_output->modes)) {
+		wl_list_for_each(mode, &wlr_output->modes, link) {
+			if (mode != preferred_mode) {
+				wlr_output_set_mode(wlr_output, mode);
+				if (wlr_output_test(wlr_output))
+					break;
+			}
+		}
+	}
 	wlr_output_enable_adaptive_sync(wlr_output, 1);
 
 	/* Set up event listeners */
@@ -917,6 +1024,14 @@ createmon(struct wl_listener *listener, void *data)
 	if (!wlr_output_commit(wlr_output))
 		return;
 
+	wl_list_for_each(om, &mons, link) {
+		wlr_output_effective_resolution(om->wlr_output, &width, &height);
+		if (om->m.x + width > max_x) {
+			max_x = om->m.x + width;
+			max_x_y = om->m.y;
+		}
+	}
+
 	wl_list_insert(&mons, &m->link);
 	printstatus();
 
@@ -927,7 +1042,7 @@ createmon(struct wl_listener *listener, void *data)
 	 * output (such as DPI, scale factor, manufacturer, etc).
 	 */
 	m->scene_output = wlr_scene_output_create(scene, wlr_output);
-	wlr_output_layout_add_auto(output_layout, wlr_output);
+	wlr_output_layout_add(output_layout, wlr_output, max_x, max_x_y);
 
 	/* If length == 1 we need update selmon.
 	 * Maybe it will change in run(). */
@@ -940,6 +1055,28 @@ createmon(struct wl_listener *listener, void *data)
 	}
 }
 
+void
+createpointerconstraint(struct wl_listener *listener, void *data)
+{
+	struct wlr_pointer_constraint_v1 *constraint = data;
+	struct pointer_constraint *pointer_constraint = calloc(1, sizeof(struct pointer_constraint));
+	pointer_constraint->constraint = constraint;
+	
+	pointer_constraint->destroy.notify = destroypointerconstraint;
+	wl_signal_add(&constraint->events.destroy, &pointer_constraint->destroy);
+	
+	if (client_surface(selclient()) == constraint->surface) {
+		if (allow_constrain == 0 || active_constraint == constraint)
+			return;
+
+		active_constraint = constraint;
+		wlr_pointer_constraint_v1_send_activated(constraint);
+
+		constraint_commit.notify = handleconstraintcommit;
+		wl_signal_add(&constraint->surface->events.commit, &constraint_commit);
+	}
+}
+
 void
 createnotify(struct wl_listener *listener, void *data)
 {
@@ -975,9 +1112,199 @@ createnotify(struct wl_listener *listener, void *data)
 	LISTEN(&xdg_surface->events.unmap, &c->unmap, unmapnotify);
 	LISTEN(&xdg_surface->events.destroy, &c->destroy, destroynotify);
 	LISTEN(&xdg_surface->toplevel->events.set_title, &c->set_title, updatetitle);
+	LISTEN(&xdg_surface->toplevel->events.set_app_id, &c->set_app_id, updateappid);
 	LISTEN(&xdg_surface->toplevel->events.request_fullscreen, &c->fullscreen,
 			fullscreennotify);
+	LISTEN(&xdg_surface->toplevel->events.request_move, &c->request_move,
+			startmove);
+	LISTEN(&xdg_surface->toplevel->events.request_resize, &c->request_resize,
+			startresize);
+	LISTEN(&xdg_surface->toplevel->events.request_maximize, &c->request_maximize,
+			togglemaximize);
+	LISTEN(&xdg_surface->toplevel->events.request_minimize, &c->request_minimize,
+			toggleminimize);
+
+	c->toplevel_handle = wlr_foreign_toplevel_handle_v1_create(
+			foreign_toplevel_mgr);
+	if (c->toplevel_handle) {
+		LISTEN(&c->toplevel_handle->events.request_activate,
+				&c->toplevel_request_activate, activatetoplevel);
+		LISTEN(&c->toplevel_handle->events.request_maximize,
+				&c->toplevel_request_maximize, maximizetoplevel);
+		LISTEN(&c->toplevel_handle->events.request_minimize,
+				&c->toplevel_request_minimize, minimizetoplevel);
+	}
 	c->isfullscreen = 0;
+	c->ismaximized = 0;
+}
+
+static int
+isenabled(const char *val, int def)
+{
+	return ((def && (!val || !val[0] || (val[0] != '0'))) || (!def && (val && val[0] && (val[0] != '0'))));
+}
+
+static void
+setclickmethod(struct libinput_device *libinput_device)
+{
+	const char *val;
+	long l;
+	char *end = NULL;
+	enum libinput_config_click_method method = LIBINPUT_CONFIG_CLICK_METHOD_NONE;
+
+	val = getenv("LIBINPUT_DEFAULT_CLICK_METHOD");
+	if (!val || !val[0])
+		return;
+
+	errno = 0;
+	l = strtol(val, &end, 10);
+	if (errno || (end && *end))
+		return;
+
+	libinput_device_config_click_set_method(libinput_device,
+		(enum libinput_config_click_method)l);
+}
+
+static void
+settap(struct libinput_device *libinput_device)
+{
+	const char *val;
+	enum libinput_config_tap_state state = LIBINPUT_CONFIG_TAP_DISABLED;
+
+	val = getenv("LIBINPUT_DEFAULT_TAP");
+	if (val) {
+		if (!val[0])
+			return;
+
+		libinput_device_config_tap_set_enabled(libinput_device,
+			isenabled(val, 1) ? LIBINPUT_CONFIG_TAP_ENABLED :
+				LIBINPUT_CONFIG_TAP_DISABLED);
+	} else if (tap_to_click && libinput_device_config_tap_get_finger_count(libinput_device))
+		libinput_device_config_tap_set_enabled(libinput_device,
+			LIBINPUT_CONFIG_TAP_ENABLED);
+}
+
+static void
+settapanddrag(struct libinput_device *libinput_device)
+{
+	const char *val;
+
+	val = getenv("LIBINPUT_DEFAULT_DRAG");
+	if (val && val[0])
+		libinput_device_config_tap_set_drag_enabled(libinput_device,
+			isenabled(val, 1) ? LIBINPUT_CONFIG_DRAG_ENABLED :
+				LIBINPUT_CONFIG_DRAG_DISABLED);
+}
+
+static void
+setnaturalscroll(struct libinput_device *libinput_device)
+{
+	const char *val;
+	enum libinput_config_status status;
+
+	val = getenv("LIBINPUT_DEFAULT_NATURAL_SCROLL");
+	if (val && val[0])
+		libinput_device_config_scroll_set_natural_scroll_enabled(
+			libinput_device, isenabled(val, 0));
+	else if (!val && libinput_device_config_scroll_has_natural_scroll(libinput_device))
+		libinput_device_config_scroll_set_natural_scroll_enabled(
+			libinput_device, natural_scrolling);
+}
+
+static void
+setaccelprofile(struct libinput_device *libinput_device)
+{
+	const char *val;
+	double profile;
+	char *end = NULL;
+	enum libinput_config_status status;
+
+	val = getenv("LIBINPUT_DEFAULT_ACCELERATION_PROFILE");
+	if (!val || !val[0])
+		return;
+
+	errno = 0;
+	profile = strtod(val, &end);
+	if (errno || (end && *end))
+		return;
+
+	libinput_device_config_accel_set_profile(libinput_device,
+		(enum libinput_config_accel_profile)profile);
+}
+
+static void
+setaccelspeed(struct libinput_device *libinput_device)
+{
+	const char *val;
+	double accel = 0;
+	char *end = NULL;
+
+	val = getenv("LIBINPUT_DEFAULT_ACCELERATION");
+	if (!val || !val[0])
+		return;
+
+	errno = 0;
+	accel = strtod(val, &end);
+	if (errno || (end && *end) || (accel < -1) || (accel > 1))
+		return;
+
+	libinput_device_config_accel_set_speed(libinput_device, accel);
+}
+
+static void
+setscrollmethod(struct libinput_device *libinput_device)
+{
+	const char *val;
+	long l;
+	char *end = NULL;
+	enum libinput_config_status status;
+
+	val = getenv("LIBINPUT_DEFAULT_SCROLL_METHOD");
+	if (!val || !val[0])
+		return;
+
+	errno = 0;
+	l = strtol(val, &end, 10);
+	if (errno || (end && *end))
+		return;
+
+	libinput_device_config_scroll_set_method(libinput_device,
+		(enum libinput_config_scroll_method)l);
+}
+
+static void
+setdwt(struct libinput_device *libinput_device)
+{
+	const char *val;
+
+	val = getenv("LIBINPUT_DEFAULT_DISABLE_WHILE_TYPING");
+	if (val && val[0])
+		libinput_device_config_dwt_set_enabled(libinput_device,
+			isenabled(val, false) ? LIBINPUT_CONFIG_DWT_ENABLED :
+				LIBINPUT_CONFIG_DWT_DISABLED);
+}
+
+static void
+setmiddleemul(struct libinput_device *libinput_device)
+{
+	const char *val;
+
+	val = getenv("LIBINPUT_DEFAULT_MIDDLE_EMULATION");
+	if (val && val[0])
+		libinput_device_config_middle_emulation_set_enabled(libinput_device,
+			isenabled(val, false) ? LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED :
+				LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED);
+}
+
+static void
+setlefthanded(struct libinput_device *libinput_device)
+{
+	const char *val;
+
+	val = getenv("LIBINPUT_DEFAULT_LEFT_HANDED");
+	if (val && val[0])
+		libinput_device_config_left_handed_set(libinput_device,
+			isenabled(val, 0));
 }
 
 void
@@ -987,6 +1314,7 @@ createpointer(struct wlr_input_device *device)
 		struct libinput_device *libinput_device =  (struct libinput_device*)
 			wlr_libinput_get_device_handle(device);
 
+#if 0
 		if (libinput_device_config_tap_get_finger_count(libinput_device)) {
 			libinput_device_config_tap_set_enabled(libinput_device, tap_to_click);
 			libinput_device_config_tap_set_drag_enabled(libinput_device, tap_and_drag);
@@ -1018,11 +1346,42 @@ createpointer(struct wlr_input_device *device)
 			libinput_device_config_accel_set_profile(libinput_device, accel_profile);
 			libinput_device_config_accel_set_speed(libinput_device, accel_speed);
 		}
+#endif
+
+		setclickmethod(libinput_device);
+		settap(libinput_device);
+		settapanddrag(libinput_device);
+		setnaturalscroll(libinput_device);
+		setaccelprofile(libinput_device);
+		setaccelspeed(libinput_device);
+		setscrollmethod(libinput_device);
+		setdwt(libinput_device);
+		setmiddleemul(libinput_device);
+		setlefthanded(libinput_device);
 	}
 
 	wlr_cursor_attach_input_device(cursor, device);
 }
 
+void
+destroypointerconstraint(struct wl_listener *listener, void *data)
+{
+	struct wlr_pointer_constraint_v1 *constraint = data;
+	struct pointer_constraint *pointer_constraint = wl_container_of(listener, pointer_constraint, destroy);
+
+	wl_list_remove(&pointer_constraint->destroy.link);
+
+	if (active_constraint == constraint) {
+		if (constraint_commit.link.next != NULL) {
+			wl_list_remove(&constraint_commit.link);
+		}
+		wl_list_init(&constraint_commit.link);
+		active_constraint = NULL;
+	}
+
+	free(pointer_constraint);
+}
+
 void
 cursorframe(struct wl_listener *listener, void *data)
 {
@@ -1069,11 +1428,22 @@ destroynotify(struct wl_listener *listener, void *data)
 {
 	/* Called when the surface is destroyed and should never be shown again. */
 	Client *c = wl_container_of(listener, c, destroy);
+	if (c->toplevel_handle) {
+		wl_list_remove(&c->toplevel_request_activate.link);
+		wl_list_remove(&c->toplevel_request_maximize.link);
+		wl_list_remove(&c->toplevel_request_minimize.link);
+		wlr_foreign_toplevel_handle_v1_destroy(c->toplevel_handle);
+	}
 	wl_list_remove(&c->map.link);
 	wl_list_remove(&c->unmap.link);
 	wl_list_remove(&c->destroy.link);
 	wl_list_remove(&c->set_title.link);
+	wl_list_remove(&c->set_app_id.link);
 	wl_list_remove(&c->fullscreen.link);
+	wl_list_remove(&c->request_move.link);
+	wl_list_remove(&c->request_resize.link);
+	wl_list_remove(&c->request_maximize.link);
+	wl_list_remove(&c->request_minimize.link);
 #ifdef XWAYLAND
 	if (c->type != XDGShell) {
 		wl_list_remove(&c->configure.link);
@@ -1112,17 +1482,25 @@ dragicondestroy(struct wl_listener *listener, void *data)
 void
 focusclient(Client *c, int lift)
 {
+	Client *other;
 	struct wlr_surface *old = seat->keyboard_state.focused_surface;
 	struct wlr_keyboard *kb;
 	int i;
 
 	/* Raise client in stacking order if requested */
-	if (c && lift)
+	if (c && lift && (!kiosk || c->isfloating))
 		wlr_scene_node_raise_to_top(c->scene);
 
 	if (c && client_surface(c) == old)
 		return;
 
+	if (c) {
+		wl_list_for_each(other, &fstack, flink) {
+			if (other != c && VISIBLEON(other, c->mon) && other->toplevel_handle)
+				wlr_foreign_toplevel_handle_v1_set_activated(other->toplevel_handle, false);
+		}
+	}
+
 	/* Put the new client atop the focus stack and select its monitor */
 	if (c) {
 		wl_list_remove(&c->flink);
@@ -1180,6 +1558,9 @@ focusclient(Client *c, int lift)
 
 	/* Activate the new client */
 	client_activate_surface(client_surface(c), 1);
+
+	if (c->toplevel_handle)
+		wlr_foreign_toplevel_handle_v1_set_activated(c->toplevel_handle, true);
 }
 
 void
@@ -1241,6 +1622,12 @@ fullscreennotify(struct wl_listener *listener, void *data)
 	setfullscreen(c, fullscreen);
 }
 
+void
+handleconstraintcommit(struct wl_listener *listener, void *data)
+{
+	assert(active_constraint->surface == data);
+}
+
 void
 incnmaster(const Arg *arg)
 {
@@ -1290,7 +1677,7 @@ keybinding(uint32_t mods, xkb_keysym_t sym)
 	const Key *k;
 	for (k = keys; k < END(keys); k++) {
 		if (CLEANMASK(mods) == CLEANMASK(k->mod) &&
-				sym == k->keysym && k->func) {
+				sym == k->keysym && k->func && (!kiosk || k->func == chvt)) {
 			k->func(&k->arg);
 			handled = 1;
 		}
@@ -1372,6 +1759,7 @@ void
 mapnotify(struct wl_listener *listener, void *data)
 {
 	/* Called when the surface is mapped, or ready to display on-screen. */
+	const char *appid, *title;
 	Client *c = wl_container_of(listener, c, map);
 	int i;
 
@@ -1400,7 +1788,6 @@ mapnotify(struct wl_listener *listener, void *data)
 	}
 
 	/* Initialize client geometry with room for border */
-	client_set_tiled(c, WLR_EDGE_TOP | WLR_EDGE_BOTTOM | WLR_EDGE_LEFT | WLR_EDGE_RIGHT);
 	client_get_geometry(c, &c->geom);
 	c->geom.width += 2 * c->bw;
 	c->geom.height += 2 * c->bw;
@@ -1415,10 +1802,33 @@ mapnotify(struct wl_listener *listener, void *data)
 
 	if (c->isfullscreen)
 		setfullscreen(c, 1);
+	if (!c->isfloating)
+		client_set_tiled(c, WLR_EDGE_TOP | WLR_EDGE_BOTTOM | WLR_EDGE_LEFT | WLR_EDGE_RIGHT);
+
+	if (c->toplevel_handle) {
+		wlr_foreign_toplevel_handle_v1_set_title(c->toplevel_handle, (title = client_get_title(c)) ? title : broken);
+		wlr_foreign_toplevel_handle_v1_set_app_id(c->toplevel_handle, (appid = client_get_appid(c)) ? appid : broken);
+	}
 
 	c->mon->un_map = 1;
 }
 
+void
+maximizetoplevel(struct wl_listener *listener, void *data)
+{
+	struct wlr_foreign_toplevel_handle_v1_maximized_event *event = data;
+	Client *c = wl_container_of(listener, c, toplevel_request_maximize);
+	setmaximized(c, event->maximized);
+}
+
+void
+minimizetoplevel(struct wl_listener *listener, void *data)
+{
+	struct wlr_foreign_toplevel_handle_v1_minimized_event *event = data;
+	Client *c = wl_container_of(listener, c, toplevel_request_minimize);
+	setfloating(c, !event->minimized);
+}
+
 void
 monocle(Monitor *m)
 {
@@ -1502,7 +1912,15 @@ motionrelative(struct wl_listener *listener, void *data)
 	 * special configuration applied for the specific input device which
 	 * generated the event. You can pass NULL for the device if you want to move
 	 * the cursor around without any input. */
-	wlr_cursor_move(cursor, event->device, event->delta_x, event->delta_y);
+	wlr_relative_pointer_manager_v1_send_relative_motion(
+		relative_pointer_manager,
+		seat, (uint64_t)event->time_msec * 1000,
+		event->delta_x, event->delta_y, event->unaccel_dx, event->unaccel_dy);
+
+	if (!active_constraint) {
+		wlr_cursor_move(cursor, event->device,
+			event->delta_x, event->delta_y);
+	}
 	motionnotify(event->time_msec);
 }
 
@@ -1517,6 +1935,8 @@ moveresize(const Arg *arg)
 
 	/* Float the window and tell motionnotify to grab it */
 	setfloating(grabc, 1);
+	if (grabc->ismaximized)
+		setmaximized(grabc, 0);
 	switch (cursor_mode = arg->ui) {
 	case CurMove:
 		grabcx = cursor->x - grabc->geom.x;
@@ -1535,6 +1955,17 @@ moveresize(const Arg *arg)
 	}
 }
 
+void nextstacked(const Arg *arg)
+{
+	Client *c, *next;
+	c = selclient();
+	if (!c)
+		return;
+	next = wl_container_of(c->flink.next, next, flink);
+	if (&next->flink != &fstack)
+		focusclient(next, 1);
+}
+
 void
 outputmgrapply(struct wl_listener *listener, void *data)
 {
@@ -1661,6 +2092,16 @@ printstatus(void)
 	fflush(stdout);
 }
 
+void
+powermgrsetmodenotify(struct wl_listener *listener, void *data)
+{
+	struct wlr_output_power_v1_set_mode_event *event = data;
+	wlr_output_enable(event->output, event->mode);
+	if (event->mode)
+		wlr_output_damage_whole(event->output);
+	wlr_output_commit(event->output);
+}
+
 void
 quit(const Arg *arg)
 {
@@ -1790,7 +2231,10 @@ run(char *startup_cmd)
 	 * instead of (0, 0) and then jumping.  still may not be fully
 	 * initialized, as the image/coordinates are not transformed for the
 	 * monitor when displayed here */
-	wlr_cursor_warp_closest(cursor, NULL, cursor->x, cursor->y);
+	if (selmon)
+		wlr_cursor_warp_closest(cursor, NULL, selmon->w.x + selmon->w.width / 2, selmon->w.y + selmon->w.height / 2);
+	else
+		wlr_cursor_warp_closest(cursor, NULL, cursor->x, cursor->y);
 	wlr_xcursor_manager_set_cursor_image(cursor_mgr, "left_ptr", cursor);
 
 	/* Run the Wayland event loop. This does not return until you exit the
@@ -1832,7 +2276,12 @@ void
 setfloating(Client *c, int floating)
 {
 	c->isfloating = floating;
+	client_set_tiled(c, floating ? 0 : WLR_EDGE_TOP | WLR_EDGE_BOTTOM | WLR_EDGE_LEFT | WLR_EDGE_RIGHT);
 	wlr_scene_node_reparent(c->scene, layers[c->isfloating ? LyrFloat : LyrTile]);
+	if (floating)
+		center(c, &c->mon->w);
+	if (c->toplevel_handle)
+		wlr_foreign_toplevel_handle_v1_set_minimized(c->toplevel_handle, !c->isfloating);
 	arrange(c->mon);
 	printstatus();
 }
@@ -1840,19 +2289,26 @@ setfloating(Client *c, int floating)
 void
 setfullscreen(Client *c, int fullscreen)
 {
+	struct wlr_box *layout_box;
+
 	c->isfullscreen = fullscreen;
 	c->bw = fullscreen ? 0 : borderpx;
 	client_set_fullscreen(c, fullscreen);
 
 	if (fullscreen) {
 		c->prev = c->geom;
-		resize(c, c->mon->m.x, c->mon->m.y, c->mon->m.width, c->mon->m.height, 0);
+		if (c->allmons) {
+			layout_box = wlr_output_layout_get_box(output_layout, NULL);
+			resize(c, layout_box->x, layout_box->y, layout_box->width, layout_box->height, 0);
+		} else resize(c, c->mon->m.x, c->mon->m.y, c->mon->m.width, c->mon->m.height, 0);
 	} else {
 		/* restore previous size instead of arrange for floating windows since
 		 * client positions are set by the user and cannot be recalculated */
 		resize(c, c->prev.x, c->prev.y, c->prev.width, c->prev.height, 0);
 	}
 	arrange(c->mon);
+	if (c->toplevel_handle)
+		wlr_foreign_toplevel_handle_v1_set_fullscreen(c->toplevel_handle, fullscreen);
 	printstatus();
 }
 
@@ -1868,6 +2324,27 @@ setlayout(const Arg *arg)
 	printstatus();
 }
 
+void
+setmaximized(Client *c, int maximized)
+{
+	if (c->isfullscreen)
+		return;
+	if (!c->isfloating)
+		setfloating(c, 1);
+
+	c->ismaximized = maximized;
+
+	if (maximized) {
+		c->prev = c->geom;
+		resize(c, c->mon->w.x, c->mon->w.y, c->mon->w.width, c->mon->w.height, 0);
+	} else
+		resize(c, c->prev.x, c->prev.y, c->prev.width, c->prev.height, 0);
+	arrange(c->mon);
+	if (c->toplevel_handle)
+		wlr_foreign_toplevel_handle_v1_set_maximized(c->toplevel_handle, maximized);
+	printstatus();
+}
+
 /* arg > 1.0 will set mfact absolutely */
 void
 setmfact(const Arg *arg)
@@ -1895,6 +2372,9 @@ setmon(Client *c, Monitor *m, unsigned int newtags)
 	/* TODO leave/enter is not optimal but works */
 	if (oldmon) {
 		wlr_surface_send_leave(client_surface(c), oldmon->wlr_output);
+		if (c->toplevel_handle)
+			wlr_foreign_toplevel_handle_v1_output_leave(c->toplevel_handle,
+					oldmon->wlr_output);
 		arrange(oldmon);
 	}
 	if (m) {
@@ -1905,6 +2385,9 @@ setmon(Client *c, Monitor *m, unsigned int newtags)
 		arrange(m);
 	}
 	focusclient(focustop(selmon), 1);
+	if (c->toplevel_handle && c->mon)
+		wlr_foreign_toplevel_handle_v1_output_enter(c->toplevel_handle,
+				c->mon->wlr_output);
 }
 
 void
@@ -1932,6 +2415,8 @@ setsel(struct wl_listener *listener, void *data)
 void
 setup(void)
 {
+	const char *gdk_backend;
+
 	/* The Wayland display is managed by libwayland. It handles accepting
 	 * clients from the Unix socket, manging Wayland globals, and so on. */
 	dpy = wl_display_create();
@@ -1990,6 +2475,9 @@ setup(void)
 	activation = wlr_xdg_activation_v1_create(dpy);
 	wl_signal_add(&activation->events.request_activate, &request_activate);
 
+	power_mgr = wlr_output_power_manager_v1_create(dpy);
+	wl_signal_add(&power_mgr->events.set_mode, &power_mgr_set_mode);
+
 	/* Creates an output layout, which a wlroots utility for working with an
 	 * arrangement of screens in a physical layout. */
 	output_layout = wlr_output_layout_create();
@@ -2023,12 +2511,19 @@ setup(void)
 
 	input_inhibit_mgr = wlr_input_inhibit_manager_create(dpy);
 
+	foreign_toplevel_mgr = wlr_foreign_toplevel_manager_v1_create(dpy);
+
 	/* Use decoration protocols to negotiate server-side decorations */
 	wlr_server_decoration_manager_set_default_mode(
 			wlr_server_decoration_manager_create(dpy),
-			WLR_SERVER_DECORATION_MANAGER_MODE_SERVER);
+			WLR_SERVER_DECORATION_MANAGER_MODE_CLIENT);
 	wlr_xdg_decoration_manager_v1_create(dpy);
 
+	pointer_constraints = wlr_pointer_constraints_v1_create(dpy);
+	wl_signal_add(&pointer_constraints->events.new_constraint, &pointer_constraint_create);
+	
+	relative_pointer_manager = wlr_relative_pointer_manager_v1_create(dpy);
+
 	/*
 	 * Creates a cursor, which is a wlroots utility for tracking the cursor
 	 * image shown on screen.
@@ -2085,6 +2580,13 @@ setup(void)
 	wlr_scene_set_presentation(scene, wlr_presentation_create(dpy, backend));
 
 #ifdef XWAYLAND
+	/*
+	 * XWayland is started and DISPLAY is set manually if GDK_BACKEND=x11
+	 */
+	gdk_backend = getenv("GDK_BACKEND");
+	if (gdk_backend && strcmp(gdk_backend, "x11") == 0)
+		return;
+
 	/*
 	 * Initialise the XWayland X server.
 	 * It will be started when the first X client is started.
@@ -2141,6 +2643,22 @@ startdrag(struct wl_listener *listener, void *data)
 	wl_signal_add(&drag->icon->events.destroy, &drag_icon_destroy);
 }
 
+void
+startmove(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, request_move);
+
+	moveresize(&(Arg){.ui = CurMove});
+}
+
+void
+startresize(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, request_resize);
+
+	moveresize(&(Arg){.ui = CurResize});
+}
+
 void
 tag(const Arg *arg)
 {
@@ -2212,6 +2730,38 @@ togglefullscreen(const Arg *arg)
 		setfullscreen(sel, !sel->isfullscreen);
 }
 
+void
+togglemaximize(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, request_maximize);
+
+	setmaximized(c, !c->ismaximized);
+}
+
+void
+togglemaximizesel(const Arg *arg)
+{
+	Client *sel = selclient();
+	if (sel)
+		setmaximized(sel, !sel->ismaximized);
+}
+
+void
+toggleminimize(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, request_minimize);
+
+	setfloating(c, !c->isfloating);
+}
+
+void
+toggleminimizesel(const Arg *arg)
+{
+	Client *sel = selclient();
+	if (sel)
+		setfloating(sel, !sel->isfloating);
+}
+
 void
 toggletag(const Arg *arg)
 {
@@ -2284,6 +2834,15 @@ unmapnotify(struct wl_listener *listener, void *data)
 	printstatus();
 }
 
+void
+updateappid(struct wl_listener *listener, void *data)
+{
+	const char *appid;
+	Client *c = wl_container_of(listener, c, set_app_id);
+	if (c->toplevel_handle)
+		wlr_foreign_toplevel_handle_v1_set_app_id(c->toplevel_handle, (appid = client_get_appid(c)) ? appid : broken);
+}
+
 void
 updatemons(struct wl_listener *listener, void *data)
 {
@@ -2325,9 +2884,12 @@ updatemons(struct wl_listener *listener, void *data)
 void
 updatetitle(struct wl_listener *listener, void *data)
 {
+	const char *title;
 	Client *c = wl_container_of(listener, c, set_title);
 	if (c == focustop(c->mon))
 		printstatus();
+	if (c->toplevel_handle)
+		wlr_foreign_toplevel_handle_v1_set_title(c->toplevel_handle, (title = client_get_title(c)) ? title : broken);
 }
 
 void
@@ -2469,6 +3031,7 @@ createnotifyx11(struct wl_listener *listener, void *data)
 	c->type = xwayland_surface->override_redirect ? X11Unmanaged : X11Managed;
 	c->bw = borderpx;
 	c->isfullscreen = 0;
+	c->ismaximized = 0;
 
 	/* Listen to the various events it can emit */
 	LISTEN(&xwayland_surface->events.map, &c->map, mapnotify);
@@ -2478,9 +3041,29 @@ createnotifyx11(struct wl_listener *listener, void *data)
 			configurex11);
 	LISTEN(&xwayland_surface->events.set_hints, &c->set_hints, sethints);
 	LISTEN(&xwayland_surface->events.set_title, &c->set_title, updatetitle);
+	LISTEN(&xwayland_surface->events.set_class, &c->set_app_id, updateappid);
 	LISTEN(&xwayland_surface->events.destroy, &c->destroy, destroynotify);
 	LISTEN(&xwayland_surface->events.request_fullscreen, &c->fullscreen,
 			fullscreennotify);
+	LISTEN(&xwayland_surface->events.request_move, &c->request_move,
+			startmove);
+	LISTEN(&xwayland_surface->events.request_resize, &c->request_resize,
+			startresize);
+	LISTEN(&xwayland_surface->events.request_maximize, &c->request_maximize,
+			togglemaximize);
+	LISTEN(&xwayland_surface->events.request_minimize, &c->request_minimize,
+			toggleminimize);
+
+	c->toplevel_handle = wlr_foreign_toplevel_handle_v1_create(
+			foreign_toplevel_mgr);
+	if (c->toplevel_handle) {
+		LISTEN(&c->toplevel_handle->events.request_activate,
+				&c->toplevel_request_activate, activatetoplevel);
+		LISTEN(&c->toplevel_handle->events.request_maximize,
+				&c->toplevel_request_maximize, maximizetoplevel);
+		LISTEN(&c->toplevel_handle->events.request_minimize,
+				&c->toplevel_request_minimize, minimizetoplevel);
+	}
 }
 
 Atom
@@ -2544,11 +3127,15 @@ main(int argc, char *argv[])
 	char *startup_cmd = NULL;
 	int c;
 
-	while ((c = getopt(argc, argv, "s:hv")) != -1) {
+	while ((c = getopt(argc, argv, "s:hvfk")) != -1) {
 		if (c == 's')
 			startup_cmd = optarg;
 		else if (c == 'v')
 			die("dwl " VERSION);
+		else if (c == 'f')
+			floating = 1;
+		else if (c == 'k')
+			kiosk = 1;
 		else
 			goto usage;
 	}
@@ -2564,5 +3151,5 @@ main(int argc, char *argv[])
 	return EXIT_SUCCESS;
 
 usage:
-	die("Usage: %s [-v] [-s startup command]", argv[0]);
+	die("Usage: %s [-v] [-f] [-k] [-s startup command]", argv[0]);
 }
diff --git a/protocols/wlr-output-power-management-unstable-v1.xml b/protocols/wlr-output-power-management-unstable-v1.xml
new file mode 100644
index 00000000..a9778399
--- /dev/null
+++ b/protocols/wlr-output-power-management-unstable-v1.xml
@@ -0,0 +1,128 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="wlr_output_power_management_unstable_v1">
+  <copyright>
+    Copyright Â© 2019 Purism SPC
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <description summary="Control power management modes of outputs">
+    This protocol allows clients to control power management modes
+    of outputs that are currently part of the compositor space. The
+    intent is to allow special clients like desktop shells to power
+    down outputs when the system is idle.
+
+    To modify outputs not currently part of the compositor space see
+    wlr-output-management.
+
+    Warning! The protocol described in this file is experimental and
+    backward incompatible changes may be made. Backward compatible changes
+    may be added together with the corresponding interface version bump.
+    Backward incompatible changes are done by bumping the version number in
+    the protocol and interface names and resetting the interface version.
+    Once the protocol is to be declared stable, the 'z' prefix and the
+    version number in the protocol and interface names are removed and the
+    interface version number is reset.
+  </description>
+
+  <interface name="zwlr_output_power_manager_v1" version="1">
+    <description summary="manager to create per-output power management">
+      This interface is a manager that allows creating per-output power
+      management mode controls.
+    </description>
+
+    <request name="get_output_power">
+      <description summary="get a power management for an output">
+        Create a output power management mode control that can be used to
+        adjust the power management mode for a given output.
+      </description>
+      <arg name="id" type="new_id" interface="zwlr_output_power_v1"/>
+      <arg name="output" type="object" interface="wl_output"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the manager">
+        All objects created by the manager will still remain valid, until their
+        appropriate destroy request has been called.
+      </description>
+    </request>
+  </interface>
+
+  <interface name="zwlr_output_power_v1" version="1">
+    <description summary="adjust power management mode for an output">
+      This object offers requests to set the power management mode of
+      an output.
+    </description>
+
+    <enum name="mode">
+      <entry name="off" value="0"
+             summary="Output is turned off."/>
+      <entry name="on" value="1"
+             summary="Output is turned on, no power saving"/>
+    </enum>
+
+    <enum name="error">
+      <entry name="invalid_mode" value="1" summary="inexistent power save mode"/>
+    </enum>
+
+    <request name="set_mode">
+      <description summary="Set an outputs power save mode">
+        Set an output's power save mode to the given mode. The mode change
+        is effective immediately. If the output does not support the given
+        mode a failed event is sent.
+      </description>
+      <arg name="mode" type="uint" enum="mode" summary="the power save mode to set"/>
+    </request>
+
+    <event name="mode">
+      <description summary="Report a power management mode change">
+        Report the power management mode change of an output.
+
+        The mode event is sent after an output changed its power
+        management mode. The reason can be a client using set_mode or the
+        compositor deciding to change an output's mode.
+        This event is also sent immediately when the object is created
+        so the client is informed about the current power management mode.
+      </description>
+      <arg name="mode" type="uint" enum="mode"
+           summary="the output's new power management mode"/>
+    </event>
+
+    <event name="failed">
+      <description summary="object no longer valid">
+        This event indicates that the output power management mode control
+        is no longer valid. This can happen for a number of reasons,
+        including:
+        - The output doesn't support power management
+        - Another client already has exclusive power management mode control
+          for this output
+        - The output disappeared
+
+        Upon receiving this event, the client should destroy this object.
+      </description>
+    </event>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy this power management">
+        Destroys the output power management mode control object.
+      </description>
+    </request>
+  </interface>
+</protocol>
