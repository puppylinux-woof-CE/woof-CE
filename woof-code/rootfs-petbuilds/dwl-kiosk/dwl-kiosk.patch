From 3d971851293806c7a1d5d2cec4d62c307beb83cc Mon Sep 17 00:00:00 2001
From: Dima Krasner <dima@dimakrasner.com>
Date: Mon, 18 Jul 2022 11:11:09 +0300
Subject: [PATCH] Squashed commit of the following:

commit 65bfc29fe86fdbc8c3ca918d8eca67580bf27d97
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Jul 18 09:42:17 2022 +0300

    drop -f

commit 8f5b29de4c072d2430f1e4a1546e19d49e889b51
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sun Jul 17 08:35:20 2022 +0300

    allow environment variables to override colors

commit c4326e93667066e9a2b3a0600cc384e048db68b5
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Jul 16 17:27:25 2022 +0300

    cleanup

commit 353e8bde2d17927e91f502e6d52c0dfc864ebeb1
Merge: 6d47464 e98719f
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Jul 16 17:23:00 2022 +0300

    Merge branch 'main' of https://github.com/djpohly/dwl into dwl-kiosk

commit 6d4746436323a9f010ee604d5e7357b92ac53a0a
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Jul 16 17:22:43 2022 +0300

    drop wlr-foreign-toplevel-management support

commit 4f0481741de33416322602143002e7771a93293a
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Jul 16 17:07:59 2022 +0300

    center floating windows in all layouts

commit b8488274efcc6d24ec245fe17b98b82b0df00f5f
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Jul 11 20:12:58 2022 +0300

    mark windows in hidden tags as inactive

commit 4123781fd06583a20fc78401688667cb99b3f467
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu Jul 7 09:10:27 2022 +0300

    fix breakage

commit bb676eb810acc191d9bd057aed9e75066ccfd04a
Merge: 91c509f 87fc3a5
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu Jul 7 08:40:55 2022 +0300

    Merge branch 'main' of https://github.com/djpohly/dwl into dwl-kiosk

commit 91c509f9772c50116e33e2fbaa45e1d57948aeae
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Jul 2 08:04:07 2022 +0000

    fix breakage

commit 2ffb24e36340f911efaea706b73ca1c35f62a5c3
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Jul 2 07:39:34 2022 +0000

    allow Xwayland to be disabled without specifying GDK_BACKEND

commit e2c896ffd6e6f53cae5f09a860a24af4dc81bddd
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Jul 1 07:08:30 2022 +0000

    enable key bindings on windows other than the kiosk window

commit 4446ba5a1b69dccf55aedaa6c029d95613491a27
Merge: 6251c97 7cc6c64
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Jul 1 06:50:45 2022 +0000

    Merge branch 'main' of https://github.com/djpohly/dwl into dwl-kiosk

commit 6251c97242209b919c2fe0932de6a836d6eb7c8e
Merge: 0c728e1 72e0a56
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sun Jun 26 06:58:10 2022 +0000

    Merge branch 'main' of https://github.com/djpohly/dwl into dwl-kiosk

commit 0c728e1ca5575793b416db6894226c7e3808fe2e
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Wed Jun 22 20:11:51 2022 +0000

    add a function for Alt-Tab

commit f2cd033f17c8d141739917b55ed85c4e0e4be83d
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Jun 18 11:47:57 2022 +0000

    fix segfault if window has no title

commit f0509ea8acfab1047a9e7606897a6f195537e4c6
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Jun 17 06:26:34 2022 +0000

    center the cursor on startup

commit d41059b80d9f1ec56d99fb3618d7ba76d2055e0c
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu Jun 16 18:01:56 2022 +0000

    float maximized windows

commit 7fbc4c95cf22f878c3edbe1f0c726a692e8e51cf
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu Jun 16 15:38:34 2022 +0000

    add functions maximize/minimize key bindings

commit 3101ec921d0703e59bb227bc11ff74673c84a640
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu Jun 16 15:12:47 2022 +0000

    disable key bindings in kiosk mode

commit 543b1757ac8f17c0a76a17c52d7003c9ec0ef760
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Wed Jun 15 06:03:03 2022 +0000

    deactivate other windows when focusing a window

commit 4d747e7ecac220b0b4a4a11c9b56bbb05ddd4f57
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Tue Jun 14 17:43:05 2022 +0000

    activate floating windows

commit f3284d7756c20b41b24df4f9fc0eca351a135183
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Tue Jun 14 16:42:18 2022 +0000

    add missing wlr-foreign-toplevel-management updates

commit 2c954a088cae74edff39712bc3ab4ed20fa57e63
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Tue Jun 14 15:55:30 2022 +0000

    tile minimized windows

commit cd81a991259b9f26f9834a7d16143e634bc353c7
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Jun 13 17:16:31 2022 +0000

    float by default when -f is specified

commit e91dde6ea85f9433dc867b63c75a418571679d8c
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Jun 13 17:02:10 2022 +0000

    center floating windows within the usable area

commit 4f0f369295fce6c64f5c0bdb8b748232b3085b0c
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Jun 13 16:49:55 2022 +0000

    respect the usable area when maximizing

commit 7a1b8207e6eb7f454a62cf377d53854a4dfa4122
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Jun 13 16:48:20 2022 +0000

    activate kiosk mode using -k

commit f6bdcab9ec029ce1ad1851b91db8101cdbb7b71f
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Jun 13 05:51:08 2022 +0000

    disable Xwayland at runtime if GDK_BACKEND=x11

commit 4701c81d3af1b49075f873ed0a17102ee4399d85
Merge: 128a3b6 583f471
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Jun 10 21:14:39 2022 +0300

    Merge branch 'main' of https://github.com/djpohly/dwl into dwl-kiosk

commit 128a3b6114a254fc12977c8687d9f7bcbf3ae4e8
Merge: 7cf1ac8 d969289
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Jun 10 19:23:41 2022 +0300

    Merge branch 'main' of https://github.com/djpohly/dwl into dwl-kiosk

commit 7cf1ac815850a7e4940dfa9aa23f4baf1810827c
Merge: 9da62b6 4dfa456
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Jun 6 19:02:52 2022 +0300

    Merge branch 'main' into dwl-kiosk

commit 9da62b6c5d5c3a99b2cce4ef827bc2af4d720d08
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Jun 6 19:02:02 2022 +0300

    add basic wlr-foreign-toplevel-management support

commit 93a25e164c9cb6f26393ad2444a0b5cbb0e8d3f9
Merge: 51b10ba 2623a96
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Sat Jun 4 16:58:16 2022 +0800

    Merge branch 'main' of https://github.com/djpohly/dwl into dwl-kiosk

commit 51b10bac51e40b4ba39f208eb1493d37a5b4e186
Merge: 3abcf6e 52e0d00
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Thu May 26 14:03:49 2022 +0800

    Merge branch 'main' of https://github.com/djpohly/dwl into dwl-kiosk

commit 3abcf6e9075428157c2e2cffd7e6df934cd3b299
Merge: 7293f2c da4fd3c
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri May 20 14:28:59 2022 +0800

    Merge branch 'kiosk' of https://github.com/dimkr/dwl

commit 7293f2cc464624e0b9a201958cad88f9446e5e58
Merge: 2dfdd52 12e6a9b
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri May 20 14:28:01 2022 +0800

    Merge branch 'csd' of https://github.com/dimkr/dwl

commit 2dfdd529bce8cfc4047df6d5754547e5be920ca9
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri May 20 14:27:51 2022 +0800

    add support for resizing and moving of floating windows

commit fbf0edbb757274155f3499c1744694d79c31afd2
Merge: 76346dc 395c057
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri May 20 14:17:43 2022 +0800

    Merge branch 'fallback' of https://github.com/dimkr/dwl

commit 76346dcd20637d2edbb5f831130484ce0515190f
Merge: 936b5bd 0718815
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri May 20 14:17:34 2022 +0800

    Merge branch 'right' of https://github.com/dimkr/dwl

commit 936b5bdaaa36d98451d65052a5ca8079449e870c
Merge: 85502b7 a0abd9c
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri May 20 14:16:50 2022 +0800

    Merge branch 'input' of https://github.com/dimkr/dwl

commit 85502b7aec6196732f4e2bdfd802c8c1368f9c61
Merge: d6b0aca cf2000f
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri May 20 14:16:29 2022 +0800

    Merge branch 'output-power-management' of https://github.com/guidocella/dwl

commit d6b0aca985c4836140132d406b593e6f9829e9ff
Merge: 8870ba0 49bd8a8
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri May 20 14:14:27 2022 +0800

    Merge branch 'point' of https://github.com/PalanixYT/dwl

commit 0718815dc585183d642b06dba21d7015cdc94525
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Apr 22 15:59:27 2022 +0800

    extend the display to the right

commit da4fd3cab01010825d90bfd38b90b87bf076d490
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Apr 22 15:47:57 2022 +0800

    maximize the first window and make all others float

commit a0abd9c83d7980c2a807d4a96d58c40126f84590
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Apr 22 15:43:57 2022 +0800

    add support for pointer device configuration using environment variables

commit 395c0578f5248b5919ad7710e2094ae1b89cc7fc
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Apr 22 15:37:08 2022 +0800

    fall back to a lower output mode if needed (swaywm/sway@4cdc4ac)

commit 12e6a9bcf8225465c32ea4472a21cddc10b1cd34
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Fri Apr 22 15:36:28 2022 +0800

    ask clients to draw their own decorations

commit 49bd8a8274d5803c90f0651bf1d9fa16e4f6d4ea
Author: Palanix <palanixyt@gmail.com>
Date:   Sun Mar 20 20:40:49 2022 +0100

    Fix pointerconstraints

    Fix pedantic

commit cf2000f2655de6829020dc0186333ac00e60567e
Author: Dima Krasner <dima@dimakrasner.com>
Date:   Mon Apr 4 01:20:06 2022 +0800

    damage the output after wlopm --on

commit e0f48b3ab478a7e67f00bb42171c311e334ee778
Author: Guido Cella <guido@guidocella.xyz>
Date:   Sun Mar 20 21:19:29 2022 +0100

    Implement the output power management protocol.

    I thought wlr-randr used this, but it doesn't so I don't even know what
    this is for.
---
 Makefile                                      |   8 +-
 config.def.h                                  |  11 +-
 dwl.c                                         | 547 +++++++++++++++++-
 ...lr-output-power-management-unstable-v1.xml | 128 ++++
 4 files changed, 672 insertions(+), 22 deletions(-)
 create mode 100644 protocols/wlr-output-power-management-unstable-v1.xml

diff --git a/Makefile b/Makefile
index 6a8323bf..05d8f9bd 100644
--- a/Makefile
+++ b/Makefile
@@ -23,7 +23,7 @@ LDLIBS    = `pkg-config --libs $(PKGS)` $(LIBS)
 all: dwl
 dwl: dwl.o util.o
 	$(CC) dwl.o util.o $(LDLIBS) $(LDFLAGS) $(DWLCFLAGS) -o $@
-dwl.o: dwl.c config.mk config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h idle-protocol.h
+dwl.o: dwl.c config.mk config.h client.h xdg-shell-protocol.h wlr-layer-shell-unstable-v1-protocol.h idle-protocol.h pointer-constraints-unstable-v1-protocol.h wlr-output-power-management-unstable-v1-protocol.h
 util.o: util.c util.h
 
 # wayland scanner rules to generate .h / .c files
@@ -36,6 +36,12 @@ wlr-layer-shell-unstable-v1-protocol.h:
 idle-protocol.h:
 	$(WAYLAND_SCANNER) server-header \
 		protocols/idle.xml $@
+pointer-constraints-unstable-v1-protocol.h:
+	$(WAYLAND_SCANNER) server-header \
+		$(WAYLAND_PROTOCOLS)/unstable/pointer-constraints/pointer-constraints-unstable-v1.xml $@
+wlr-output-power-management-unstable-v1-protocol.h:
+	$(WAYLAND_SCANNER) server-header \
+		protocols/wlr-output-power-management-unstable-v1.xml $@
 
 config.h:
 	cp config.def.h $@
diff --git a/config.def.h b/config.def.h
index 43f35cd4..85adc160 100644
--- a/config.def.h
+++ b/config.def.h
@@ -1,10 +1,13 @@
 /* appearance */
 static const int sloppyfocus        = 1;  /* focus follows mouse */
-static const unsigned int borderpx  = 1;  /* border pixel of windows */
+static unsigned int borderpx  = 1;  /* border pixel of windows */
 static const int lockfullscreen     = 1;  /* 1 will force focus on the fullscreen window */
-static const float rootcolor[]      = {0.3, 0.3, 0.3, 1.0};
-static const float bordercolor[]    = {0.5, 0.5, 0.5, 1.0};
-static const float focuscolor[]     = {1.0, 0.0, 0.0, 1.0};
+static float rootcolor[]      = {0.3, 0.3, 0.3, 1.0};
+static float bordercolor[]    = {0.5, 0.5, 0.5, 1.0};
+static float focuscolor[]     = {1.0, 0.0, 0.0, 1.0};
+
+/* pointer constraints */
+static const int allow_constrain      = 1;
 
 /* tagging */
 static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
diff --git a/dwl.c b/dwl.c
index 0c806917..16b3f86f 100644
--- a/dwl.c
+++ b/dwl.c
@@ -2,6 +2,7 @@
  * See LICENSE file for copyright and license details.
  */
 #define _POSIX_C_SOURCE 200809L
+#include <assert.h>
 #include <getopt.h>
 #include <libinput.h>
 #include <limits.h>
@@ -30,12 +31,16 @@
 #include <wlr/types/wlr_keyboard.h>
 #include <wlr/types/wlr_layer_shell_v1.h>
 #include <wlr/types/wlr_output.h>
+#include <wlr/interfaces/wlr_output.h>
 #include <wlr/types/wlr_output_layout.h>
 #include <wlr/types/wlr_output_management_v1.h>
+#include <wlr/types/wlr_output_power_management_v1.h>
 #include <wlr/types/wlr_pointer.h>
 #include <wlr/types/wlr_presentation_time.h>
+#include <wlr/types/wlr_pointer_constraints_v1.h>
 #include <wlr/types/wlr_primary_selection.h>
 #include <wlr/types/wlr_primary_selection_v1.h>
+#include <wlr/types/wlr_relative_pointer_v1.h>
 #include <wlr/types/wlr_scene.h>
 #include <wlr/types/wlr_screencopy_v1.h>
 #include <wlr/types/wlr_seat.h>
@@ -110,6 +115,10 @@ typedef struct {
 	struct wl_listener destroy;
 	struct wl_listener set_title;
 	struct wl_listener fullscreen;
+	struct wl_listener request_move;
+	struct wl_listener request_resize;
+	struct wl_listener request_maximize;
+	struct wl_listener request_minimize;
 	struct wlr_box prev;  /* layout-relative, includes border */
 #ifdef XWAYLAND
 	struct wl_listener activate;
@@ -120,7 +129,9 @@ typedef struct {
 	unsigned int tags;
 	int isfloating, isurgent;
 	uint32_t resize; /* configure serial of a pending resize */
+	int allmons;
 	int isfullscreen;
+	int ismaximized;
 } Client;
 
 typedef struct {
@@ -195,6 +206,14 @@ typedef struct {
 	enum wl_output_transform rr;
 } MonitorRule;
 
+struct pointer_constraint {
+	struct wlr_pointer_constraint_v1 *constraint;
+
+	struct wl_listener set_region;
+	struct wl_listener destroy;
+};
+
+
 typedef struct {
 	const char *id;
 	const char *title;
@@ -208,6 +227,7 @@ static void applybounds(Client *c, struct wlr_box *bbox);
 static void applyexclusive(struct wlr_box *usable_area, uint32_t anchor,
 		int32_t exclusive, int32_t margin_top, int32_t margin_right,
 		int32_t margin_bottom, int32_t margin_left);
+static void center(Client *c, const struct wlr_box *box);
 static void applyrules(Client *c);
 static void arrange(Monitor *m);
 static void arrangelayer(Monitor *m, struct wl_list *list,
@@ -228,10 +248,12 @@ static void createlayersurface(struct wl_listener *listener, void *data);
 static void createmon(struct wl_listener *listener, void *data);
 static void createnotify(struct wl_listener *listener, void *data);
 static void createpointer(struct wlr_input_device *device);
+static void createpointerconstraint(struct wl_listener *listener, void *data);
 static void cursorframe(struct wl_listener *listener, void *data);
 static void destroyidleinhibitor(struct wl_listener *listener, void *data);
 static void destroylayersurfacenotify(struct wl_listener *listener, void *data);
 static void destroynotify(struct wl_listener *listener, void *data);
+static void destroypointerconstraint(struct wl_listener *listener, void *data);
 static Monitor *dirtomon(enum wlr_direction dir);
 static void dragicondestroy(struct wl_listener *listener, void *data);
 static void focusclient(Client *c, int lift);
@@ -239,12 +261,14 @@ static void focusmon(const Arg *arg);
 static void focusstack(const Arg *arg);
 static Client *focustop(Monitor *m);
 static void fullscreennotify(struct wl_listener *listener, void *data);
+static void handleconstraintcommit(struct wl_listener *listener, void *data);
 static void incnmaster(const Arg *arg);
 static void inputdevice(struct wl_listener *listener, void *data);
-static int keybinding(uint32_t mods, xkb_keysym_t sym);
+static int keybinding(uint32_t mods, xkb_keysym_t sym, Client *);
 static void keypress(struct wl_listener *listener, void *data);
 static void keypressmod(struct wl_listener *listener, void *data);
 static void killclient(const Arg *arg);
+static void loadtheme(void);
 static void maplayersurfacenotify(struct wl_listener *listener, void *data);
 static void mapnotify(struct wl_listener *listener, void *data);
 static void monocle(Monitor *m);
@@ -252,12 +276,15 @@ static void motionabsolute(struct wl_listener *listener, void *data);
 static void motionnotify(uint32_t time);
 static void motionrelative(struct wl_listener *listener, void *data);
 static void moveresize(const Arg *arg);
+static void nextstacked(const Arg *arg);
 static void outputmgrapply(struct wl_listener *listener, void *data);
 static void outputmgrapplyortest(struct wlr_output_configuration_v1 *config, int test);
 static void outputmgrtest(struct wl_listener *listener, void *data);
+static void parsecolor(const char *val, float color[4]);
 static void pointerfocus(Client *c, struct wlr_surface *surface,
 		double sx, double sy, uint32_t time);
 static void printstatus(void);
+static void powermgrsetmodenotify(struct wl_listener *listener, void *data);
 static void quit(const Arg *arg);
 static void quitsignal(int signo);
 static void rendermon(struct wl_listener *listener, void *data);
@@ -269,6 +296,7 @@ static void setcursor(struct wl_listener *listener, void *data);
 static void setfloating(Client *c, int floating);
 static void setfullscreen(Client *c, int fullscreen);
 static void setlayout(const Arg *arg);
+static void setmaximized(Client *c, int maximized);
 static void setmfact(const Arg *arg);
 static void setmon(Client *c, Monitor *m, unsigned int newtags);
 static void setpsel(struct wl_listener *listener, void *data);
@@ -277,11 +305,17 @@ static void setup(void);
 static void sigchld(int unused);
 static void spawn(const Arg *arg);
 static void startdrag(struct wl_listener *listener, void *data);
+static void startmove(struct wl_listener *listener, void *data);
+static void startresize(struct wl_listener *listener, void *data);
 static void tag(const Arg *arg);
 static void tagmon(const Arg *arg);
 static void tile(Monitor *m);
 static void togglefloating(const Arg *arg);
 static void togglefullscreen(const Arg *arg);
+static void togglemaximize(struct wl_listener *listener, void *data);
+static void togglemaximizesel(const Arg *arg);
+static void toggleminimize(struct wl_listener *listener, void *data);
+static void toggleminimizesel(const Arg *arg);
 static void toggletag(const Arg *arg);
 static void toggleview(const Arg *arg);
 static void unmaplayersurfacenotify(struct wl_listener *listener, void *data);
@@ -321,17 +355,27 @@ static struct wlr_virtual_keyboard_manager_v1 *virtual_keyboard_mgr;
 static struct wlr_cursor *cursor;
 static struct wlr_xcursor_manager *cursor_mgr;
 
+static struct wlr_output_power_manager_v1 *power_mgr;
+static struct wl_listener power_mgr_set_mode = {.notify = powermgrsetmodenotify};
+
 static struct wlr_seat *seat;
 static struct wl_list keyboards;
 static unsigned int cursor_mode;
 static Client *grabc;
 static int grabcx, grabcy; /* client-relative */
+static int kiosk = 0;
+static int xwaylandon = 0;
 
 static struct wlr_output_layout *output_layout;
 static struct wlr_box sgeom;
 static struct wl_list mons;
 static Monitor *selmon;
 
+struct wlr_pointer_constraints_v1 *pointer_constraints;
+struct wlr_pointer_constraint_v1 *active_constraint;
+static struct wl_listener constraint_commit;
+struct wlr_relative_pointer_manager_v1 *relative_pointer_manager;
+
 /* global event handlers */
 static struct wl_listener cursor_axis = {.notify = axisnotify};
 static struct wl_listener cursor_button = {.notify = buttonpress};
@@ -345,6 +389,7 @@ static struct wl_listener new_input = {.notify = inputdevice};
 static struct wl_listener new_virtual_keyboard = {.notify = virtualkeyboard};
 static struct wl_listener new_output = {.notify = createmon};
 static struct wl_listener new_xdg_surface = {.notify = createnotify};
+static struct wl_listener pointer_constraint_create = {.notify = createpointerconstraint};
 static struct wl_listener new_layer_shell_surface = {.notify = createlayersurface};
 static struct wl_listener output_mgr_apply = {.notify = outputmgrapply};
 static struct wl_listener output_mgr_test = {.notify = outputmgrtest};
@@ -457,6 +502,24 @@ applyexclusive(struct wlr_box *usable_area,
 	}
 }
 
+void
+center(Client *c, const struct wlr_box *box)
+{
+	c->geom.x = cursor->x - c->geom.width / 2;
+	if (c->geom.x + c->geom.width > box->x + box->width)
+		c->geom.x = box->x + box->width - c->geom.width;
+	if (c->geom.x < box->x || c->geom.width > box->width)
+		c->geom.x = box->x;
+
+	c->geom.y = cursor->y - c->geom.height / 2;
+	if (c->geom.y + c->geom.height > box->y + box->height)
+		c->geom.y = box->y + box->height - c->geom.height;
+	if (c->geom.y < box->y || c->geom.height > box->height)
+		c->geom.y = box->y;
+
+	wlr_scene_node_set_position(c->scene, c->geom.x, c->geom.y);
+}
+
 void
 applyrules(Client *c)
 {
@@ -465,6 +528,7 @@ applyrules(Client *c)
 	unsigned int i, newtags = 0;
 	const Rule *r;
 	Monitor *mon = selmon, *m;
+	Client *oc;
 
 	c->isfloating = client_is_float_type(c);
 	if (!(appid = client_get_appid(c)))
@@ -483,6 +547,22 @@ applyrules(Client *c)
 					mon = m;
 		}
 	}
+
+	if (kiosk) {
+		wl_list_for_each(oc, &clients, link) {
+			if (oc != c) {
+				c->isfloating = 1;
+				goto floating;
+			}
+		}
+		c->isfullscreen = 1;
+		c->allmons = 1;
+	}
+
+floating:
+	if (c->isfloating)
+		center(c, &mon->w);
+
 	wlr_scene_node_reparent(c->scene, layers[c->isfloating ? LyrFloat : LyrTile]);
 	setmon(c, mon, newtags);
 }
@@ -650,12 +730,11 @@ buttonpress(struct wl_listener *listener, void *data)
 		/* Don't focus unmanaged clients */
 		if (c && !client_is_unmanaged(c))
 			focusclient(c, 1);
-
 		keyboard = wlr_seat_get_keyboard(seat);
 		mods = keyboard ? wlr_keyboard_get_modifiers(keyboard) : 0;
 		for (b = buttons; b < END(buttons); b++) {
 			if (CLEANMASK(mods) == CLEANMASK(b->mod) &&
-					event->button == b->button && b->func) {
+					event->button == b->button && b->func && (!kiosk || !c || !c->allmons || client_is_unmanaged(c))) {
 				b->func(&b->arg);
 				return;
 			}
@@ -889,8 +968,10 @@ createmon(struct wl_listener *listener, void *data)
 	/* This event is raised by the backend when a new output (aka a display or
 	 * monitor) becomes available. */
 	struct wlr_output *wlr_output = data;
+	struct wlr_output_mode *preferred_mode, *mode;
 	const MonitorRule *r;
-	Monitor *m = wlr_output->data = ecalloc(1, sizeof(*m));
+	int max_x = 0, max_x_y = 0, width, height;
+	Monitor *om, *m = wlr_output->data = ecalloc(1, sizeof(*m));
 	m->wlr_output = wlr_output;
 
 	wlr_output_init_render(wlr_output, alloc, drw);
@@ -915,7 +996,17 @@ createmon(struct wl_listener *listener, void *data)
 	 * monitor supports only a specific set of modes. We just pick the
 	 * monitor's preferred mode; a more sophisticated compositor would let
 	 * the user configure it. */
-	wlr_output_set_mode(wlr_output, wlr_output_preferred_mode(wlr_output));
+	preferred_mode = wlr_output_preferred_mode(wlr_output);
+	wlr_output_set_mode(wlr_output, preferred_mode);
+	if (!wlr_output_test(wlr_output) && !wl_list_empty(&wlr_output->modes)) {
+		wl_list_for_each(mode, &wlr_output->modes, link) {
+			if (mode != preferred_mode) {
+				wlr_output_set_mode(wlr_output, mode);
+				if (wlr_output_test(wlr_output))
+					break;
+			}
+		}
+	}
 	wlr_output_enable_adaptive_sync(wlr_output, 1);
 
 	/* Set up event listeners */
@@ -926,6 +1017,14 @@ createmon(struct wl_listener *listener, void *data)
 	if (!wlr_output_commit(wlr_output))
 		return;
 
+	wl_list_for_each(om, &mons, link) {
+		wlr_output_effective_resolution(om->wlr_output, &width, &height);
+		if (om->m.x + width > max_x) {
+			max_x = om->m.x + width;
+			max_x_y = om->m.y;
+		}
+	}
+
 	wl_list_insert(&mons, &m->link);
 	printstatus();
 
@@ -936,7 +1035,7 @@ createmon(struct wl_listener *listener, void *data)
 	 * output (such as DPI, scale factor, manufacturer, etc).
 	 */
 	m->scene_output = wlr_scene_output_create(scene, wlr_output);
-	wlr_output_layout_add_auto(output_layout, wlr_output);
+	wlr_output_layout_add(output_layout, wlr_output, max_x, max_x_y);
 
 	/* If length == 1 we need update selmon.
 	 * Maybe it will change in run(). */
@@ -949,6 +1048,28 @@ createmon(struct wl_listener *listener, void *data)
 	}
 }
 
+void
+createpointerconstraint(struct wl_listener *listener, void *data)
+{
+	struct wlr_pointer_constraint_v1 *constraint = data;
+	struct pointer_constraint *pointer_constraint = calloc(1, sizeof(struct pointer_constraint));
+	pointer_constraint->constraint = constraint;
+	
+	pointer_constraint->destroy.notify = destroypointerconstraint;
+	wl_signal_add(&constraint->events.destroy, &pointer_constraint->destroy);
+	
+	if (client_surface(selclient()) == constraint->surface) {
+		if (allow_constrain == 0 || active_constraint == constraint)
+			return;
+
+		active_constraint = constraint;
+		wlr_pointer_constraint_v1_send_activated(constraint);
+
+		constraint_commit.notify = handleconstraintcommit;
+		wl_signal_add(&constraint->surface->events.commit, &constraint_commit);
+	}
+}
+
 void
 createnotify(struct wl_listener *listener, void *data)
 {
@@ -990,6 +1111,183 @@ createnotify(struct wl_listener *listener, void *data)
 	LISTEN(&xdg_surface->toplevel->events.set_title, &c->set_title, updatetitle);
 	LISTEN(&xdg_surface->toplevel->events.request_fullscreen, &c->fullscreen,
 			fullscreennotify);
+	LISTEN(&xdg_surface->toplevel->events.request_move, &c->request_move,
+			startmove);
+	LISTEN(&xdg_surface->toplevel->events.request_resize, &c->request_resize,
+			startresize);
+	LISTEN(&xdg_surface->toplevel->events.request_maximize, &c->request_maximize,
+			togglemaximize);
+	LISTEN(&xdg_surface->toplevel->events.request_minimize, &c->request_minimize,
+			toggleminimize);
+}
+
+static int
+isenabled(const char *val, int def)
+{
+	return ((def && (!val || !val[0] || (val[0] != '0'))) || (!def && (val && val[0] && (val[0] != '0'))));
+}
+
+static void
+setclickmethod(struct libinput_device *libinput_device)
+{
+	const char *val;
+	long l;
+	char *end = NULL;
+	enum libinput_config_click_method method = LIBINPUT_CONFIG_CLICK_METHOD_NONE;
+
+	val = getenv("LIBINPUT_DEFAULT_CLICK_METHOD");
+	if (!val || !val[0])
+		return;
+
+	errno = 0;
+	l = strtol(val, &end, 10);
+	if (errno || (end && *end))
+		return;
+
+	libinput_device_config_click_set_method(libinput_device,
+		(enum libinput_config_click_method)l);
+}
+
+static void
+settap(struct libinput_device *libinput_device)
+{
+	const char *val;
+	enum libinput_config_tap_state state = LIBINPUT_CONFIG_TAP_DISABLED;
+
+	val = getenv("LIBINPUT_DEFAULT_TAP");
+	if (val) {
+		if (!val[0])
+			return;
+
+		libinput_device_config_tap_set_enabled(libinput_device,
+			isenabled(val, 1) ? LIBINPUT_CONFIG_TAP_ENABLED :
+				LIBINPUT_CONFIG_TAP_DISABLED);
+	} else if (tap_to_click && libinput_device_config_tap_get_finger_count(libinput_device))
+		libinput_device_config_tap_set_enabled(libinput_device,
+			LIBINPUT_CONFIG_TAP_ENABLED);
+}
+
+static void
+settapanddrag(struct libinput_device *libinput_device)
+{
+	const char *val;
+
+	val = getenv("LIBINPUT_DEFAULT_DRAG");
+	if (val && val[0])
+		libinput_device_config_tap_set_drag_enabled(libinput_device,
+			isenabled(val, 1) ? LIBINPUT_CONFIG_DRAG_ENABLED :
+				LIBINPUT_CONFIG_DRAG_DISABLED);
+}
+
+static void
+setnaturalscroll(struct libinput_device *libinput_device)
+{
+	const char *val;
+	enum libinput_config_status status;
+
+	val = getenv("LIBINPUT_DEFAULT_NATURAL_SCROLL");
+	if (val && val[0])
+		libinput_device_config_scroll_set_natural_scroll_enabled(
+			libinput_device, isenabled(val, 0));
+	else if (!val && libinput_device_config_scroll_has_natural_scroll(libinput_device))
+		libinput_device_config_scroll_set_natural_scroll_enabled(
+			libinput_device, natural_scrolling);
+}
+
+static void
+setaccelprofile(struct libinput_device *libinput_device)
+{
+	const char *val;
+	double profile;
+	char *end = NULL;
+	enum libinput_config_status status;
+
+	val = getenv("LIBINPUT_DEFAULT_ACCELERATION_PROFILE");
+	if (!val || !val[0])
+		return;
+
+	errno = 0;
+	profile = strtod(val, &end);
+	if (errno || (end && *end))
+		return;
+
+	libinput_device_config_accel_set_profile(libinput_device,
+		(enum libinput_config_accel_profile)profile);
+}
+
+static void
+setaccelspeed(struct libinput_device *libinput_device)
+{
+	const char *val;
+	double accel = 0;
+	char *end = NULL;
+
+	val = getenv("LIBINPUT_DEFAULT_ACCELERATION");
+	if (!val || !val[0])
+		return;
+
+	errno = 0;
+	accel = strtod(val, &end);
+	if (errno || (end && *end) || (accel < -1) || (accel > 1))
+		return;
+
+	libinput_device_config_accel_set_speed(libinput_device, accel);
+}
+
+static void
+setscrollmethod(struct libinput_device *libinput_device)
+{
+	const char *val;
+	long l;
+	char *end = NULL;
+	enum libinput_config_status status;
+
+	val = getenv("LIBINPUT_DEFAULT_SCROLL_METHOD");
+	if (!val || !val[0])
+		return;
+
+	errno = 0;
+	l = strtol(val, &end, 10);
+	if (errno || (end && *end))
+		return;
+
+	libinput_device_config_scroll_set_method(libinput_device,
+		(enum libinput_config_scroll_method)l);
+}
+
+static void
+setdwt(struct libinput_device *libinput_device)
+{
+	const char *val;
+
+	val = getenv("LIBINPUT_DEFAULT_DISABLE_WHILE_TYPING");
+	if (val && val[0])
+		libinput_device_config_dwt_set_enabled(libinput_device,
+			isenabled(val, false) ? LIBINPUT_CONFIG_DWT_ENABLED :
+				LIBINPUT_CONFIG_DWT_DISABLED);
+}
+
+static void
+setmiddleemul(struct libinput_device *libinput_device)
+{
+	const char *val;
+
+	val = getenv("LIBINPUT_DEFAULT_MIDDLE_EMULATION");
+	if (val && val[0])
+		libinput_device_config_middle_emulation_set_enabled(libinput_device,
+			isenabled(val, false) ? LIBINPUT_CONFIG_MIDDLE_EMULATION_ENABLED :
+				LIBINPUT_CONFIG_MIDDLE_EMULATION_DISABLED);
+}
+
+static void
+setlefthanded(struct libinput_device *libinput_device)
+{
+	const char *val;
+
+	val = getenv("LIBINPUT_DEFAULT_LEFT_HANDED");
+	if (val && val[0])
+		libinput_device_config_left_handed_set(libinput_device,
+			isenabled(val, 0));
 }
 
 void
@@ -999,6 +1297,7 @@ createpointer(struct wlr_input_device *device)
 		struct libinput_device *libinput_device =  (struct libinput_device*)
 			wlr_libinput_get_device_handle(device);
 
+#if 0
 		if (libinput_device_config_tap_get_finger_count(libinput_device)) {
 			libinput_device_config_tap_set_enabled(libinput_device, tap_to_click);
 			libinput_device_config_tap_set_drag_enabled(libinput_device, tap_and_drag);
@@ -1030,11 +1329,42 @@ createpointer(struct wlr_input_device *device)
 			libinput_device_config_accel_set_profile(libinput_device, accel_profile);
 			libinput_device_config_accel_set_speed(libinput_device, accel_speed);
 		}
+#endif
+
+		setclickmethod(libinput_device);
+		settap(libinput_device);
+		settapanddrag(libinput_device);
+		setnaturalscroll(libinput_device);
+		setaccelprofile(libinput_device);
+		setaccelspeed(libinput_device);
+		setscrollmethod(libinput_device);
+		setdwt(libinput_device);
+		setmiddleemul(libinput_device);
+		setlefthanded(libinput_device);
 	}
 
 	wlr_cursor_attach_input_device(cursor, device);
 }
 
+void
+destroypointerconstraint(struct wl_listener *listener, void *data)
+{
+	struct wlr_pointer_constraint_v1 *constraint = data;
+	struct pointer_constraint *pointer_constraint = wl_container_of(listener, pointer_constraint, destroy);
+
+	wl_list_remove(&pointer_constraint->destroy.link);
+
+	if (active_constraint == constraint) {
+		if (constraint_commit.link.next != NULL) {
+			wl_list_remove(&constraint_commit.link);
+		}
+		wl_list_init(&constraint_commit.link);
+		active_constraint = NULL;
+	}
+
+	free(pointer_constraint);
+}
+
 void
 cursorframe(struct wl_listener *listener, void *data)
 {
@@ -1083,6 +1413,10 @@ destroynotify(struct wl_listener *listener, void *data)
 	wl_list_remove(&c->destroy.link);
 	wl_list_remove(&c->set_title.link);
 	wl_list_remove(&c->fullscreen.link);
+	wl_list_remove(&c->request_move.link);
+	wl_list_remove(&c->request_resize.link);
+	wl_list_remove(&c->request_maximize.link);
+	wl_list_remove(&c->request_minimize.link);
 #ifdef XWAYLAND
 	if (c->type != XDGShell) {
 		wl_list_remove(&c->configure.link);
@@ -1120,12 +1454,13 @@ dragicondestroy(struct wl_listener *listener, void *data)
 void
 focusclient(Client *c, int lift)
 {
+	Client *other;
 	struct wlr_surface *old = seat->keyboard_state.focused_surface;
 	struct wlr_keyboard *kb;
 	int i;
 
 	/* Raise client in stacking order if requested */
-	if (c && lift)
+	if (c && lift && (!kiosk || c->isfloating))
 		wlr_scene_node_raise_to_top(c->scene);
 
 	if (c && client_surface(c) == old)
@@ -1247,6 +1582,12 @@ fullscreennotify(struct wl_listener *listener, void *data)
 	setfullscreen(c, fullscreen);
 }
 
+void
+handleconstraintcommit(struct wl_listener *listener, void *data)
+{
+	assert(active_constraint->surface == data);
+}
+
 void
 incnmaster(const Arg *arg)
 {
@@ -1285,7 +1626,7 @@ inputdevice(struct wl_listener *listener, void *data)
 }
 
 int
-keybinding(uint32_t mods, xkb_keysym_t sym)
+keybinding(uint32_t mods, xkb_keysym_t sym, Client *sel)
 {
 	/*
 	 * Here we handle compositor keybindings. This is when the compositor is
@@ -1296,7 +1637,7 @@ keybinding(uint32_t mods, xkb_keysym_t sym)
 	const Key *k;
 	for (k = keys; k < END(keys); k++) {
 		if (CLEANMASK(mods) == CLEANMASK(k->mod) &&
-				sym == k->keysym && k->func) {
+				sym == k->keysym && k->func && (!kiosk || !sel || !sel->allmons || client_is_unmanaged(sel) || k->func == chvt)) {
 			k->func(&k->arg);
 			handled = 1;
 		}
@@ -1307,6 +1648,7 @@ keybinding(uint32_t mods, xkb_keysym_t sym)
 void
 keypress(struct wl_listener *listener, void *data)
 {
+	Client *sel = selclient();
 	int i;
 	/* This event is raised when a key is pressed or released. */
 	Keyboard *kb = wl_container_of(listener, kb, key);
@@ -1329,7 +1671,7 @@ keypress(struct wl_listener *listener, void *data)
 	if (!input_inhibit_mgr->active_inhibitor
 			&& event->state == WL_KEYBOARD_KEY_STATE_PRESSED)
 		for (i = 0; i < nsyms; i++)
-			handled = keybinding(mods, syms[i]) || handled;
+			handled = keybinding(mods, syms[i], sel) || handled;
 
 	if (!handled) {
 		/* Pass unhandled keycodes along to the client. */
@@ -1365,6 +1707,29 @@ killclient(const Arg *arg)
 		client_send_close(sel);
 }
 
+void
+loadtheme(void)
+{
+	const char *val;
+	unsigned int tmp;
+
+	val = getenv("DWL_ROOT_COLOR");
+	if (val)
+		parsecolor(val, rootcolor);
+
+	val = getenv("DWL_BORDER_COLOR");
+	if (val)
+		parsecolor(val, bordercolor);
+
+	val = getenv("DWL_FOCUS_COLOR");
+	if (val)
+		parsecolor(val, focuscolor);
+
+	val = getenv("DWL_BORDER");
+	if (val && sscanf(val, "%u", &tmp) == 1)
+		borderpx = tmp;
+}
+
 void
 maplayersurfacenotify(struct wl_listener *listener, void *data)
 {
@@ -1413,7 +1778,6 @@ mapnotify(struct wl_listener *listener, void *data)
 	}
 
 	/* Initialize client geometry with room for border */
-	client_set_tiled(c, WLR_EDGE_TOP | WLR_EDGE_BOTTOM | WLR_EDGE_LEFT | WLR_EDGE_RIGHT);
 	client_get_geometry(c, &c->geom);
 	c->geom.width += 2 * c->bw;
 	c->geom.height += 2 * c->bw;
@@ -1428,6 +1792,8 @@ mapnotify(struct wl_listener *listener, void *data)
 
 	if (c->isfullscreen)
 		setfullscreen(c, 1);
+	if (!c->isfloating)
+		client_set_tiled(c, WLR_EDGE_TOP | WLR_EDGE_BOTTOM | WLR_EDGE_LEFT | WLR_EDGE_RIGHT);
 
 	c->mon->un_map = 1;
 }
@@ -1514,7 +1880,15 @@ motionrelative(struct wl_listener *listener, void *data)
 	 * special configuration applied for the specific input device which
 	 * generated the event. You can pass NULL for the device if you want to move
 	 * the cursor around without any input. */
-	wlr_cursor_move(cursor, event->device, event->delta_x, event->delta_y);
+	wlr_relative_pointer_manager_v1_send_relative_motion(
+		relative_pointer_manager,
+		seat, (uint64_t)event->time_msec * 1000,
+		event->delta_x, event->delta_y, event->unaccel_dx, event->unaccel_dy);
+
+	if (!active_constraint) {
+		wlr_cursor_move(cursor, event->device,
+			event->delta_x, event->delta_y);
+	}
 	motionnotify(event->time_msec);
 }
 
@@ -1529,6 +1903,8 @@ moveresize(const Arg *arg)
 
 	/* Float the window and tell motionnotify to grab it */
 	setfloating(grabc, 1);
+	if (grabc->ismaximized)
+		setmaximized(grabc, 0);
 	switch (cursor_mode = arg->ui) {
 	case CurMove:
 		grabcx = cursor->x - grabc->geom.x;
@@ -1547,6 +1923,17 @@ moveresize(const Arg *arg)
 	}
 }
 
+void nextstacked(const Arg *arg)
+{
+	Client *c, *next;
+	c = selclient();
+	if (!c)
+		return;
+	next = wl_container_of(c->flink.next, next, flink);
+	if (&next->flink != &fstack)
+		focusclient(next, 1);
+}
+
 void
 outputmgrapply(struct wl_listener *listener, void *data)
 {
@@ -1608,6 +1995,18 @@ outputmgrtest(struct wl_listener *listener, void *data)
 	outputmgrapplyortest(config, 1);
 }
 
+void
+parsecolor(const char *val, float color[4])
+{
+	uint8_t r, g, b;
+	if (sscanf(val, "#%02hhx%02hhx%02hhx", &r, &g, &b) == 3) {
+		color[0] = (float)r / 0xFF;
+		color[1] = (float)g / 0xFF;
+		color[2] = (float)b / 0xFF;
+		color[3] = 0xFF;
+	}
+}
+
 void
 pointerfocus(Client *c, struct wlr_surface *surface, double sx, double sy,
 		uint32_t time)
@@ -1673,6 +2072,16 @@ printstatus(void)
 	fflush(stdout);
 }
 
+void
+powermgrsetmodenotify(struct wl_listener *listener, void *data)
+{
+	struct wlr_output_power_v1_set_mode_event *event = data;
+	wlr_output_enable(event->output, event->mode);
+	if (event->mode)
+		wlr_output_damage_whole(event->output);
+	wlr_output_commit(event->output);
+}
+
 void
 quit(const Arg *arg)
 {
@@ -1797,7 +2206,10 @@ run(char *startup_cmd)
 	 * instead of (0, 0) and then jumping.  still may not be fully
 	 * initialized, as the image/coordinates are not transformed for the
 	 * monitor when displayed here */
-	wlr_cursor_warp_closest(cursor, NULL, cursor->x, cursor->y);
+	if (selmon)
+		wlr_cursor_warp_closest(cursor, NULL, selmon->w.x + selmon->w.width / 2, selmon->w.y + selmon->w.height / 2);
+	else
+		wlr_cursor_warp_closest(cursor, NULL, cursor->x, cursor->y);
 	wlr_xcursor_manager_set_cursor_image(cursor_mgr, "left_ptr", cursor);
 
 	/* Run the Wayland event loop. This does not return until you exit the
@@ -1839,7 +2251,10 @@ void
 setfloating(Client *c, int floating)
 {
 	c->isfloating = floating;
+	client_set_tiled(c, floating ? 0 : WLR_EDGE_TOP | WLR_EDGE_BOTTOM | WLR_EDGE_LEFT | WLR_EDGE_RIGHT);
 	wlr_scene_node_reparent(c->scene, layers[c->isfloating ? LyrFloat : LyrTile]);
+	if (floating)
+		center(c, &c->mon->w);
 	arrange(c->mon);
 	printstatus();
 }
@@ -1847,13 +2262,18 @@ setfloating(Client *c, int floating)
 void
 setfullscreen(Client *c, int fullscreen)
 {
+	struct wlr_box *layout_box;
+
 	c->isfullscreen = fullscreen;
 	c->bw = fullscreen ? 0 : borderpx;
 	client_set_fullscreen(c, fullscreen);
 
 	if (fullscreen) {
 		c->prev = c->geom;
-		resize(c, c->mon->m, 0);
+		if (c->allmons) {
+			layout_box = wlr_output_layout_get_box(output_layout, NULL);
+			resize(c, (struct wlr_box){.x = layout_box->x, .y = layout_box->y, .width = layout_box->width, .height = layout_box->height}, 0);
+		} else resize(c, c->mon->m, 0);
 	} else {
 		/* restore previous size instead of arrange for floating windows since
 		 * client positions are set by the user and cannot be recalculated */
@@ -1875,6 +2295,25 @@ setlayout(const Arg *arg)
 	printstatus();
 }
 
+void
+setmaximized(Client *c, int maximized)
+{
+	if (c->isfullscreen)
+		return;
+	if (!c->isfloating)
+		setfloating(c, 1);
+
+	c->ismaximized = maximized;
+
+	if (maximized) {
+		c->prev = c->geom;
+		resize(c, (struct wlr_box){.x = c->mon->w.x, .y = c->mon->w.y, .width = c->mon->w.width, .height = c->mon->w.height}, 0);
+	} else
+		resize(c, (struct wlr_box){.x = c->prev.x, .y = c->prev.y, .width = c->prev.width, .height = c->prev.height}, 0);
+	arrange(c->mon);
+	printstatus();
+}
+
 /* arg > 1.0 will set mfact absolutely */
 void
 setmfact(const Arg *arg)
@@ -1997,6 +2436,9 @@ setup(void)
 	activation = wlr_xdg_activation_v1_create(dpy);
 	wl_signal_add(&activation->events.request_activate, &request_activate);
 
+	power_mgr = wlr_output_power_manager_v1_create(dpy);
+	wl_signal_add(&power_mgr->events.set_mode, &power_mgr_set_mode);
+
 	/* Creates an output layout, which a wlroots utility for working with an
 	 * arrangement of screens in a physical layout. */
 	output_layout = wlr_output_layout_create();
@@ -2033,9 +2475,14 @@ setup(void)
 	/* Use decoration protocols to negotiate server-side decorations */
 	wlr_server_decoration_manager_set_default_mode(
 			wlr_server_decoration_manager_create(dpy),
-			WLR_SERVER_DECORATION_MANAGER_MODE_SERVER);
+			WLR_SERVER_DECORATION_MANAGER_MODE_CLIENT);
 	wlr_xdg_decoration_manager_v1_create(dpy);
 
+	pointer_constraints = wlr_pointer_constraints_v1_create(dpy);
+	wl_signal_add(&pointer_constraints->events.new_constraint, &pointer_constraint_create);
+	
+	relative_pointer_manager = wlr_relative_pointer_manager_v1_create(dpy);
+
 	/*
 	 * Creates a cursor, which is a wlroots utility for tracking the cursor
 	 * image shown on screen.
@@ -2092,6 +2539,10 @@ setup(void)
 	wlr_scene_set_presentation(scene, wlr_presentation_create(dpy, backend));
 
 #ifdef XWAYLAND
+	if (!xwaylandon) {
+		return;
+	}
+
 	/*
 	 * Initialise the XWayland X server.
 	 * It will be started when the first X client is started.
@@ -2148,6 +2599,22 @@ startdrag(struct wl_listener *listener, void *data)
 	wl_signal_add(&drag->icon->events.destroy, &drag_icon_destroy);
 }
 
+void
+startmove(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, request_move);
+
+	moveresize(&(Arg){.ui = CurMove});
+}
+
+void
+startresize(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, request_resize);
+
+	moveresize(&(Arg){.ui = CurResize});
+}
+
 void
 tag(const Arg *arg)
 {
@@ -2219,6 +2686,38 @@ togglefullscreen(const Arg *arg)
 		setfullscreen(sel, !sel->isfullscreen);
 }
 
+void
+togglemaximize(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, request_maximize);
+
+	setmaximized(c, !c->ismaximized);
+}
+
+void
+togglemaximizesel(const Arg *arg)
+{
+	Client *sel = selclient();
+	if (sel)
+		setmaximized(sel, !sel->ismaximized);
+}
+
+void
+toggleminimize(struct wl_listener *listener, void *data)
+{
+	Client *c = wl_container_of(listener, c, request_minimize);
+
+	setfloating(c, !c->isfloating);
+}
+
+void
+toggleminimizesel(const Arg *arg)
+{
+	Client *sel = selclient();
+	if (sel)
+		setfloating(sel, !sel->isfloating);
+}
+
 void
 toggletag(const Arg *arg)
 {
@@ -2328,6 +2827,7 @@ updatemons(struct wl_listener *listener, void *data)
 void
 updatetitle(struct wl_listener *listener, void *data)
 {
+	const char *title;
 	Client *c = wl_container_of(listener, c, set_title);
 	if (c == focustop(c->mon))
 		printstatus();
@@ -2483,6 +2983,14 @@ createnotifyx11(struct wl_listener *listener, void *data)
 	LISTEN(&xwayland_surface->events.destroy, &c->destroy, destroynotify);
 	LISTEN(&xwayland_surface->events.request_fullscreen, &c->fullscreen,
 			fullscreennotify);
+	LISTEN(&xwayland_surface->events.request_move, &c->request_move,
+			startmove);
+	LISTEN(&xwayland_surface->events.request_resize, &c->request_resize,
+			startresize);
+	LISTEN(&xwayland_surface->events.request_maximize, &c->request_maximize,
+			togglemaximize);
+	LISTEN(&xwayland_surface->events.request_minimize, &c->request_minimize,
+			toggleminimize);
 }
 
 Atom
@@ -2546,11 +3054,15 @@ main(int argc, char *argv[])
 	char *startup_cmd = NULL;
 	int c;
 
-	while ((c = getopt(argc, argv, "s:hv")) != -1) {
+	while ((c = getopt(argc, argv, "s:hvkx")) != -1) {
 		if (c == 's')
 			startup_cmd = optarg;
 		else if (c == 'v')
 			die("dwl " VERSION);
+		else if (c == 'k')
+			kiosk = 1;
+		else if (c == 'x')
+			xwaylandon = 1;
 		else
 			goto usage;
 	}
@@ -2560,11 +3072,12 @@ main(int argc, char *argv[])
 	/* Wayland requires XDG_RUNTIME_DIR for creating its communications socket */
 	if (!getenv("XDG_RUNTIME_DIR"))
 		die("XDG_RUNTIME_DIR must be set");
+	loadtheme();
 	setup();
 	run(startup_cmd);
 	cleanup();
 	return EXIT_SUCCESS;
 
 usage:
-	die("Usage: %s [-v] [-s startup command]", argv[0]);
+	die("Usage: %s [-v] [-f] [-k] [-x] [-s startup command]", argv[0]);
 }
diff --git a/protocols/wlr-output-power-management-unstable-v1.xml b/protocols/wlr-output-power-management-unstable-v1.xml
new file mode 100644
index 00000000..a9778399
--- /dev/null
+++ b/protocols/wlr-output-power-management-unstable-v1.xml
@@ -0,0 +1,128 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="wlr_output_power_management_unstable_v1">
+  <copyright>
+    Copyright Â© 2019 Purism SPC
+
+    Permission is hereby granted, free of charge, to any person obtaining a
+    copy of this software and associated documentation files (the "Software"),
+    to deal in the Software without restriction, including without limitation
+    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+    and/or sell copies of the Software, and to permit persons to whom the
+    Software is furnished to do so, subject to the following conditions:
+
+    The above copyright notice and this permission notice (including the next
+    paragraph) shall be included in all copies or substantial portions of the
+    Software.
+
+    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+    DEALINGS IN THE SOFTWARE.
+  </copyright>
+
+  <description summary="Control power management modes of outputs">
+    This protocol allows clients to control power management modes
+    of outputs that are currently part of the compositor space. The
+    intent is to allow special clients like desktop shells to power
+    down outputs when the system is idle.
+
+    To modify outputs not currently part of the compositor space see
+    wlr-output-management.
+
+    Warning! The protocol described in this file is experimental and
+    backward incompatible changes may be made. Backward compatible changes
+    may be added together with the corresponding interface version bump.
+    Backward incompatible changes are done by bumping the version number in
+    the protocol and interface names and resetting the interface version.
+    Once the protocol is to be declared stable, the 'z' prefix and the
+    version number in the protocol and interface names are removed and the
+    interface version number is reset.
+  </description>
+
+  <interface name="zwlr_output_power_manager_v1" version="1">
+    <description summary="manager to create per-output power management">
+      This interface is a manager that allows creating per-output power
+      management mode controls.
+    </description>
+
+    <request name="get_output_power">
+      <description summary="get a power management for an output">
+        Create a output power management mode control that can be used to
+        adjust the power management mode for a given output.
+      </description>
+      <arg name="id" type="new_id" interface="zwlr_output_power_v1"/>
+      <arg name="output" type="object" interface="wl_output"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the manager">
+        All objects created by the manager will still remain valid, until their
+        appropriate destroy request has been called.
+      </description>
+    </request>
+  </interface>
+
+  <interface name="zwlr_output_power_v1" version="1">
+    <description summary="adjust power management mode for an output">
+      This object offers requests to set the power management mode of
+      an output.
+    </description>
+
+    <enum name="mode">
+      <entry name="off" value="0"
+             summary="Output is turned off."/>
+      <entry name="on" value="1"
+             summary="Output is turned on, no power saving"/>
+    </enum>
+
+    <enum name="error">
+      <entry name="invalid_mode" value="1" summary="inexistent power save mode"/>
+    </enum>
+
+    <request name="set_mode">
+      <description summary="Set an outputs power save mode">
+        Set an output's power save mode to the given mode. The mode change
+        is effective immediately. If the output does not support the given
+        mode a failed event is sent.
+      </description>
+      <arg name="mode" type="uint" enum="mode" summary="the power save mode to set"/>
+    </request>
+
+    <event name="mode">
+      <description summary="Report a power management mode change">
+        Report the power management mode change of an output.
+
+        The mode event is sent after an output changed its power
+        management mode. The reason can be a client using set_mode or the
+        compositor deciding to change an output's mode.
+        This event is also sent immediately when the object is created
+        so the client is informed about the current power management mode.
+      </description>
+      <arg name="mode" type="uint" enum="mode"
+           summary="the output's new power management mode"/>
+    </event>
+
+    <event name="failed">
+      <description summary="object no longer valid">
+        This event indicates that the output power management mode control
+        is no longer valid. This can happen for a number of reasons,
+        including:
+        - The output doesn't support power management
+        - Another client already has exclusive power management mode control
+          for this output
+        - The output disappeared
+
+        Upon receiving this event, the client should destroy this object.
+      </description>
+    </event>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy this power management">
+        Destroys the output power management mode control object.
+      </description>
+    </request>
+  </interface>
+</protocol>
