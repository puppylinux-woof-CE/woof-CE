#!/bin/bash
#pMusic
#GPL - Copyright Sigmund Berglund

case "$1" in
-check_playlist)
	FILE="$2"
	case "$FILE" in *pmu) TMP=4;; *pmd) TMP=1;; esac #set field to read
	#check if an update is require
	while read I; do
		case $I in /*) [ ! -f "$I" ] && C=1;; esac
	done <<< "$(cut -d'|' -f$TMP "$FILE")"
	[ "$C" != "1" ] && exit
	#we don't update lists outside the pMusic internal structure (pmd and album-pmu). If user has built his own lists we leave them even if not in shape --> pMusic will anyway search for alternative source when start playing. 
	case $FILE in
		"$STORAGE_DIR"*.pmu)	$APPDIR/func_index -update_pmu "$FILE";;
		*.pmd)					$APPDIR/func_index -update_pmd "$FILE";;
	esac
	;;

-playlist_collapse)
	IFS='|' read COMMAND ARTIST TITLE ALBUM NR YEAR GENRE COMMENT RATING FORMAT BITRATE LENGTH COL13 ADR ICON <<< "$(grep -Fm1 "${2}|" $WORKDIR/sourcelist)"
	[[ $COMMAND != pmusicbrowse_collapse:* ]] && exit
	SOURCELIST_PRE="`grep -B 1000 -F "pmusicbrowse_collapse:$ADR" $WORKDIR/sourcelist | grep -vF "pmusicbrowse_collapse:$ADR"`"
	SOURCELIST_POST="`grep -A 1000 -F "pmusicbrowse_collapse:$ADR" $WORKDIR/sourcelist | grep -vF "pmusicbrowse_collapse:$ADR"`"
	echo "$SOURCELIST_PRE" > $WORKDIR/sourcelist
	if [ "$ALBUM" ]; then #pmusic generated album list
		echo "pmusicbrowse_expand:$ADR|$ARTIST||$ALBUM||$YEAR||||||||$ADR|$ICON||||||" >> $WORKDIR/sourcelist
	else
		find "$ADR" -printf "pmusicbrowse_expand:%p|%f||||$YEAR||||||||%p|$ICON||||||\n" >> $WORKDIR/sourcelist
	fi
	#remove track-lines
	TMP=`grep -m1 -n '___________________________' <<< "$SOURCELIST_POST" | tail -n1`
	echo "$SOURCELIST_POST" | tac | head -n -${TMP%%:*} | tac >> $WORKDIR/sourcelist
	;;

-playlist_expand) #$2=file
	IFS='|' read COMMAND ARTIST TITLE ALBUM NR YEAR GENRE COMMENT RATING FORMAT BITRATE LENGTH COL13 ADR ICON <<< "$(grep -Fm1 "${2}|" $WORKDIR/sourcelist)"
	SOURCELIST_PRE="`grep -B 1000 -F "pmusicbrowse_expand:$ADR" $WORKDIR/sourcelist | grep -vF "pmusicbrowse_expand:$ADR"`"
	SOURCELIST_POST="`grep -A 1000 -F "pmusicbrowse_expand:$ADR" $WORKDIR/sourcelist | grep -vF "pmusicbrowse_expand:$ADR"`"
	echo "$SOURCELIST_PRE" > $WORKDIR/sourcelist
	case $ADR in
		*.pmd)
			$APPDIR/func -check_playlist "$ADR" #check if paths is valid
			find "$ADR" -printf "pmusicbrowse_collapse:%p|%f||||$YEAR||||||||%p|$ICON||||||\n" >> $WORKDIR/sourcelist
			echo -n > $WORKDIR/tmp_playlist_expand
			while read I; do
				IFS='|' read ADR2 ARTIST2 C <<< "${I}"
				[ ! "$ADR2" ] && ADR2="$ARTIST2" #in case no valid file (ie. after an update of favorite lists in the update_index function.) 
				case $I in *jamendo.com*) URL_JAMENDO="`echo "$I" | awk -F 'id=' '{print $2}' | awk -F '|' '{print $1}'`";; esac
				TMP="`grep -Fm1 "$ADR2" "$STORAGE_DIR/index_mymusic"`"
				if [ "$TMP" ]; then
					echo "$TMP" >> $WORKDIR/tmp_playlist_expand
				elif [ "$URL_JAMENDO" ]; then
					TMP="`grep -Fm1 "$URL_JAMENDO" "$STORAGE_DIR/index_webmusic_jamendo"`"
					[ "$TMP" ] && echo "$TMP" >> $WORKDIR/tmp_playlist_expand
				else
					grep -Fm1 "$ADR2" "$ADR" >> $WORKDIR/tmp_playlist_expand
				fi
			done < "$ADR"
			$APPDIR/func_rating -buildlist 1 $WORKDIR/tmp_playlist_expand 0 0 "    " >> $WORKDIR/sourcelist #get rating
			;;
		*.pmu)
			$APPDIR/func -check_playlist "$ADR" #check if paths is valid
			if [ "$ALBUM" ]; then #pmusic generated album list
				echo "pmusicbrowse_collapse:$ADR|$ARTIST||$ALBUM||||$YEAR||||||$ADR|$ICON||||||" >> $WORKDIR/sourcelist
			else
				find "$ADR" -printf "pmusicbrowse_collapse:%p|%f||||$YEAR||||||||%p|$ICON||||||\n" >> $WORKDIR/sourcelist
			fi
			echo -n > $WORKDIR/tmp_playlist_expand
			while read I; do
				IFS='|' read ICON LENGTH NAME ADR ID <<< "$I"
				if [ -s "$ADR" ]; then
					grep -F "$ADR" "$STORAGE_DIR/index_mymusic" >> $WORKDIR/tmp_playlist_expand
				elif [[ "$ADR" = *jamendo.com* ]]; then
						ARTIST=${NAME%\ -\ *}
						TITLE=${NAME#*\ -\ }
						echo "$ADR|$ARTIST|$TITLE|||||||mp3|96|$LENGTH||$ADR|gtk-audio" >> $WORKDIR/tmp_playlist_expand
				else
					echo "$I" | awk -F'|' '{print $4 "|" $3 "||||||||||||" $4 "|gtk-audio_missing"}' >> $WORKDIR/tmp_playlist_expand
				fi
			done < "$ADR"
			$APPDIR/func_rating -buildlist 1 $WORKDIR/tmp_playlist_expand 0 0 "    " >> $WORKDIR/sourcelist #get rating
			;;
		*.m3u)
			find "$ADR" -printf "pmusicbrowse_collapse:%p|%f||||$YEAR||||||||%p|$ICON||||||\n" >> $WORKDIR/sourcelist
				while read I; do
				case $I in
					'#EXTM3U'*|'#M3U'*) #header info. We don't use this
						continue
						;;
					'#EXT'*) #we use #EXT info in m3u if available
						LENGTH=${I#*:}
						LENGTH=${LENGTH%%,*}
						[ "$LENGTH" -gt 0 ] || LENGTH='' && LENGTH=`$APPDIR/func -sec2time $LENGTH` #m3u stores length in seconds, we want a human readable length
						NAME=${I#*,}
						continue #if EXT line, go to next line...
						;;
				esac
				[ ! "$NAME" ] && NAME=${I##*/}
				#Adress (path/URL)
				case $I in
					cdda:*|*/*)	ADR="$I";;
					*) 			ADR="${SOURCE%/*}/$I";; #no path for files in list. Use current dir
				esac
				echo "$ADR|    $NAME||||||||||$LENGTH||$ADR|" | tr -d '\r' >> $WORKDIR/sourcelist
				NAME=""
			done < "$ADR"
			;;
		*.pls)
			find "$ADR" -printf "pmusicbrowse_collapse:%p|%f||||$YEAR||||||||%p|$ICON||||||\n" >> $WORKDIR/sourcelist
			while read I; do
				NR=${I%%=*}; NR=${NR#*e}
				ADR=${I#*=}
				#length
				LENGTH="`grep -F "Length${NR}=" "$SOURCE" | cut -d= -f2`"
				[ "$LENGTH" -gt 0 ] || LENGTH='' && LENGTH=`$APPDIR/func -sec2time $LENGTH` #pls stores length in seconds, we want a human readable length
				#---
				NAME="`grep -F "Title${NR}=" "$SOURCE" | cut -d= -f2`"
				[ ! "$NAME" ] && NAME=${ADR##*/}
				echo "$ADR|    $NAME||||||||||$LENGTH||$ADR|" | tr -d '\r' >> $WORKDIR/sourcelist
			done <<< "$(grep "^File" "$ADR")"
			;;
	esac
	echo 'pmusic_expand_end|___________________________' >> $WORKDIR/sourcelist
	echo "$SOURCELIST_POST" >> $WORKDIR/sourcelist
	;;

-browse)
	[ "$PTR_BTN" = "3" ] && exit #right-click menu
	[ -f "${SOURCE}" ] && exit #see func_add
	case $SOURCE in 
		pmusicbrowse_expand:*)
			SOURCE=${SOURCE#*:} #remove pmusicbrowse_expand:
#			case $SOURCE in *.pmu|*.m3u|*.pls) . $APPDIR/func_add -check_source;; esac #is it where db points?
			$APPDIR/func -playlist_expand "$SOURCE"
			echo true > $WORKDIR/UPDATE_SOURCELIST2
			;;
		pmusicbrowse_collapse:*)
			TMP=${SOURCE#*:} #remove pmusicbrowse_collapse:
			$APPDIR/func -playlist_collapse "$TMP"
			echo true > $WORKDIR/UPDATE_SOURCELIST2
			;;
		pmusicbrowse_parent:*)
			IFS=: read C1 PARENT SOURCE <<< "$SOURCE"
			;;
		pmusicbrowse_favorites)
			$APPDIR/func_favorites -show_favorites
			echo true > $WORKDIR/UPDATE_SOURCELIST2
			;;
		pmusicbrowse_radio:*)
			grep "|${SOURCE#*:}" "$STORAGE_DIR/index_radio" | cut -d'|' -f1-2 > $WORKDIR/tmp_radio
			awk -F'\n' '{print $1 "|||||||||||||gtk-audio_url"}' $WORKDIR/tmp_radio > $WORKDIR/sourcelist #give it an icon in sourcelist
			$APPDIR/func -add_to_history "pMusic: $(gettext 'Radio stations')" & #update history
			echo true > $WORKDIR/UPDATE_SOURCELIST2
			;;
	esac
	#---
	if [ -d "${SOURCE}" ]; then
		#define parent directory.
		if [ "$PARENT" ]; then
			echo "$PARENT|..|||||||||||||gtk-go-back" > $WORKDIR/sourcelist
		else
			TMP="`dirname "$SOURCE"`"
			[ "$SOURCE" = ".." ] && SOURCE="$TMP"
			[ "$SOURCE" != "/" ] && echo "$TMP|..|||||||||||||gtk-go-up" > $WORKDIR/sourcelist || echo -n > $WORKDIR/sourcelist
		fi
		#---
		echo "$SOURCE" > $WORKDIR/filebrowser_dir #remember path for next time
		find -L "$SOURCE" -mindepth 1 -maxdepth 1 -printf "%f_test%p|%f||||%TY %Tm/%Td %TH:%TM||||||||%p|gtk-%Y%f\n" \
		| sort -t'|' -k15,15 \
		| sed \
		-e 's/gtk-d.*$/gtk-directory/g' \
		-e 's/gtk-f.*\.pmd$/gtk-audio_playlist_favorites/g' \
		-e 's/gtk-f.*.pmu$\|gtk-f.*.pls$\|gtk-f.*.m3u$\|gtk-f.*.asx$/gtk-audio_playlist/g' \
		-e 's/gtk-f.*$/gtk-audio/g' \
		-e "s/^.*pmu_test\|^.*m3u_test\|^.*pls_test\|^.*pmd_test/pmusicbrowse_expand:/g" \
		-e "s/^.*_test//g" \
		| grep -iE "${AUDIO_FORMATS//$/\\|}|\.pmu\||\.pmd\||\.m3u\||\.pls\||\.asx\||gtk-directory" \
		| grep -vF '|.' \
		>> $WORKDIR/sourcelist
		#---
		[ -f $WORKDIR/gui_is_running ] && echo true > $WORKDIR/UPDATE_SOURCELIST2
		case $* in *history*) false;; *) $APPDIR/func -add_to_history "$SOURCE" & ;; esac #update history
	fi
	;;

-set_gtk)
	#GTK-theme
	[ -f $APPDIR/themes/$THEME/gtkrc_mainwindow ] && TMP=":$APPDIR/themes/$THEME/gtkrc_mainwindow"
	#include gtk code for svg-headings
	echo 'pixmap_path "'$WORKDIR'"
		style "svgHeadingImg" { bg_pixmap[NORMAL] = "heading.svg" }
		widget "*svgheading" style "svgHeadingImg"
		style "svgSplashImg" { bg_pixmap[NORMAL] = "splash.svg" }
		widget "*svgsplash" style "svgSplashImg"' > $WORKDIR/svg_gtkrc
	if [ "`grep -F 'ONLY_THIS_GTKTHEME=true' $APPDIR/themes/$THEME/themerc 2>> $STDERR`" ]; then
		export GTK2_RC_FILES="$TMP:$WORKDIR/svg_gtkrc:$APPDIR/themes/$THEME/gtkrc"
	else
		export GTK2_RC_FILES="$HOME/.gtkrc-2.0:$TMP:$WORKDIR/svg_gtkrc:$APPDIR/themes/$THEME/gtkrc"
	fi
	;;

-reset_gtk) #the pMusic specific gtk-theme is not meant for all kinds of dialogs...
	if [ -f "$APPDIR/themes/$THEME/gtkrc" ]; then
		if [ "`grep -F 'THEME_ALL_DIALOGS=false' $APPDIR/themes/$THEME/themerc 2>> $STDERR`" ]; then 
			export GTK2_RC_FILES="`grep -m 1 gtkrc $HOME/.gtkrc-2.0 | cut -d'\"' -f2 2>> $STDERR`:$WORKDIR/svg_gtkrc" #get active theme
		else
			. $APPDIR/func -set_gtk
		fi
	fi
	;;

-plugins)
	find $APPDIR/plugins/ | grep -vE "rc$|/$" > $WORKDIR/tmp
	while read I; do
		. "${I}.rc" #read plugin info from rc file
		XML_PLUGINS=$XML_PLUGINS'
		<vbox>
		<hbox>
		 <pixmap width-request="90" height-request="90" space-expand="false" space-fill="false"><input file>'$PLUGIN_IMAGE'</input><height>80</height></pixmap>
		 <vbox>
		  <text height-request="5"><label>""</label></text>
		  <hbox>
		   <text space-expand="false" space-fill="false" use-markup="true"><label>"<b>'$PLUGIN_NAME'</b>"</label></text>
		   <text space-expand="true" space-fill="true"><label>""</label></text>
		  </hbox>
		  <hbox>
		   <text space-expand="false" space-fill="false"><label>'$PLUGIN_DESCRIPTION'</label></text>
		   <text space-expand="true" space-fill="true"><label>""</label></text>
		  </hbox>
		 </vbox>
		 <text space-expand="true" space-fill="true"><label>""</label></text>
		 <vbox>
		  <button>
		   <label>'$(gettext 'Uninstall')'</label>
		   <input file stock="gtk-clear"></input>
		   <action>rm '$I'; rm '$I'.rc</action>
		   <action>disable:'$PLUGIN_EXEC'</action>
		  </button>'
		   if [ $PLUGIN_RUN_AT_START = true ]; then
		    XML_PLUGINS=$XML_PLUGINS'
		    <text use-markup="true"><label>"<i>'$(gettext 'Runs at startup')'</i>"</label></text>'
		   else
		    XML_PLUGINS=$XML_PLUGINS'
		    <button>
		     <label>'$(gettext 'Run now')'</label>
		     <input file stock="gtk-execute"></input>
		     <action>exec '$APPDIR'/plugins/'$PLUGIN_EXEC' &</action>
		    </button>'
		   fi
		  XML_PLUGINS=$XML_PLUGINS'
		 </vbox>
		 <variable>'$PLUGIN_EXEC'</variable>
		</hbox>
		<hseparator></hseparator>
		</vbox>'
	done < $WORKDIR/tmp

	echo '
<window title="pMusic - '$(gettext 'Plugins')'" icon-name="pmusic" default_width="470" default_height="400">
<vbox>
 '"$($APPDIR/func_svg -heading "$(gettext 'Installed plugins')")"'
 <vbox scrollable="true" spacing="0" width="600">
   '$XML_PLUGINS'
 </vbox>
 <hbox>
  <button>
   <label>'$(gettext 'Check new Plugins')'</label>
   <input file stock="gtk-go-down"></input>
   <action>EXIT:install</action>
  </button>
  <button ok></button>
 </hbox>
</vbox>
</window>' > $WORKDIR/xml_pmusic_plugins
	[ $TOOLTIPS = false ] && sed -i 's%tooltip-text%tooltipXXXtext%g' $WORKDIR/xml_pmusic_plugins #deactivate tooltips
	I=$IFS; IFS=""
	for STATEMENTS in $($GTKDIALOG -f $WORKDIR/xml_pmusic_plugins); do
		eval $STATEMENTS
	done
	IFS=$I
	case $EXIT in
		install)
			export GTK2_RC_FILES="`grep -Fm1 gtkrc $HOME/.gtkrc-2.0 | cut -d'\"' -f2 2>> $STDERR`" #use global gtk-theme for browser
			$BROWSER "$PLUGIN_URL" &
			;;
	esac
	;;

-add_to_history)
	if [ ! "`tail -n 1 "$STORAGE_DIR/index_history" | grep "|    $2$"`" ]; then
		DATO=`date +%s`
		echo "$DATO|pmusic_history:$DATO|    $2" >> "$STORAGE_DIR/index_history"
		cp $WORKDIR/sourcelist "$STORAGE_DIR"/history_files/$DATO
		cp $WORKDIR/tmp_search_albumart "$STORAGE_DIR"/history_files/${DATO}_albumart 2>> $STDERR
		rm -f $WORKDIR/history #reset undo/redo function
		#keep 100 history items 
		ls -1 "$STORAGE_DIR"/history_files > $WORKDIR/tmp_history
		if [ `cat $WORKDIR/tmp_history | wc -l` -gt 100 ]; then
			read TMP < $WORKDIR/tmp_history
			rm -f "$STORAGE_DIR"/history_files/$TMP
			tail -n 100 "$STORAGE_DIR/index_history" > $WORKDIR/tmp_history
			mv -f $WORKDIR/tmp_history "$STORAGE_DIR/index_history"
		fi
	fi
	;;

-history_undo)
	read HISTORY_NR < $WORKDIR/history
	[ ! -s $WORKDIR/history ] && IFS='|' read HISTORY_NR <<< "`tail -n1 "$STORAGE_DIR/index_history"`" #first undo-click: grab last active search/browse
	[ "`head -n1 "$STORAGE_DIR/index_history" | cut -d'|' -f1`" = "$HISTORY_NR" ] && exit #last entry
	SEARCH="`grep -FB1 "$HISTORY_NR" "$STORAGE_DIR/index_history" | cut -d'|' -f3 | head -n1 | cut -c 5-`"
	echo "$SEARCH" > $WORKDIR/filebrowser_dir
	TMP="`grep -FB1 "$HISTORY_NR" "$STORAGE_DIR/index_history" | cut -d'|' -f1 | head -n1`" 
	echo "$TMP" > $WORKDIR/history
	cp -f "$STORAGE_DIR"/history_files/$TMP $WORKDIR/sourcelist 
	#update albumart
	cp -f "$STORAGE_DIR"/history_files/${TMP}_albumart $WORKDIR/tmp_search_albumart
	$APPDIR/func -search_albumart_update
	;;

-history_redo)
	read HISTORY_NR < $WORKDIR/history
	[ ! "$HISTORY_NR" ] && exit
	[ "`tail -n 1 "$STORAGE_DIR/index_history" | cut -d'|' -f1`" = "$HISTORY_NR" ] && exit
	SEARCH="`grep -FA1 "$HISTORY_NR" "$STORAGE_DIR/index_history" | cut -d'|' -f3 | tail -n1 | cut -c 5-`" 
	echo "$SEARCH" > $WORKDIR/filebrowser_dir
	TMP="`grep -FA1 "$HISTORY_NR" "$STORAGE_DIR/index_history" | cut -d'|' -f1 | tail -n1`" 
	echo "$TMP" > $WORKDIR/history
	cp -f "$STORAGE_DIR"/history_files/$TMP $WORKDIR/sourcelist 
	#update albumart
	cp -f "$STORAGE_DIR"/history_files/${TMP}_albumart $WORKDIR/tmp_search_albumart
	$APPDIR/func -search_albumart_update
	;;

-dependency_check)
	if type rxvt > /dev/null 2>&1 && [ "`grep -Fi puppy /etc/DISTRO_SPECS`" ]; then
		rxvt --hold +sb -bg black -fg grey -cr black -geometry 57x20 -title "pMusic - $(gettext 'Dependecy check')" -e pmusic -D &
	else
		xterm --hold -e pmusic -D &
	fi
	;;

-sec2time) #transform 100 sec to 01:40
	MIN=$(($2/60))
	SEC=$(($2-($MIN*60)))
	echo $(printf "%02d" $MIN):$(printf "%02d" $SEC)
	;;

-jump_to_time) #start song with given time
	. $APPDIR/func -reset_gtk
	#can't jump in a radio-stream
	read TMP < $HOME/.pmusic/nowplaying
	if [[ ${TMP} = *'://'* && ${TMP} != @(*jamendo*|*youtube*) ]]; then
		TXT1="$(gettext 'You can not jump in a stream.')"
		. $APPDIR/box_ok
		exit
	fi
	FRAME="$(gettext 'Jump to time')"; IMG=""; TXT1="$(gettext 'Jump in song to time'):"; DEFAULT='0:00'
	. $APPDIR/box_input
	if [ $EXIT = "ok" ]; then
		case $INPUT in
			*:*)
				MIN=${INPUT%:*}
				SEC=${INPUT#*:}
				[ ! $SEC ] && SEC=0
				;;
			*)
				MIN=0
				SEC=$INPUT
				;;
		esac
		echo "$[($MIN*60)+$SEC]" > $WORKDIR/SS
		$APPDIR/func_kill -audio
		$APPDIR/func_player -playing -skip_update &
	fi
	;;

-faq)
	export GTK2_RC_FILES="`grep -m 1 gtkrc $HOME/.gtkrc-2.0 | cut -d'\"' -f2 2>> $STDERR`" #use global gtk-theme for browser
	[ $MY_LANGUAGE = auto ] && NLS=$LANG || NLS=$LANGUAGE #$NLS is temporary, and only used here
	if [ -s /usr/share/doc/help/${NLS%.*}/pmusic_faq.html ]; then
		$BROWSER /usr/share/doc/help/${NLS%.*}/pmusic_faq.html &
	elif [ -s /usr/share/doc/help/${NLS%_*}/pmusic_faq.html ]; then #fallback to macrolanguage if available (ISO 639-1 two letter code: en, es, fr, etc.)
		$BROWSER /usr/share/doc/help/${NLS%_*}/pmusic_faq.html &
	else
		gettext 'No FAQ available on local system.
Downloading from internet.' > $WORKDIR/splashtext
		$APPDIR/box_splash &
		#check internet connection
		LC_ALL=C wget --spider "$FTP_SERVER/pmusic_faq_en.html" 2> $WORKDIR/tmp
		if [ "`LC_ALL=C grep -Ei "unable to resolve host|file does not exist" $WORKDIR/tmp`" ]; then
			#let's try the alternative ftp server
			LC_ALL=C wget --spider "$FTP_SERVER_2/pmusic_faq_en.html" 2> $WORKDIR/tmp
			if [ "`LC_ALL=C grep -Ei "unable to resolve host|file does not exist" $WORKDIR/tmp`" ]; then
				sleep 0.2
				echo 100 > $WORKDIR/splash #reset progress bar
				TXT1="<b>$(gettext 'No connection to server')</b>"
				. $APPDIR/box_ok
				exit
			else
				MY_SERVER="$FTP_SERVER_2"
				MY_USER="$FTP_USER_2"
				MY_PASSWORD="$FTP_PASSWORD_2"
			fi
		else
			MY_SERVER="$FTP_SERVER"
			MY_USER="$FTP_USER"
			MY_PASSWORD="$FTP_PASSWORD"
		fi
		#---
		[ ! -d /usr/share/doc/help/${NLS%_*} ] && mkdir /usr/share/doc/help/${NLS%_*}
		wget --tries=1 -T 3 --user $MY_USER --password $MY_PASSWORD --output-document=/usr/share/doc/help/${NLS%_*}/pmusic_faq.html $MY_SERVER/pmusic_faq_${NLS%_*}.html
		#use english as fallback if local faq does not exist
		if [ ! -s /usr/share/doc/help/${NLS%_*}/pmusic_faq.html ]; then
			NLS=en
			[ ! -d /usr/share/doc/help/en ] && mkdir /usr/share/doc/help/en
			if [ ! -s /usr/share/doc/help/en/pmusic_faq.html ]; then
				wget --tries=1 -T 3 --user $MY_USER --password $MY_PASSWORD --output-document=/usr/share/doc/help/en/pmusic_faq.html $MY_SERVER/pmusic_faq_en.html
			fi
		fi
		echo 100 > $WORKDIR/splash
		$BROWSER /usr/share/doc/help/${NLS%_*}/pmusic_faq.html
	fi
	;;

-statusbar_playlist)
	#calculate length by sum up columns
	MIN=`cut -d'|' -f2 $WORKDIR/playlist | awk -F: '{ SUM += $1} END { print SUM*60 }'`
	SEC=`cut -d'|' -f2 $WORKDIR/playlist | awk -F: '{ SUM += $2} END { print SUM }'`
	if [ ! "$SEC" ]; then #if list is empty
		SEC_TOTAL=00; MIN_TOTAL=0
	else
		MIN_TOTAL=$((($MIN+$SEC)/60))
		SEC_TOTAL=$((($MIN+$SEC)-($MIN_TOTAL*60)))
		[ ${#SEC_TOTAL} -eq 1 ] && SEC_TOTAL="0$SEC_TOTAL" #ensure 2 digits
	fi
	#---
	echo " (${MIN_TOTAL}:${SEC_TOTAL})" > $WORKDIR/statusbar_playlist
	;;

-radio)
	#check if db exists
	if [  ! -s "$STORAGE_DIR/index_radio" ]; then
		echo -e "pmusic_radio|$(gettext 'Missing index')|||||||||||||gtk-info\npmusic_radio|$(gettext 'Doubleclick here to setup')" > $WORKDIR/sourcelist
		echo true > $WORKDIR/UPDATE_SOURCELIST
		exit
	fi
	#---
 	if [ "$2" = "-genre" ]; then
		cat $APPDIR/radio-tags | sed 's%$%|||||||||||||gtk-bullet%g' > $WORKDIR/sourcelist
		$APPDIR/func -add_to_history "pMusic: $(gettext 'Radio Genre')" & #update history
	elif [ "$2" = "-country" ]; then
		cat $APPDIR/radio-country | sed 's%$%|||||||||||||gtk-bullet%g' > $WORKDIR/sourcelist
		$APPDIR/func -add_to_history "pMusic: $(gettext 'Radio Country')" & #update history
	fi
 	echo true > $WORKDIR/UPDATE_SOURCELIST #update source-list
	;;
	
-playlist_move)
	#button right-click --> already run -playlist_menu
	if [ $BUTTON = 3 ]; then echo -n > $WORKDIR/RIGHT_MENU; exit; fi
	#button mid-click
	if [ $BUTTON = 2 ]; then $APPDIR/func -remove_from_list; exit; fi

	#exit if no valid item. PRESS_EVENT includes all songs if nothing is choosen
	[[ "$(uniq $WORKDIR/PLAYLIST_PRESS_EVENT)" = *$'\n'* ]] && exit

	#Button left-click
	read PRESS_EVENT < $WORKDIR/PLAYLIST_PRESS_EVENT
	RELEASE_EVENT="`grep -F "$PLAYLIST" $WORKDIR/playlist`"
	#move song in playlist
	if [ "$RELEASE_EVENT" != "$PRESS_EVENT" ]; then
		( flock -e 201
			grep -Fv "$PRESS_EVENT" $WORKDIR/playlist > $WORKDIR/tmp_playlist
			if [[ "$RELEASE_EVENT" = *$'\n'* ]]; then #move last. RELEASE_EVENT includes all songs if nothing is choosen
				mv -f $WORKDIR/tmp_playlist $WORKDIR/tmp_playlist1
				echo "$PRESS_EVENT" >> $WORKDIR/tmp_playlist1
			else #normal move
				grep -Fm1 -B1000 "$RELEASE_EVENT" $WORKDIR/tmp_playlist | grep -vF "$RELEASE_EVENT" > $WORKDIR/tmp_playlist1
				echo "$PRESS_EVENT" >> $WORKDIR/tmp_playlist1
				grep -Fm1 -A1000 "$RELEASE_EVENT" $WORKDIR/tmp_playlist >> $WORKDIR/tmp_playlist1
			fi
			mv -f $WORKDIR/tmp_playlist1 $WORKDIR/playlist
		) 201>$WORKDIR/playlist.lockfile 
	else #play
		if [ "$PRESS_EVENT" ]; then
			#avoid rating for playing track
			[ "`LC_ALL=C grep -F aplay <<< $(LC_ALL=C ps -eo pid,s,command)`" ] && echo true > $WORKDIR/NO_RATING #playing
			#---
			echo 0 > $WORKDIR/SS
			$APPDIR/func_player -stop -skip_update
			$APPDIR/func_player -playing "${RELEASE_EVENT##*|}" &
			exit 0
		fi
	fi
	;;

-remove_from_list)
	if [ "$PLAYLIST" ]; then
		( flock -e 201
			grep -v "$PLAYLIST" $WORKDIR/playlist > $WORKDIR/tmp_remove_from_list
			mv -f $WORKDIR/tmp_remove_from_list $WORKDIR/playlist
		) 201>$WORKDIR/playlist.lockfile 
		$APPDIR/func -statusbar_playlist & #update statusbar
	fi
	;;

-about)
	. $APPDIR/func -reset_gtk
	. $APPDIR/gui_about
	$GTKDIALOG -p pmusic_about
	;;

-undo)
	$APPDIR/func_store_playlist
	( flock -e 201
		echo > $WORKDIR/last_added_playlist
		read PLAYLIST_NAME < $WORKDIR/PLAYLIST_NAME
		[ ! "$PLAYLIST_NAME" ] && PLAYLIST_NAME="`ls "$STORAGE_DIR/storage_playlist/" | tail -n1`"
		[ -s $WORKDIR/playlist ] && PLAYLIST_NAME="`ls "$STORAGE_DIR/storage_playlist/" | grep -xB1 "$PLAYLIST_NAME" | head -n1`"
		cp "$STORAGE_DIR/storage_playlist/$PLAYLIST_NAME" $WORKDIR/playlist
		echo "$PLAYLIST_NAME" > $WORKDIR/PLAYLIST_NAME
	) 201>$WORKDIR/playlist.lockfile 
	$APPDIR/func -statusbar_playlist & #update statusbar
	;;

-redo)
	( flock -e 201
		echo > $WORKDIR/last_added_playlist
		read PLAYLIST_NAME < $WORKDIR/PLAYLIST_NAME
		TMP="`ls "$STORAGE_DIR/storage_playlist/" | grep -xA1 "$PLAYLIST_NAME" | tail -n1`"
		cp "$STORAGE_DIR/storage_playlist/$TMP" $WORKDIR/playlist
		echo "$TMP" > $WORKDIR/PLAYLIST_NAME
		$APPDIR/func -statusbar_playlist & #update statusbar
	) 201>$WORKDIR/playlist.lockfile 
	;;

-burn)
	cut -d '|' -f 4 $WORKDIR/playlist | grep -vF "('\|cdda:\|://\|')" > $WORKDIR/tmp_burn #do not include CD tracks and streams
	export BROWSER_DIR=""
	pburn -i $WORKDIR/tmp_burn -m audio
	;;

-show_location)
	[ ! "$2" ] && exit
	SOURCE=${2%/*}
	if type rox > /dev/null 2>&1; then
		rox -d "$SOURCE" &
	else
		echo true > $WORKDIR/UPDATE_SOURCELIST
		. $0 -browse
		echo true > $WORKDIR/UPDATE_SOURCELIST
	fi
	;;

-quit)
	export LC_ALL=C
	echo > $WORKDIR/last_added_playlist #this is what shows up in the save-dialog
	echo 0 > $WORKDIR/maingui_notebook_page #be sure to close message in case of a pMusic restart.
	#first quit guis
	TMP="$(ps -eo pid,command)"
	PS=$(grep -iE "pmusic|aplay" <<< "$TMP")
	for I in `grep -F gtkdialog <<< "$PS" | grep -vF radiohits | awk '{print $1}' 2>> $STDERR`; do kill -9 $I 2>> $STDERR; done #do not kill radiohits grabber 
	#stop audio
	pmusic -s stop
	rm -f $WORKDIR/gui_is_running #ensure to flag 'no gui'
	#remove play-icon in playlist
	sed -i "s/gtk-media-play//" $WORKDIR/playlist
	#deactivate equalizer
	mv -f $HOME/.asoundrc $HOME/.asoundrc.bak 2>> $STDERR
	#remove temporary cd-audio files
	rm $WORKDIR/*.wav 2>> $STDERR
	rm $WORKDIR/*.inf 2>> $STDERR
	#remove temporary files, some could be big
	rm $WORKDIR/tmp* 2>> $STDERR
	rm $WORKDIR/trackinfo[0-9]* 2>> $STDERR #keep the refreshing trackinfo files
	echo -n > $WORKDIR/statusbar
	#kill the rest - in case something is still running
	for I in `grep -iF plugins <<< "$PS" | awk '{print $1}' 2>> $STDERR`; do kill -9 $I 2>> $STDERR; done
	for I in `grep -F index <<< "$PS" | awk '{print $1}' 2>> $STDERR`; do kill -9 $I 2>> $STDERR; done
	for I in `grep -F aplay <<< "$PS" | awk '{print $1}' 2>> $STDERR`; do kill -9 $I 2>> $STDERR; done
	for I in `grep -F playing <<< "$PS" | awk '{print $1}' 2>> $STDERR`; do kill -9 $I 2>> $STDERR; done
	for I in `grep -F gtkdialog <<< "$PS" | grep -vF radiohits | awk '{print $1} 2>> $STDERR'`; do kill -9 $I 2>> $STDERR; done
	for I in `grep -vF radiohits <<< "$PS" | awk '{print $1}' 2>> $STDERR`; do kill -9 $I 2>> $STDERR; done
	killall cdda2wav 2>> $STDERR
	#reset info about search filters. Next run will use settings from preferences
	rm $WORKDIR/SEARCH_*
	exit 0
	;;

-rename)
	DIR=${2%/*}
	NAME=${2##*/}; NAME=${NAME%.*}
	[ ! -d "$FILE" ] && EXTENSION=${2##*.}
	#box
	FRAME="$(gettext 'Rename source file')"; IMG="convert"; TXT1="$NAME"; DEFAULT="$NAME"
	. $APPDIR/box_input
	if [ $EXIT = "ok" ]; then
		#if no name (use of " in name clears variable)
		if [ ! "$INPUT" ] || [ "`grep -E '\||\\|\"' <<< "$INPUT"`" ]; then
			TXT1="$(gettext 'Filename is empty!
Be aware that use of some special chars (like \"|) in filename clears value.')"
			. $APPDIR/box_ok
			exit
		fi
		INPUT="`sed 's|"|\\\\"|g' <<< "$INPUT"`"
		#check if already exist
		if [ -f "$DIR"/"$INPUT"."$EXTENSION" ]; then
			TXT1="$DIR"/"$INPUT"."$EXTENSION $(gettext 'already exist')"
			. $APPDIR/box_ok
			exit
		fi
		#---
		echo > $WORKDIR/error
		mv "$DIR"/"$NAME""$EXTENSION" "$DIR"/"$INPUT""$EXTENSION" 2> $WORKDIR/error

		TXT1=($(<"$WORKDIR/error"))
		if [ -n "$TXT1" ]; then
			. $APPDIR/box_ok
		else #update playlist and index
			#running sed directly gives problems with special chars
			echo '( flock -e 200' > $WORKDIR/exec3
			echo "sed -i \"s%$DIR/$NAME$EXTENSION|$NAME$EXTENSION%$DIR/$INPUT$EXTENSION|$INPUT$EXTENSION%g\" \"$STORAGE_DIR/index_mymusic\"" >> $WORKDIR/exec3 #in case no metatags is defined in db
			echo "sed -i \"s%$DIR/$NAME$EXTENSION%$DIR/$INPUT$EXTENSION%g\" \"$STORAGE_DIR/index_mymusic\"" >> $WORKDIR/exec3
			echo ') 200> $WORKDIR/mymusic_db.lockfile' >> $WORKDIR/exec3
			echo "sed -i \"s%$DIR/$NAME$EXTENSION%$DIR/$INPUT$EXTENSION%g\" \"$STORAGE_DIR/index_recent\"" >> $WORKDIR/exec3
			echo '( flock -e 201' >> $WORKDIR/exec3
			echo "sed -i \"s%$NAME$EXTENSION%$INPUT$EXTENSION%g\" $WORKDIR/playlist $WORKDIR/PLAYLIST $WORKDIR/PLAYLIST_ALL" >> $WORKDIR/exec3
			echo ') 201> $WORKDIR/playlist.lockfile' >> $WORKDIR/exec3
			echo "sed -i \"s%$NAME$EXTENSION|%$INPUT$EXTENSION|%g\" $WORKDIR/sourcelist" >> $WORKDIR/exec3 #column 2 - name
			echo "sed -i \"s%$DIR/$NAME$EXTENSION%$DIR/$INPUT$EXTENSION%g\" $WORKDIR/favorites" >> $WORKDIR/exec3
			sed -i 's/\&/\\\&/g' $WORKDIR/exec3
			chmod 777 $WORKDIR/exec3
			$WORKDIR/exec3
			echo true > $WORKDIR/UPDATE_SOURCELIST
			echo true > $WORKDIR/UPDATE_GUI
		fi
	fi
	;;

-copy)
	FILE="$2"
	FRAME="$(gettext 'Copy source file')"; IMG="copy"; TXT1="$FILE"; DEFAULT="$HOME"
	. $APPDIR/box_input
	if [ $EXIT = "ok" ]; then
		while read I; do
			echo > $WORKDIR/error
			cp "$I" "$INPUT/${I##*/}" 2> $WORKDIR/error
			TXT1=($(<"$WORKDIR/error"))
			[ -n "$TXT1" ] && . $APPDIR/box_ok #error
		done <<< "$FILE"
	fi
	;;

-delete)
	DEL="$2"
	FRAME="$(gettext 'Delete source file')"; IMG="clear"; TXT1="$DEL"
	. $APPDIR/box_yesno
	if [ $EXIT = "yes" ]; then
		while read I; do
			rm "$I"
			. $APPDIR/func -remove_from_list
			#recent index
			grep -vF "$I" "$STORAGE_DIR/index_recent" > $WORKDIR/tmp
			mv -f $WORKDIR/tmp "$STORAGE_DIR/index_recent"
			#db
			( flock -e 200
				grep -vF "$I" "$STORAGE_DIR/index_mymusic" > $WORKDIR/tmp
				mv -f $WORKDIR/tmp "$STORAGE_DIR/index_mymusic"
			) 200>$WORKDIR/mymusic_db.lockfile 
			#favorites
			grep -vF "$I" "$STORAGE_DIR/favorites" > $WORKDIR/tmp
			mv -f $WORKDIR/tmp "$STORAGE_DIR/favorites"
			#sourcelist
			$APPDIR/func -playlist_collapse "$I"
			grep -vE ":${I}|^${I}" $WORKDIR/sourcelist > $WORKDIR/tmp
			mv -f $WORKDIR/tmp $WORKDIR/sourcelist
		done <<< "$DEL"
		echo true > $WORKDIR/UPDATE_SOURCELIST
	fi
	;;

-save)
	. $APPDIR/func -reset_gtk
	read ACTIVE_PLAYLIST < $WORKDIR/last_added_playlist
	DIR=${ACTIVE_PLAYLIST%/*}
	[ ! -s $WORKDIR/last_added_playlist ] && echo "$HOME/pMusic_playlist.pmu" > $WORKDIR/last_added_playlist
	#sort extensions so the active comes first
	echo -e "pmu - pMusic $(gettext 'native format')\nm3u - $(gettext 'Supported by most players')\npls - $(gettext 'Shoutcast playlist')\ntxt - $(gettext 'Plain track list')" > $WORKDIR/tmp_save
	case $ACTIVE_PLAYLIST in
		*.pmu)
			mv -f $WORKDIR/tmp_save $WORKDIR/save_formats
			;;
		*.m3u)
			echo "m3u - $(gettext 'Supported by most players')" > $WORKDIR/save_formats
			grep -v m3u $WORKDIR/tmp_save >> $WORKDIR/save_formats
			;;
		*.pls)
			echo "pls - $(gettext 'Shoutcast playlist')" > $WORKDIR/save_formats
			grep -v pls $WORKDIR/tmp_save >> $WORKDIR/save_formats
			;;
		*.txt)
			echo "txt - $(gettext 'Plain track list')" > $WORKDIR/save_formats
			grep -v txt $WORKDIR/tmp_save >> $WORKDIR/save_formats
			;;
	esac
	#---
	export pmusic_save='
	<window title="pMusic - '$(gettext 'Save playlist')'" icon-name="pmusic">
	 <vbox>
	  <timer visible="false" milliseconds="true" interval="500">
	   <action condition="command_is_true([[ ${SAVE_FORMAT} = @(*m3u*|*txt*) ]] && echo true)">enable:SAVE_PATH</action>
	   <action condition="command_is_true([[ ${SAVE_FORMAT} = @(*pmu*|*pls*) ]] && echo true)">disable:SAVE_PATH</action>
	  </timer>
	  <frame '$(gettext 'Save playlist')'>
	   <hbox>
	    <text><label>'$(gettext 'File')'</label></text>
	    <entry accept="savefilename" width-request="300" fs-filters="*.pmu|*.m3u|*.pls" fs-folder="'$DIR'" fs-title="pMusic - '$(gettext 'Save playlist')'">
	     <variable>SAVEFILE</variable>
	     <input file>'$WORKDIR'/last_added_playlist</input>
	     <action signal="activate">exit:ok</action>
	    </entry>
	    <button>
	     <input file stock="gtk-open"></input>
	     <action type="fileselect">SAVEFILE</action>
	    </button>
	   </hbox>
	   <checkbox tooltip-text="'$(gettext 'm3u format supports to skip path description. It will instead use the same path as the m3u file itself. This is handy when music files are moving to a new location.')'">
	    <label>'$(gettext 'Include path')'</label>
	    <variable>SAVE_PATH</variable>
	    <input file>'$WORKDIR'/SAVE_PATH</input>
	    <action>echo $SAVE_PATH > '$WORKDIR'/SAVE_PATH</action>
	   </checkbox>
	   <hbox>
	    <text><label>'$(gettext 'Filetype')'</label></text>
	    <comboboxtext>
	     <variable>SAVE_FORMAT</variable>
	     <input file>'$WORKDIR'/save_formats</input>
	     <action condition="command_is_true([[ ${SAVE_FORMAT} = *pmu* ]] && echo true)">echo "${SAVEFILE%.*}.pmu" > '$WORKDIR'/last_added_playlist</action>
	     <action condition="command_is_true([[ ${SAVE_FORMAT} = *m3u* ]] && echo true)">echo "${SAVEFILE%.*}.m3u" > '$WORKDIR'/last_added_playlist</action>
	     <action condition="command_is_true([[ ${SAVE_FORMAT} = *pls* ]] && echo true)">echo "${SAVEFILE%.*}.pls" > '$WORKDIR'/last_added_playlist</action>
	     <action condition="command_is_true([[ ${SAVE_FORMAT} = *txt* ]] && echo true)">echo "${SAVEFILE%.*}.txt" > '$WORKDIR'/last_added_playlist</action>
	     <action>refresh:SAVEFILE</action>
	    </comboboxtext>
	   </hbox>
	  </frame>
	  <hbox>
	   <button cancel></button>
	   <button can-default="true" has-default="true">
	    <label>'$(gettext 'Ok')'</label>
	    <input file stock="gtk-ok"></input>
	    <action type="exit">ok</action>
	   </button>
	  </hbox>
	 </vbox>
	</window>'
	I=$IFS; IFS=""
	for STATEMENTS in $($GTKDIALOG -p pmusic_save); do
		eval $STATEMENTS
	done
	IFS=$I
	if [ "$EXIT" = "ok" ]; then
		case $SAVEFILE in
			*.pmu|*.m3u|*.pls|*.txt)
				EXT=${SAVEFILE##*.}
				SAVEFILE=${SAVEFILE%.*}
				;;
			*)
				EXT=${SAVE_FORMAT%% *}
				;;
		esac
		if [ -s "$SAVEFILE".$EXT ]; then #already exist
			IMG=dialog-warning
			FRAME="$(gettext 'Warning')"
			TXT1="<b>$SAVEFILE.$EXT $(gettext 'already exist')</b>"
			TXT2="$(gettext 'Do you want to overwrite existing file?')"
			DEFAULT=yes
			. $APPDIR/box_yesno
			if [ $EXIT = no ]; then 
				echo -n > $WORKDIR/SAVEFILE
				exit
			fi
		fi
		if [ "$SAVEFILE" ]; then
			case $EXT in
				txt)
					echo -n > "$SAVEFILE".txt
					while IFS='|' read C1 C2 C3 ADR C; do
						[[ $SAVE_PATH = false && ${ADR} != @(http*|cdda*) ]] && ADR=${ADR##*/} #remove path of files if choosen in gui
						echo "$ADR" >> "$SAVEFILE".txt
					done < $WORKDIR/playlist
					;;
				m3u)
					#add EXT info which will speed up reading of the playlist (skip length detection)
					echo '#EXTM3U' > "$SAVEFILE".m3u
					while IFS='|' read C1 LENGTH NAME ADR C; do
						LENGTH=$(((10#${LENGTH%:*} * 60) + 10#${LENGTH#*:}))
						[[ $SAVE_PATH = false && ${ADR} != @(http*|cdda*) ]] && ADR=${ADR##*/} #remove path of files if choosen in gui
						echo -e "#EXTINFO:${LENGTH},$NAME\n$ADR" >> "$SAVEFILE".m3u
					done < $WORKDIR/playlist
					;;
				pls)
					#add EXT info which will speed up reading of the playlist (skip length detection)
					COUNT=1
					echo -n -e "[playlist]\nNumberOfEntries=" > "$SAVEFILE".pls
					grep -c ^ $WORKDIR/playlist >> "$SAVEFILE".pls
					while IFS='|' read COL1 LENGTH NAME ADR ADR_ID; do
						LENGTH=$(((10#${LENGTH%:*} * 60) + 10#${LENGTH#*:}))
						echo -e "File${COUNT}=${ADR}\nTitle${COUNT}=${NAME}\nLength${COUNT}=${LENGTH}" >> "$SAVEFILE".pls
						COUNT=$(($COUNT+1))
					done < $WORKDIR/playlist
					;;
				pmu)
					sed 's/gtk-media-play//' $WORKDIR/playlist > "$SAVEFILE".pmu
					;;
			esac
			#---
			echo "$SAVEFILE".$EXT > $WORKDIR/last_added_playlist
			#update index
			NAME=${SAVEFILE##*/}
			if [[ "$SAVEFILE" = *"$STORAGE_DIR/pmu"* ]]; then #if saved to pmu storage we suppose it is a edited pmusic-generated album. 
				ARTIST=${NAME% - *}
				ALBUM=${NAME#* - }
			else
				ARTIST=${NAME}
				ALBUM=''
			fi
			grep -v "^${SAVEFILE}.$EXT|" "$STORAGE_DIR/index_mymusic" > $WORKDIR/tmp_save
			mv -f $WORKDIR/tmp_save "$STORAGE_DIR/index_mymusic"
			( flock -e 202
				echo "${SAVEFILE}.$EXT|$ARTIST||$ALBUM||||||||||${SAVEFILE}.$EXT|gtk-audio_playlist||||||" >> $WORKDIR/mymusic_stack
			) 202>$WORKDIR/mymusic_stack.lockfile
		else
			TXT1="<b>$(gettext 'Target file is not defined')</b>"
			. $APPDIR/box_ok
		fi
	fi
	;;

-new)
	echo -n > $WORKDIR/playlist
	echo > $WORKDIR/last_added_playlist
	$APPDIR/func -statusbar_playlist & #update statusbar
	;;



	
##############      Search      ################

-search)
	kill -9 `LC_ALL=C ps -eo pid,command | grep -F pmusic | grep -F search2 | awk '{print $1}'` 2>> $STDERR #kill ongoing search
	[[ ${SEARCH} !=	*/* ]] && $APPDIR/func -search2 &
	;;
-search2)
	#this is searching while typing -- only use this for local files (speed issue)
	[[ $SEARCH_MYMUSIC = false && $SEARCH_RADIO = false && $SEARCH_WEBMUSIC = false ]] && exit
	#---
	echo "export LC_ALL=C" > $WORKDIR/tmp_exec
	echo -n "cat " >> $WORKDIR/tmp_exec
	[ $SEARCH_MYMUSIC = true ] && echo -n "\"$STORAGE_DIR/index_mymusic\" " >> $WORKDIR/tmp_exec
	[ $SEARCH_RADIO = true ] && echo -n "\"$STORAGE_DIR/index_radio\" " >> $WORKDIR/tmp_exec
	[ $SEARCH_WEBMUSIC = true ] && echo -n "\"$STORAGE_DIR/index_webmusic*\" " >> $WORKDIR/tmp_exec
	I=$IFS; IFS=" "
	for I in $SEARCH; do echo -n "| grep -iF '$I' " >> $WORKDIR/tmp_exec; done
	IFS=$I
	echo -n " > $WORKDIR/tmp_sourcelist" >> $WORKDIR/tmp_exec
	chmod 722 $WORKDIR/tmp_exec
	$WORKDIR/tmp_exec 2>> $STDERR #execute
	echo "$SEARCH" > $WORKDIR/filebrowser_dir #remember searchtext for next keystroke
	#refresh browser field only if small amount of hits
	if [ `grep -c ^ $WORKDIR/tmp_sourcelist` -lt 500 ]; then
		mv $WORKDIR/tmp_sourcelist $WORKDIR/sourcelist
		echo true > $WORKDIR/UPDATE_SOURCELIST
	fi
	;;
-search_refresh) #click enter in search-field.
	case $SEARCH in
		'')
			echo > $WORKDIR/sourcelist
			exit
			;;
		http://*|https://*)
			SOURCE="$SEARCH"
			. $APPDIR/func_add -add
			echo true > $WORKDIR/UPDATE_GUI
			;;
		/*) #if file --> add to playlist
			if [ -f "$SEARCH" ]; then
				SOURCE="$SEARCH"
				. $APPDIR/func_add -add
				echo true > $WORKDIR/UPDATE_GUI
			else #browse
				SOURCE="$SEARCH"
				. $APPDIR/func -browse "$*"
			fi
			exit
			;;
		*) #search
			kill -9 `LC_ALL=C ps -eo pid,command | grep pmusic | grep search2 | awk '{print $1}'` #kill ongoing search
			#clicking on an albumart (searched) we send an extra attribute to avoid albumart-update
			if [ "$2" ]; then
				$APPDIR/func -search_sources "$SEARCH" no_albumart
				NO_UPDATE=no_albumart
			else
				$APPDIR/func -search_sources "$SEARCH" no_update
			fi
			mv -f $WORKDIR/search_sources $WORKDIR/sourcelist
			echo "$SEARCH" > $WORKDIR/filebrowser_dir #remember searchtext for next keystroke
			;;
	esac
	#update history
	[ "$NO_UPDATE" != "no_albumart" ] && $APPDIR/func -add_to_history "$SEARCH" & #we don't want to keep info when user click on albumart
	;;
-search_sources) #this is also used to update the content of sourclist (ie. to update tags).
	SEARCH="$2"
	NO_UPDATE="$3" #point result to another target, or udating of sourcelist is done in gui-code to give an imidiate response
	#this seperates searchresults in different groups
	echo > $WORKDIR/tmp_exec
	[ $UTF8 = false ] && echo "export LC_ALL=${LANG%%_*}" >> $WORKDIR/tmp_exec
	echo "echo -n > $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
	#pMusic allows '-' to define what should NOT be in searchresult. We deal with that after the initial search
	SEARCHSTRING="$SEARCH" #for history index...
	NOT_SEARCH="`echo "$SEARCH" | tr ' ' '\n' | grep "^-" | cut -c2- | tr '\n' ' '`"
	SEARCH="`echo "$SEARCHSTRING" | tr ' ' '\n' | grep -v "^-" | tr '\n' ' '`"
	#When in Radio streamer frontend we should only search for radio stations.
	if [[ "$PMUSIC_FRONTEND" = *'/.Radio'* ]]; then
		SEARCH_COLLECTIONS=false
		SEARCH_MYMUSIC=false
		SEARCH_ALBUMART=false
		SEARCH_RADIO=true
		SEARCH_WEBMUSIC=false
		SEARCH_FILES=false
	fi

	#pfilesearch
	if [ $SEARCH_FILES = true ] && type pfilesearch > /dev/null 2>&1; then
		#no heading is necessary if user don't use any of the indexes.
		if [ $SEARCH_MYMUSIC = true ] || [ $SEARCH_COLLECTIONS = true ] || [ $SEARCH_RADIO = true ] || [ $SEARCH_WEBMUSIC = true ]; then
			echo "echo -e '\n|__${SEARCHPATH}__' >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
		fi
		#---
		echo "pfilesearch -bb -f music -c \"${SEARCH// /[AND]}\" -d \"$SEARCHPATH\"" >> $WORKDIR/tmp_exec
		echo 'sort -u --output='$WORKDIR'/tmp3 '$HOME'/.pfilesearch/hits' >> $WORKDIR/tmp_exec
		echo 'paste -d"|" '$WORKDIR'/tmp3 '$WORKDIR'/tmp3 >> '$WORKDIR'/search_sources' >> $WORKDIR/tmp_exec
	fi

	#My music - Local tracks
	#First we search for both tracks and collections (for speed)
	if [ $SEARCH_COLLECTIONS = true ] || [ $SEARCH_MYMUSIC = true ]; then
		echo "find \"$STORAGE_DIR/favorite_lists/\" -type f -printf \"%p|%f||||||||||||%p|gtk-audio_playlist_favorites||||||\n\" > $WORKDIR/tmp_search_fav" >> $WORKDIR/tmp_exec
		echo -n "cat \"$STORAGE_DIR/index_mymusic\" $WORKDIR/tmp_search_fav" >> $WORKDIR/tmp_exec
		for I in $SEARCH; do echo -n '| grep -iF "'${I//\"/\\\"}'" ' >> $WORKDIR/tmp_exec; done
		echo " > $WORKDIR/tmp_search" >> $WORKDIR/tmp_exec
		if [ $SEARCH_COLLECTIONS = true ]; then
			#search inside MyMusic index
			if [ -s "$STORAGE_DIR/index_mymusic" ]; then
				echo "echo -e '\n|__  $(gettext 'M Y   L I S T S')  __' > $WORKDIR/tmp_search_sources" >> $WORKDIR/tmp_exec
				echo "grep -HiE \"\.pmu\||\.pmd\||\.m3u\||\.pls\|\" $WORKDIR/tmp_search | grep -vF \"$STORAGE_DIR/pmu\" > $WORKDIR/tmp_search_sources2" >> $WORKDIR/tmp_exec
				echo "[ -s $WORKDIR/tmp_search_sources2 ] && cat $WORKDIR/tmp_search_sources $WORKDIR/tmp_search_sources2 >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
				#---
				echo "echo -e '\n|__  $(gettext 'A L B U M S')  __' > $WORKDIR/tmp_search_sources" >> $WORKDIR/tmp_exec
				echo "grep -HF \"$STORAGE_DIR/pmu\" $WORKDIR/tmp_search  > $WORKDIR/tmp_search_sources2" >> $WORKDIR/tmp_exec
				echo "[ -s $WORKDIR/tmp_search_sources2 ] && cat $WORKDIR/tmp_search_sources $WORKDIR/tmp_search_sources2 >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
				#---
				echo "sed -i 's%$WORKDIR/tmp_search%pmusicbrowse_expand%g' $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
			fi
		fi
		if [ $SEARCH_MYMUSIC = true ]; then
			#index tracks
			echo "echo -e '\npmusic_index|__  $(gettext 'M Y   T R A C K S')  __' >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
			if [ -s "$STORAGE_DIR/index_mymusic" ]; then
				echo "grep -ivE \"\.pmu\||\.m3u\||\.pls\||\.pmd\|\" $WORKDIR/tmp_search > $WORKDIR/tmp_search_tracks" >> $WORKDIR/tmp_exec
				#update icons and visible rating coloumn in db
				echo "$APPDIR/func_rating -buildlist 1 $WORKDIR/tmp_search_tracks >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
			fi
		fi
	fi

	#album art
	if [ $SEARCH_ALBUMART = true ] && [ "$NO_UPDATE" != "no_albumart" ]; then
		echo "find \"$STORAGE_DIR/albumart/\" -iname \"*${SEARCH%% *}*\" -printf \"%p\n\" > $WORKDIR/tmp_search_albumart1" >> $WORKDIR/tmp_exec
		echo -n "cat $WORKDIR/tmp_search_albumart1" >> $WORKDIR/tmp_exec
		for I in $SEARCH; do TMP="`echo "$I" | sed 's%"%\\\\\"%g'`"; echo -n "| grep -iF \"$TMP\" " >> $WORKDIR/tmp_exec; done
		echo " > $WORKDIR/tmp_search_albumart" >> $WORKDIR/tmp_exec
	fi

	#radio
	if [ $SEARCH_RADIO = true ]; then
		echo "echo -e '\npmusic_radio|__  $(gettext 'R A D I O')  __' >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
		if [ -s "$STORAGE_DIR/index_radio" ]; then
			echo -n "awk -F'\\n' '{print \$1 \"|||||||||||gtk-audio_url\"}' \"$STORAGE_DIR/index_radio\"" >> $WORKDIR/tmp_exec
			for I in $SEARCH; do echo -n '| grep -iF "'${I//\"/\\\"}'" ' >> $WORKDIR/tmp_exec; done
			echo " >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
		else #message
			echo "echo -e \"pmusic_radio|$(gettext 'Missing index')|||||||||||||gtk-info\npmusic_radio|$(gettext 'Doubleclick here to setup')\" >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
		fi
	fi

	#webmusic
	if [ $SEARCH_WEBMUSIC = true ]; then
		echo "echo -e '\npmusic_webmusic_manager|__  $(gettext 'W E B   M U S I C')  __' >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
#		if [ -s "$STORAGE_DIR/index_webmusic_youtube" ]; then
#			echo -n "cat \"$STORAGE_DIR/index_webmusic_youtube\"" >> $WORKDIR/tmp_exec
#			for I in $SEARCH; do echo -n '| grep -iF "'${I//\"/\\\"}'" ' >> $WORKDIR/tmp_exec; done
#			echo " >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
#		fi
		if [ -s "$STORAGE_DIR/index_webmusic_jamendo" ]; then
			echo -n "cut -c 2- \"$STORAGE_DIR/index_webmusic_jamendo\"" >> $WORKDIR/tmp_exec
			for I in $SEARCH; do echo -n '| grep -iF "'${I//\"/\\\"}'" ' >> $WORKDIR/tmp_exec; done
			#jamendo index is shrinked with a cut down url. We need to expand URL
			echo " | awk -F \"|\" '{print \"http://api.jamendo.com/get2/stream/track/redirect/?streamencoding=mp31&id=\"\$1\"|\"\$2\"|\"\$3\"|\"\$4\"|\"\$5\"|\"\$6\"|\"\$7\"|\"\$8\"|\"\$9\"|\"\$10\"|\"\$11\"|\"\$12 }' >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
#			echo " | sed 's%+%http://api.jamendo.com/get2/stream/track/redirect/?streamencoding=mp31\&id=%' >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
		fi
		#if no indexes is present - search jamendo.com
		if [ ! -s "$STORAGE_DIR/index_webmusic_youtube" ] && [ ! -s "$STORAGE_DIR/index_webmusic_jamendo" ]; then
		
			echo "echo -e \"|$(gettext 'Missing index limits search')\n|    - $(gettext 'Much SLOWER')\n|    - $(gettext 'No multitag search')\n|    - $(gettext 'Max results is 500 pr search')\n|$(gettext 'See Setup in Music-sources menu')\" >> $WORKDIR/search_sources" >> $WORKDIR/tmp_exec
			echo "wget -t 1 --connect-timeout=1 -O - \"http://api.jamendo.com/get2/id+artist_name+name+album_name+numalbum+dates+genre+duration/track/plain/track_album+album_artist/?searchquery=${SEARCH// /+}&order=searchweight_desc&n=500\" | tr '\t' '|' | sed -e 's/http:/  96      /g' -e 's/Array//g' -e 's/^/http:\/\/api.jamendo.com\/get2\/stream\/track\/redirect\/?streamencoding=mp31\&id=/g' > $WORKDIR/tmp_wget" >> $WORKDIR/tmp_exec
			echo "if grep -F http: $WORKDIR/tmp_wget; then cat $WORKDIR/tmp_wget >> $WORKDIR/search_sources; echo >> $WORKDIR/search_sources; fi" >> $WORKDIR/tmp_exec
		fi
	fi
	#remove first empty lines
	echo "head -n 1001 $WORKDIR/search_sources | tac | head -n-1 | tac > $WORKDIR/tmp_search_sources" >> $WORKDIR/tmp_exec
	#execute
	chmod 722 $WORKDIR/tmp_exec
	$WORKDIR/tmp_exec
	#pMusic allows '-' to define what should NOT be in searchresult
	if [ "$NOT_SEARCH" ]; then
		cp -f $WORKDIR/tmp_search_sources $WORKDIR/tmp
		for I in $NOT_SEARCH; do
			grep -viF "$I" $WORKDIR/tmp > $WORKDIR/tmp2
			mv -f $WORKDIR/tmp2 $WORKDIR/tmp
		done
		mv -f $WORKDIR/tmp $WORKDIR/tmp_search_sources
	fi
	#show only the first 1000 hits
	NR=1000 #max_view
	if [ `grep -c ^ $WORKDIR/tmp_search_sources` -ge $NR ]; then
		echo -e "|$(gettext 'More than') $NR $(gettext 'hits')|||||||||||||gtk-info\n|$(gettext 'Please narrow search')\n" > $WORKDIR/search_sources
		head -n $NR $WORKDIR/tmp_search_sources >> $WORKDIR/search_sources
	else
		mv -f $WORKDIR/tmp_search_sources $WORKDIR/search_sources
	fi
	#here ends the ordinay search.

	#add to playlist if only one hit
	TMP="`grep -F '/' $WORKDIR/search_sources`"
	if [[ ${TMP} != *$'\n'* ]]; then
		SOURCE=${TMP%%|*}
		. $APPDIR/func_add -add
		echo true > $WORKDIR/UPDATE_GUI
	fi
	#update pics for albumart search
	if [ $SEARCH_ALBUMART = true ] && [ "$NO_UPDATE" != "no_albumart" ]; then
		$APPDIR/func -search_albumart_update
	fi
	#now this function is used only to update content in sourcelist. This is possible because search history is stored in index_history
	#see ie. id3io -write
	if [ "$NO_UPDATE" != "no_update" ]; then
		mv -f $WORKDIR/search_sources $WORKDIR/sourcelist
		echo true > $WORKDIR/UPDATE_SOURCELIST
	fi
	;;
-search_albumart_update)
	read START_NR < $WORKDIR/albumart_search_START_NR
	TOTAL=`grep -c ^ $WORKDIR/tmp_search_albumart`
	#are we navigating in album-arts
	case $2 in
		prev)
			if [ $(($START_NR-1)) -gt $ALBUMART_SEARCH_NR ]; then
				START_NR=$(($START_NR-$ALBUMART_SEARCH_NR-1))
				ICON_LEFT=icon_go_left
			else
				START_NR=0
				ICON_LEFT=blank
			fi
			ICON_RIGHT=icon_go_right
			;;
		next)
			START_NR=$(($START_NR+$ALBUMART_SEARCH_NR+1))
			[ $START_NR -gt $TOTAL ] && exit
			ICON_LEFT=icon_go_left
			ICON_RIGHT=icon_go_right
			;;
		*)
			START_NR=0
			ICON_LEFT=blank
			ln -sf $APPDIR/themes/$THEME/blank.svg $WORKDIR/albumart_search_prev.svg
			[[ $ALBUMART_SEARCH_NR -ge $TOTAL || -z $WORKDIR/tmp_search_albumart ]] && ICON_RIGHT=blank || ICON_RIGHT=icon_go_right
			;;
	esac
	echo $START_NR > $WORKDIR/albumart_search_START_NR
	#---
	rm $WORKDIR/albumart_search*.jpg
	COUNT=0
	NR=1
	IFS=$'\n'
	while read I in; do
		#define arrow-buttons
		COUNT=$(($COUNT+1))
		[ $COUNT -lt $START_NR ] && continue
		[ $COUNT = $TOTAL ] && ICON_RIGHT=blank
		#check if pic exist
		[ ! -f "$I" ] && I="`find "$STORAGE_DIR"/albumart -iname "${I##*/}" -printf "%p\n" | head -n1`" #accept chars/capitals
		[ ! -f "$I" ] && continue
		#---
		ln -sf "$I" $WORKDIR/albumart_search$NR.jpg
		NR=$(($NR+1))
		[ $NR -gt $ALBUMART_SEARCH_NR ] && break
	done < $WORKDIR/tmp_search_albumart
	ln -sf $APPDIR/themes/$THEME/$ICON_LEFT.svg $WORKDIR/albumart_search_prev.svg
	ln -sf $APPDIR/themes/$THEME/$ICON_RIGHT.svg $WORKDIR/albumart_search_next.svg
	;;
-pfilesearch)
	#check if pFilesearch is installed
	if ! type pfilesearch > /dev/null 2>&1; then
		TXT1="<b>pFilesearch</b> $(gettext 'is not installed')"
		. $APPDIR/box_ok
		exit
	fi
	#---
	pfilesearch -bb -f music -d "$SEARCHPATH"
	sort -u --output=$WORKDIR/tmp $HOME/.pfilesearch/hits
	paste -d'|' $WORKDIR/tmp $WORKDIR/tmp > $WORKDIR/sourcelist
	echo true > $WORKDIR/UPDATE_SOURCELIST
	;;


##############       Misc        #################

-index_recent)
	tail -n 1000 "$STORAGE_DIR/index_recent" > $WORKDIR/tmp_index #keep only last 1000
	tac $WORKDIR/tmp_index > $WORKDIR/sourcelist
	mv -f $WORKDIR/tmp_index "$STORAGE_DIR/index_recent"
	$APPDIR/func -add_to_history "pMusic: $(gettext 'Recent played')" & #update history
	;;

-index_history)
	tail -n 100 "$STORAGE_DIR/index_history" > $WORKDIR/tmp_index #keep only last 100
	tac $WORKDIR/tmp_index | cut -d '|' -f2- > $WORKDIR/sourcelist #reverse list to get last item on top
	mv -f $WORKDIR/tmp_index "$STORAGE_DIR/index_history"
	$APPDIR/func -add_to_history "pMusic: $(gettext 'History')" & #update history
	;;

-info_IWantMusic)
	HEADING="$(gettext 'I want music')"
	IMG='none'
	FRAME="$(gettext 'info')"
	TXT1="$(gettext 'In addition to be an audioplayer and music manager, pMusic is also a tool to build up your own local music collection. This includes audio, lyrics, album art and album playlists.

In the Music-Source menu, you will find different ways to access music. One of the sources is the RadioHits Grabber that records a radio station and splits the music tracks into different files with correct naming. More info there...

When it comes to lyrics, album art and album playlists, these are downloaded while playing a track. pMusic can store them to a given directory. This is set in the preferences.

A local storage is recommended for snapiness. Lyrics and album art will work ok without a local storage, but not Album playlists. pMusic will search through your music collection and put together songs belonging to each album. These album playlists (and their tracks) will be available when searching, and in the track info window.

pMusic also supports jamendo.com which is a website for free music. It contains a huge amount of music; freely available for you.')"
	. $APPDIR/box_ok &
	;;
esac
